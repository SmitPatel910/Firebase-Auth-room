{"ast":null,"code":"var _toConsumableArray = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _objectWithoutProperties = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectWithoutProperties\");\n\nvar _objectSpread = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar _require = require('zlib'),\n    inflateRawSync = _require.inflateRawSync;\n\nvar base64url = require('../help/base64url');\n\nvar getKey = require('../help/get_key');\n\nvar _require2 = require('../jwks'),\n    KeyStore = _require2.KeyStore;\n\nvar errors = require('../errors');\n\nvar _require3 = require('../jwa'),\n    check = _require3.check,\n    decrypt = _require3.decrypt,\n    keyManagementDecrypt = _require3.keyManagementDecrypt;\n\nvar JWK = require('../jwk');\n\nvar _require4 = require('../help/key_object'),\n    createSecretKey = _require4.createSecretKey;\n\nvar generateCEK = require('./generate_cek');\n\nvar validateHeaders = require('./validate_headers');\n\nvar _require5 = require('./serializers'),\n    resolveSerialization = _require5.detect;\n\nvar SINGLE_RECIPIENT = new Set(['compact', 'flattened']);\n\nvar combineHeader = function combineHeader() {\n  var prot = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var unprotected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var header = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (typeof prot === 'string') {\n    prot = base64url.JSON.decode(prot);\n  }\n\n  var p2s = prot.p2s || unprotected.p2s || header.p2s;\n  var apu = prot.apu || unprotected.apu || header.apu;\n  var apv = prot.apv || unprotected.apv || header.apv;\n  var iv = prot.iv || unprotected.iv || header.iv;\n  var tag = prot.tag || unprotected.tag || header.tag;\n  return _objectSpread({}, prot, unprotected, header, typeof p2s === 'string' ? {\n    p2s: base64url.decodeToBuffer(p2s)\n  } : undefined, typeof apu === 'string' ? {\n    apu: base64url.decodeToBuffer(apu)\n  } : undefined, typeof apv === 'string' ? {\n    apv: base64url.decodeToBuffer(apv)\n  } : undefined, typeof iv === 'string' ? {\n    iv: base64url.decodeToBuffer(iv)\n  } : undefined, typeof tag === 'string' ? {\n    tag: base64url.decodeToBuffer(tag)\n  } : undefined);\n};\n\nvar validateAlgorithms = function validateAlgorithms(algorithms, option) {\n  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some(function (s) {\n    return typeof s !== 'string' || !s;\n  }))) {\n    throw new TypeError(\"\\\"\".concat(option, \"\\\" option must be an array of non-empty strings\"));\n  }\n\n  if (!algorithms) {\n    return undefined;\n  }\n\n  return new Set(algorithms);\n};\n/*\n * @public\n */\n\n\nvar jweDecrypt = function jweDecrypt(skipValidateHeaders, serialization, jwe, key) {\n  var _ref = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {},\n      _ref$crit = _ref.crit,\n      crit = _ref$crit === void 0 ? [] : _ref$crit,\n      _ref$complete = _ref.complete,\n      complete = _ref$complete === void 0 ? false : _ref$complete,\n      keyManagementAlgorithms = _ref.keyManagementAlgorithms,\n      contentEncryptionAlgorithms = _ref.contentEncryptionAlgorithms;\n\n  key = getKey(key, true);\n  keyManagementAlgorithms = validateAlgorithms(keyManagementAlgorithms, 'keyManagementAlgorithms');\n  contentEncryptionAlgorithms = validateAlgorithms(contentEncryptionAlgorithms, 'contentEncryptionAlgorithms');\n\n  if (!Array.isArray(crit) || crit.some(function (s) {\n    return typeof s !== 'string' || !s;\n  })) {\n    throw new TypeError('\"crit\" option must be an array of non-empty strings');\n  }\n\n  if (!serialization) {\n    serialization = resolveSerialization(jwe);\n  }\n\n  var alg, ciphertext, enc, encryptedKey, iv, opts, prot, tag, unprotected, cek, aad, header; // treat general format with one recipient as flattened\n  // skips iteration and avoids multi errors in this case\n\n  if (serialization === 'general' && jwe.recipients.length === 1) {\n    serialization = 'flattened';\n\n    var _jwe = jwe,\n        _recipients = _jwe.recipients,\n        _root = _objectWithoutProperties(_jwe, [\"recipients\"]);\n\n    jwe = _objectSpread({}, _root, _recipients[0]);\n  }\n\n  if (SINGLE_RECIPIENT.has(serialization)) {\n    if (serialization === 'compact') {\n      // compact serialization format\n      var _jwe$split = jwe.split('.');\n\n      var _jwe$split2 = _slicedToArray(_jwe$split, 5);\n\n      prot = _jwe$split2[0];\n      encryptedKey = _jwe$split2[1];\n      iv = _jwe$split2[2];\n      ciphertext = _jwe$split2[3];\n      tag = _jwe$split2[4];\n    } else {\n      // flattened serialization format\n      var _jwe2 = jwe;\n      prot = _jwe2.protected;\n      encryptedKey = _jwe2.encrypted_key;\n      iv = _jwe2.iv;\n      ciphertext = _jwe2.ciphertext;\n      tag = _jwe2.tag;\n      unprotected = _jwe2.unprotected;\n      aad = _jwe2.aad;\n      header = _jwe2.header;\n    }\n\n    if (!skipValidateHeaders) {\n      validateHeaders(prot, unprotected, [{\n        header: header\n      }], true, crit);\n    }\n\n    opts = combineHeader(prot, unprotected, header);\n    var _opts = opts;\n    alg = _opts.alg;\n    enc = _opts.enc;\n\n    if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) {\n      throw new errors.JOSEAlgNotWhitelisted('key management algorithm not whitelisted');\n    }\n\n    if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {\n      throw new errors.JOSEAlgNotWhitelisted('content encryption algorithm not whitelisted');\n    }\n\n    if (key instanceof KeyStore) {\n      var keystore = key;\n      var keys;\n\n      if (opts.alg === 'dir') {\n        keys = keystore.all({\n          kid: opts.kid,\n          alg: opts.enc,\n          key_ops: ['decrypt']\n        });\n      } else {\n        keys = keystore.all({\n          kid: opts.kid,\n          alg: opts.alg,\n          key_ops: ['unwrapKey']\n        });\n      }\n\n      switch (keys.length) {\n        case 0:\n          throw new errors.JWKSNoMatchingKey();\n\n        case 1:\n          // treat the call as if a Key instance was passed in\n          // skips iteration and avoids multi errors in this case\n          key = keys[0];\n          break;\n\n        default:\n          {\n            var _errs = [];\n\n            var _iterator = _createForOfIteratorHelper(keys),\n                _step;\n\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var _key = _step.value;\n\n                try {\n                  return jweDecrypt(true, serialization, jwe, _key, {\n                    crit: crit,\n                    complete: complete,\n                    contentEncryptionAlgorithms: contentEncryptionAlgorithms ? _toConsumableArray(contentEncryptionAlgorithms) : undefined,\n                    keyManagementAlgorithms: keyManagementAlgorithms ? _toConsumableArray(keyManagementAlgorithms) : undefined\n                  });\n                } catch (err) {\n                  _errs.push(err);\n\n                  continue;\n                }\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n\n            var _multi = new errors.JOSEMultiError(_errs);\n\n            if (_toConsumableArray(_multi).some(function (e) {\n              return e instanceof errors.JWEDecryptionFailed;\n            })) {\n              throw new errors.JWEDecryptionFailed();\n            }\n\n            throw _multi;\n          }\n      }\n    }\n\n    check.apply(void 0, [key].concat(_toConsumableArray(alg === 'dir' ? ['decrypt', enc] : ['keyManagementDecrypt', alg])));\n\n    try {\n      if (alg === 'dir') {\n        cek = JWK.asKey(key, {\n          alg: enc,\n          use: 'enc'\n        });\n      } else if (alg === 'ECDH-ES') {\n        var unwrapped = keyManagementDecrypt(alg, key, undefined, opts);\n        cek = JWK.asKey(createSecretKey(unwrapped), {\n          alg: enc,\n          use: 'enc'\n        });\n      } else {\n        var _unwrapped = keyManagementDecrypt(alg, key, base64url.decodeToBuffer(encryptedKey), opts);\n\n        cek = JWK.asKey(createSecretKey(_unwrapped), {\n          alg: enc,\n          use: 'enc'\n        });\n      }\n    } catch (err) {\n      // To mitigate the attacks described in RFC 3218, the\n      // recipient MUST NOT distinguish between format, padding, and length\n      // errors of encrypted keys.  It is strongly recommended, in the event\n      // of receiving an improperly formatted key, that the recipient\n      // substitute a randomly generated CEK and proceed to the next step, to\n      // mitigate timing attacks.\n      cek = generateCEK(enc);\n    }\n\n    var adata;\n\n    if (aad) {\n      adata = Buffer.concat([Buffer.from(prot || ''), Buffer.from('.'), Buffer.from(aad)]);\n    } else {\n      adata = Buffer.from(prot || '');\n    }\n\n    try {\n      iv = base64url.decodeToBuffer(iv);\n    } catch (err) {}\n\n    try {\n      tag = base64url.decodeToBuffer(tag);\n    } catch (err) {}\n\n    var cleartext = decrypt(enc, cek, base64url.decodeToBuffer(ciphertext), {\n      iv: iv,\n      tag: tag,\n      aad: adata\n    });\n\n    if (opts.zip) {\n      cleartext = inflateRawSync(cleartext);\n    }\n\n    if (complete) {\n      var result = {\n        cleartext: cleartext,\n        key: key,\n        cek: cek\n      };\n      if (aad) result.aad = aad;\n      if (header) result.header = header;\n      if (unprotected) result.unprotected = unprotected;\n      if (prot) result.protected = base64url.JSON.decode(prot);\n      return result;\n    }\n\n    return cleartext;\n  }\n\n  validateHeaders(jwe.protected, jwe.unprotected, jwe.recipients.map(function (_ref2) {\n    var header = _ref2.header;\n    return {\n      header: header\n    };\n  }), true, crit); // general serialization format\n\n  var _jwe3 = jwe,\n      recipients = _jwe3.recipients,\n      root = _objectWithoutProperties(_jwe3, [\"recipients\"]);\n\n  var errs = [];\n\n  var _iterator2 = _createForOfIteratorHelper(recipients),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var recipient = _step2.value;\n\n      try {\n        return jweDecrypt(true, 'flattened', _objectSpread({}, root, recipient), key, {\n          crit: crit,\n          complete: complete,\n          contentEncryptionAlgorithms: contentEncryptionAlgorithms ? _toConsumableArray(contentEncryptionAlgorithms) : undefined,\n          keyManagementAlgorithms: keyManagementAlgorithms ? _toConsumableArray(keyManagementAlgorithms) : undefined\n        });\n      } catch (err) {\n        errs.push(err);\n        continue;\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  var multi = new errors.JOSEMultiError(errs);\n\n  if (_toConsumableArray(multi).some(function (e) {\n    return e instanceof errors.JWEDecryptionFailed;\n  })) {\n    throw new errors.JWEDecryptionFailed();\n  } else if (_toConsumableArray(multi).every(function (e) {\n    return e instanceof errors.JWKSNoMatchingKey;\n  })) {\n    throw new errors.JWKSNoMatchingKey();\n  }\n\n  throw multi;\n};\n\nmodule.exports = jweDecrypt.bind(undefined, false, undefined);","map":null,"metadata":{},"sourceType":"script"}