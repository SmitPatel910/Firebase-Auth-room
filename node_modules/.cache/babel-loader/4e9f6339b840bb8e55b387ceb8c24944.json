{"ast":null,"code":"/*! firebase-admin v9.11.0 */\n\"use strict\";\n/*!\n * Copyright 2020 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getApplicationDefault = exports.isApplicationDefault = exports.RefreshTokenCredential = exports.ComputeEngineCredential = exports.ServiceAccountCredential = void 0;\n\nvar fs = require(\"fs\");\n\nvar os = require(\"os\");\n\nvar path = require(\"path\");\n\nvar error_1 = require(\"../utils/error\");\n\nvar api_request_1 = require(\"../utils/api-request\");\n\nvar util = require(\"../utils/validator\");\n\nvar GOOGLE_TOKEN_AUDIENCE = 'https://accounts.google.com/o/oauth2/token';\nvar GOOGLE_AUTH_TOKEN_HOST = 'accounts.google.com';\nvar GOOGLE_AUTH_TOKEN_PATH = '/o/oauth2/token'; // NOTE: the Google Metadata Service uses HTTP over a vlan\n\nvar GOOGLE_METADATA_SERVICE_HOST = 'metadata.google.internal';\nvar GOOGLE_METADATA_SERVICE_TOKEN_PATH = '/computeMetadata/v1/instance/service-accounts/default/token';\nvar GOOGLE_METADATA_SERVICE_PROJECT_ID_PATH = '/computeMetadata/v1/project/project-id';\n\nvar configDir = function () {\n  // Windows has a dedicated low-rights location for apps at ~/Application Data\n  var sys = os.platform();\n\n  if (sys && sys.length >= 3 && sys.substring(0, 3).toLowerCase() === 'win') {\n    return process.env.APPDATA;\n  } // On *nix the gcloud cli creates a . dir.\n\n\n  return process.env.HOME && path.resolve(process.env.HOME, '.config');\n}();\n\nvar GCLOUD_CREDENTIAL_SUFFIX = 'gcloud/application_default_credentials.json';\nvar GCLOUD_CREDENTIAL_PATH = configDir && path.resolve(configDir, GCLOUD_CREDENTIAL_SUFFIX);\nvar REFRESH_TOKEN_HOST = 'www.googleapis.com';\nvar REFRESH_TOKEN_PATH = '/oauth2/v4/token';\nvar ONE_HOUR_IN_SECONDS = 60 * 60;\nvar JWT_ALGORITHM = 'RS256';\n/**\n * Implementation of Credential that uses a service account.\n */\n\nvar ServiceAccountCredential =\n/** @class */\nfunction () {\n  /**\n   * Creates a new ServiceAccountCredential from the given parameters.\n   *\n   * @param serviceAccountPathOrObject Service account json object or path to a service account json file.\n   * @param httpAgent Optional http.Agent to use when calling the remote token server.\n   * @param implicit An optinal boolean indicating whether this credential was implicitly discovered from the\n   *   environment, as opposed to being explicitly specified by the developer.\n   *\n   * @constructor\n   */\n  function ServiceAccountCredential(serviceAccountPathOrObject, httpAgent, implicit) {\n    if (implicit === void 0) {\n      implicit = false;\n    }\n\n    this.httpAgent = httpAgent;\n    this.implicit = implicit;\n    var serviceAccount = typeof serviceAccountPathOrObject === 'string' ? ServiceAccount.fromPath(serviceAccountPathOrObject) : new ServiceAccount(serviceAccountPathOrObject);\n    this.projectId = serviceAccount.projectId;\n    this.privateKey = serviceAccount.privateKey;\n    this.clientEmail = serviceAccount.clientEmail;\n    this.httpClient = new api_request_1.HttpClient();\n  }\n\n  ServiceAccountCredential.prototype.getAccessToken = function () {\n    var token = this.createAuthJwt_();\n    var postData = 'grant_type=urn%3Aietf%3Aparams%3Aoauth%3A' + 'grant-type%3Ajwt-bearer&assertion=' + token;\n    var request = {\n      method: 'POST',\n      url: \"https://\" + GOOGLE_AUTH_TOKEN_HOST + GOOGLE_AUTH_TOKEN_PATH,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      },\n      data: postData,\n      httpAgent: this.httpAgent\n    };\n    return requestAccessToken(this.httpClient, request);\n  };\n\n  ServiceAccountCredential.prototype.createAuthJwt_ = function () {\n    var claims = {\n      scope: ['https://www.googleapis.com/auth/cloud-platform', 'https://www.googleapis.com/auth/firebase.database', 'https://www.googleapis.com/auth/firebase.messaging', 'https://www.googleapis.com/auth/identitytoolkit', 'https://www.googleapis.com/auth/userinfo.email'].join(' ')\n    }; // eslint-disable-next-line @typescript-eslint/no-var-requires\n\n    var jwt = require('jsonwebtoken'); // This method is actually synchronous so we can capture and return the buffer.\n\n\n    return jwt.sign(claims, this.privateKey, {\n      audience: GOOGLE_TOKEN_AUDIENCE,\n      expiresIn: ONE_HOUR_IN_SECONDS,\n      issuer: this.clientEmail,\n      algorithm: JWT_ALGORITHM\n    });\n  };\n\n  return ServiceAccountCredential;\n}();\n\nexports.ServiceAccountCredential = ServiceAccountCredential;\n/**\n * A struct containing the properties necessary to use service account JSON credentials.\n */\n\nvar ServiceAccount =\n/** @class */\nfunction () {\n  function ServiceAccount(json) {\n    if (!util.isNonNullObject(json)) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Service account must be an object.');\n    }\n\n    copyAttr(this, json, 'projectId', 'project_id');\n    copyAttr(this, json, 'privateKey', 'private_key');\n    copyAttr(this, json, 'clientEmail', 'client_email');\n    var errorMessage;\n\n    if (!util.isNonEmptyString(this.projectId)) {\n      errorMessage = 'Service account object must contain a string \"project_id\" property.';\n    } else if (!util.isNonEmptyString(this.privateKey)) {\n      errorMessage = 'Service account object must contain a string \"private_key\" property.';\n    } else if (!util.isNonEmptyString(this.clientEmail)) {\n      errorMessage = 'Service account object must contain a string \"client_email\" property.';\n    }\n\n    if (typeof errorMessage !== 'undefined') {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\n    } // eslint-disable-next-line @typescript-eslint/no-var-requires\n\n\n    var forge = require('node-forge');\n\n    try {\n      forge.pki.privateKeyFromPem(this.privateKey);\n    } catch (error) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse private key: ' + error);\n    }\n  }\n\n  ServiceAccount.fromPath = function (filePath) {\n    try {\n      return new ServiceAccount(JSON.parse(fs.readFileSync(filePath, 'utf8')));\n    } catch (error) {\n      // Throw a nicely formed error message if the file contents cannot be parsed\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse service account json file: ' + error);\n    }\n  };\n\n  return ServiceAccount;\n}();\n/**\n * Implementation of Credential that gets access tokens from the metadata service available\n * in the Google Cloud Platform. This authenticates the process as the default service account\n * of an App Engine instance or Google Compute Engine machine.\n */\n\n\nvar ComputeEngineCredential =\n/** @class */\nfunction () {\n  function ComputeEngineCredential(httpAgent) {\n    this.httpClient = new api_request_1.HttpClient();\n    this.httpAgent = httpAgent;\n  }\n\n  ComputeEngineCredential.prototype.getAccessToken = function () {\n    var request = this.buildRequest(GOOGLE_METADATA_SERVICE_TOKEN_PATH);\n    return requestAccessToken(this.httpClient, request);\n  };\n\n  ComputeEngineCredential.prototype.getProjectId = function () {\n    var _this = this;\n\n    if (this.projectId) {\n      return Promise.resolve(this.projectId);\n    }\n\n    var request = this.buildRequest(GOOGLE_METADATA_SERVICE_PROJECT_ID_PATH);\n    return this.httpClient.send(request).then(function (resp) {\n      _this.projectId = resp.text;\n      return _this.projectId;\n    }).catch(function (err) {\n      var detail = err instanceof api_request_1.HttpError ? getDetailFromResponse(err.response) : err.message;\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, \"Failed to determine project ID: \" + detail);\n    });\n  };\n\n  ComputeEngineCredential.prototype.buildRequest = function (urlPath) {\n    return {\n      method: 'GET',\n      url: \"http://\" + GOOGLE_METADATA_SERVICE_HOST + urlPath,\n      headers: {\n        'Metadata-Flavor': 'Google'\n      },\n      httpAgent: this.httpAgent\n    };\n  };\n\n  return ComputeEngineCredential;\n}();\n\nexports.ComputeEngineCredential = ComputeEngineCredential;\n/**\n * Implementation of Credential that gets access tokens from refresh tokens.\n */\n\nvar RefreshTokenCredential =\n/** @class */\nfunction () {\n  /**\n   * Creates a new RefreshTokenCredential from the given parameters.\n   *\n   * @param refreshTokenPathOrObject Refresh token json object or path to a refresh token (user credentials) json file.\n   * @param httpAgent Optional http.Agent to use when calling the remote token server.\n   * @param implicit An optinal boolean indicating whether this credential was implicitly discovered from the\n   *   environment, as opposed to being explicitly specified by the developer.\n   *\n   * @constructor\n   */\n  function RefreshTokenCredential(refreshTokenPathOrObject, httpAgent, implicit) {\n    if (implicit === void 0) {\n      implicit = false;\n    }\n\n    this.httpAgent = httpAgent;\n    this.implicit = implicit;\n    this.refreshToken = typeof refreshTokenPathOrObject === 'string' ? RefreshToken.fromPath(refreshTokenPathOrObject) : new RefreshToken(refreshTokenPathOrObject);\n    this.httpClient = new api_request_1.HttpClient();\n  }\n\n  RefreshTokenCredential.prototype.getAccessToken = function () {\n    var postData = 'client_id=' + this.refreshToken.clientId + '&' + 'client_secret=' + this.refreshToken.clientSecret + '&' + 'refresh_token=' + this.refreshToken.refreshToken + '&' + 'grant_type=refresh_token';\n    var request = {\n      method: 'POST',\n      url: \"https://\" + REFRESH_TOKEN_HOST + REFRESH_TOKEN_PATH,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      },\n      data: postData,\n      httpAgent: this.httpAgent\n    };\n    return requestAccessToken(this.httpClient, request);\n  };\n\n  return RefreshTokenCredential;\n}();\n\nexports.RefreshTokenCredential = RefreshTokenCredential;\n\nvar RefreshToken =\n/** @class */\nfunction () {\n  function RefreshToken(json) {\n    copyAttr(this, json, 'clientId', 'client_id');\n    copyAttr(this, json, 'clientSecret', 'client_secret');\n    copyAttr(this, json, 'refreshToken', 'refresh_token');\n    copyAttr(this, json, 'type', 'type');\n    var errorMessage;\n\n    if (!util.isNonEmptyString(this.clientId)) {\n      errorMessage = 'Refresh token must contain a \"client_id\" property.';\n    } else if (!util.isNonEmptyString(this.clientSecret)) {\n      errorMessage = 'Refresh token must contain a \"client_secret\" property.';\n    } else if (!util.isNonEmptyString(this.refreshToken)) {\n      errorMessage = 'Refresh token must contain a \"refresh_token\" property.';\n    } else if (!util.isNonEmptyString(this.type)) {\n      errorMessage = 'Refresh token must contain a \"type\" property.';\n    }\n\n    if (typeof errorMessage !== 'undefined') {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\n    }\n  }\n  /*\n   * Tries to load a RefreshToken from a path. Throws if the path doesn't exist or the\n   * data at the path is invalid.\n   */\n\n\n  RefreshToken.fromPath = function (filePath) {\n    try {\n      return new RefreshToken(JSON.parse(fs.readFileSync(filePath, 'utf8')));\n    } catch (error) {\n      // Throw a nicely formed error message if the file contents cannot be parsed\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse refresh token file: ' + error);\n    }\n  };\n\n  return RefreshToken;\n}();\n/**\n * Checks if the given credential was loaded via the application default credentials mechanism. This\n * includes all ComputeEngineCredential instances, and the ServiceAccountCredential and RefreshTokenCredential\n * instances that were loaded from well-known files or environment variables, rather than being explicitly\n * instantiated.\n *\n * @param credential The credential instance to check.\n */\n\n\nfunction isApplicationDefault(credential) {\n  return credential instanceof ComputeEngineCredential || credential instanceof ServiceAccountCredential && credential.implicit || credential instanceof RefreshTokenCredential && credential.implicit;\n}\n\nexports.isApplicationDefault = isApplicationDefault;\n\nfunction getApplicationDefault(httpAgent) {\n  if (process.env.GOOGLE_APPLICATION_CREDENTIALS) {\n    return credentialFromFile(process.env.GOOGLE_APPLICATION_CREDENTIALS, httpAgent);\n  } // It is OK to not have this file. If it is present, it must be valid.\n\n\n  if (GCLOUD_CREDENTIAL_PATH) {\n    var refreshToken = readCredentialFile(GCLOUD_CREDENTIAL_PATH, true);\n\n    if (refreshToken) {\n      return new RefreshTokenCredential(refreshToken, httpAgent, true);\n    }\n  }\n\n  return new ComputeEngineCredential(httpAgent);\n}\n\nexports.getApplicationDefault = getApplicationDefault;\n/**\n * Copies the specified property from one object to another.\n *\n * If no property exists by the given \"key\", looks for a property identified by \"alt\", and copies it instead.\n * This can be used to implement behaviors such as \"copy property myKey or my_key\".\n *\n * @param to Target object to copy the property into.\n * @param from Source object to copy the property from.\n * @param key Name of the property to copy.\n * @param alt Alternative name of the property to copy.\n */\n\nfunction copyAttr(to, from, key, alt) {\n  var tmp = from[key] || from[alt];\n\n  if (typeof tmp !== 'undefined') {\n    to[key] = tmp;\n  }\n}\n/**\n * Obtain a new OAuth2 token by making a remote service call.\n */\n\n\nfunction requestAccessToken(client, request) {\n  return client.send(request).then(function (resp) {\n    var json = resp.data;\n\n    if (!json.access_token || !json.expires_in) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, \"Unexpected response while fetching access token: \" + JSON.stringify(json));\n    }\n\n    return json;\n  }).catch(function (err) {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, getErrorMessage(err));\n  });\n}\n/**\n * Constructs a human-readable error message from the given Error.\n */\n\n\nfunction getErrorMessage(err) {\n  var detail = err instanceof api_request_1.HttpError ? getDetailFromResponse(err.response) : err.message;\n  return \"Error fetching access token: \" + detail;\n}\n/**\n * Extracts details from the given HTTP error response, and returns a human-readable description. If\n * the response is JSON-formatted, looks up the error and error_description fields sent by the\n * Google Auth servers. Otherwise returns the entire response payload as the error detail.\n */\n\n\nfunction getDetailFromResponse(response) {\n  if (response.isJson() && response.data.error) {\n    var json = response.data;\n    var detail = json.error;\n\n    if (json.error_description) {\n      detail += ' (' + json.error_description + ')';\n    }\n\n    return detail;\n  }\n\n  return response.text || 'Missing error payload';\n}\n\nfunction credentialFromFile(filePath, httpAgent) {\n  var credentialsFile = readCredentialFile(filePath);\n\n  if (typeof credentialsFile !== 'object' || credentialsFile === null) {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse contents of the credentials file as an object');\n  }\n\n  if (credentialsFile.type === 'service_account') {\n    return new ServiceAccountCredential(credentialsFile, httpAgent, true);\n  }\n\n  if (credentialsFile.type === 'authorized_user') {\n    return new RefreshTokenCredential(credentialsFile, httpAgent, true);\n  }\n\n  throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Invalid contents in the credentials file');\n}\n\nfunction readCredentialFile(filePath, ignoreMissing) {\n  var fileText;\n\n  try {\n    fileText = fs.readFileSync(filePath, 'utf8');\n  } catch (error) {\n    if (ignoreMissing) {\n      return null;\n    }\n\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, \"Failed to read credentials from file \" + filePath + \": \" + error);\n  }\n\n  try {\n    return JSON.parse(fileText);\n  } catch (error) {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse contents of the credentials file as an object: ' + error);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}