{"ast":null,"code":"/*! firebase-admin v9.11.0 */\n\"use strict\";\n/*!\n * @license\n * Copyright 2021 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.appCheckErrorFromCryptoSignerError = exports.AppCheckTokenGenerator = void 0;\n\nvar validator = require(\"../utils/validator\");\n\nvar utils_1 = require(\"../utils\");\n\nvar crypto_signer_1 = require(\"../utils/crypto-signer\");\n\nvar app_check_api_client_internal_1 = require(\"./app-check-api-client-internal\");\n\nvar ONE_MINUTE_IN_SECONDS = 60;\nvar ONE_MINUTE_IN_MILLIS = ONE_MINUTE_IN_SECONDS * 1000;\nvar ONE_DAY_IN_MILLIS = 24 * 60 * 60 * 1000; // Audience to use for Firebase App Check Custom tokens\n\nvar FIREBASE_APP_CHECK_AUDIENCE = 'https://firebaseappcheck.googleapis.com/google.firebase.appcheck.v1beta.TokenExchangeService';\n/**\n * Class for generating Firebase App Check tokens.\n *\n * @internal\n */\n\nvar AppCheckTokenGenerator =\n/** @class */\nfunction () {\n  /**\n   * The AppCheckTokenGenerator class constructor.\n   *\n   * @param signer The CryptoSigner instance for this token generator.\n   * @constructor\n   */\n  function AppCheckTokenGenerator(signer) {\n    if (!validator.isNonNullObject(signer)) {\n      throw new app_check_api_client_internal_1.FirebaseAppCheckError('invalid-argument', 'INTERNAL ASSERT: Must provide a CryptoSigner to use AppCheckTokenGenerator.');\n    }\n\n    this.signer = signer;\n  }\n  /**\n   * Creates a new custom token that can be exchanged to an App Check token.\n   *\n   * @param appId The Application ID to use for the generated token.\n   *\n   * @return A Promise fulfilled with a custom token signed with a service account key\n   * that can be exchanged to an App Check token.\n   */\n\n\n  AppCheckTokenGenerator.prototype.createCustomToken = function (appId, options) {\n    var _this = this;\n\n    if (!validator.isNonEmptyString(appId)) {\n      throw new app_check_api_client_internal_1.FirebaseAppCheckError('invalid-argument', '`appId` must be a non-empty string.');\n    }\n\n    var customOptions = {};\n\n    if (typeof options !== 'undefined') {\n      customOptions = this.validateTokenOptions(options);\n    }\n\n    return this.signer.getAccountId().then(function (account) {\n      var header = {\n        alg: _this.signer.algorithm,\n        typ: 'JWT'\n      };\n      var iat = Math.floor(Date.now() / 1000);\n\n      var body = __assign({\n        iss: account,\n        sub: account,\n        // eslint-disable-next-line @typescript-eslint/camelcase\n        app_id: appId,\n        aud: FIREBASE_APP_CHECK_AUDIENCE,\n        exp: iat + ONE_MINUTE_IN_SECONDS * 5,\n        iat: iat\n      }, customOptions);\n\n      var token = _this.encodeSegment(header) + \".\" + _this.encodeSegment(body);\n\n      return _this.signer.sign(Buffer.from(token)).then(function (signature) {\n        return token + \".\" + _this.encodeSegment(signature);\n      });\n    }).catch(function (err) {\n      throw appCheckErrorFromCryptoSignerError(err);\n    });\n  };\n\n  AppCheckTokenGenerator.prototype.encodeSegment = function (segment) {\n    var buffer = segment instanceof Buffer ? segment : Buffer.from(JSON.stringify(segment));\n    return utils_1.toWebSafeBase64(buffer).replace(/=+$/, '');\n  };\n  /**\n   * Checks if a given `AppCheckTokenOptions` object is valid. If successful, returns an object with\n   * custom properties.\n   *\n   * @param options An options object to be validated.\n   * @returns A custom object with ttl converted to protobuf Duration string format.\n   */\n\n\n  AppCheckTokenGenerator.prototype.validateTokenOptions = function (options) {\n    if (!validator.isNonNullObject(options)) {\n      throw new app_check_api_client_internal_1.FirebaseAppCheckError('invalid-argument', 'AppCheckTokenOptions must be a non-null object.');\n    }\n\n    if (typeof options.ttlMillis !== 'undefined') {\n      if (!validator.isNumber(options.ttlMillis)) {\n        throw new app_check_api_client_internal_1.FirebaseAppCheckError('invalid-argument', 'ttlMillis must be a duration in milliseconds.');\n      } // ttlMillis must be between 30 minutes and 7 days (inclusive)\n\n\n      if (options.ttlMillis < ONE_MINUTE_IN_MILLIS * 30 || options.ttlMillis > ONE_DAY_IN_MILLIS * 7) {\n        throw new app_check_api_client_internal_1.FirebaseAppCheckError('invalid-argument', 'ttlMillis must be a duration in milliseconds between 30 minutes and 7 days (inclusive).');\n      }\n\n      return {\n        ttl: utils_1.transformMillisecondsToSecondsString(options.ttlMillis)\n      };\n    }\n\n    return {};\n  };\n\n  return AppCheckTokenGenerator;\n}();\n\nexports.AppCheckTokenGenerator = AppCheckTokenGenerator;\n/**\n * Creates a new FirebaseAppCheckError by extracting the error code, message and other relevant\n * details from a CryptoSignerError.\n *\n * @param err The Error to convert into a FirebaseAppCheckError error\n * @return A Firebase App Check error that can be returned to the user.\n */\n\nfunction appCheckErrorFromCryptoSignerError(err) {\n  if (!(err instanceof crypto_signer_1.CryptoSignerError)) {\n    return err;\n  }\n\n  if (err.code === crypto_signer_1.CryptoSignerErrorCode.SERVER_ERROR && validator.isNonNullObject(err.cause)) {\n    var httpError = err.cause;\n    var errorResponse = httpError.response.data;\n\n    if (errorResponse === null || errorResponse === void 0 ? void 0 : errorResponse.error) {\n      var status = errorResponse.error.status;\n      var description = errorResponse.error.message || JSON.stringify(httpError.response);\n      var code = 'unknown-error';\n\n      if (status && status in app_check_api_client_internal_1.APP_CHECK_ERROR_CODE_MAPPING) {\n        code = app_check_api_client_internal_1.APP_CHECK_ERROR_CODE_MAPPING[status];\n      }\n\n      return new app_check_api_client_internal_1.FirebaseAppCheckError(code, \"Error returned from server while signing a custom token: \" + description);\n    }\n\n    return new app_check_api_client_internal_1.FirebaseAppCheckError('internal-error', 'Error returned from server: ' + JSON.stringify(errorResponse) + '.');\n  }\n\n  return new app_check_api_client_internal_1.FirebaseAppCheckError(mapToAppCheckErrorCode(err.code), err.message);\n}\n\nexports.appCheckErrorFromCryptoSignerError = appCheckErrorFromCryptoSignerError;\n\nfunction mapToAppCheckErrorCode(code) {\n  switch (code) {\n    case crypto_signer_1.CryptoSignerErrorCode.INVALID_CREDENTIAL:\n      return 'invalid-credential';\n\n    case crypto_signer_1.CryptoSignerErrorCode.INVALID_ARGUMENT:\n      return 'invalid-argument';\n\n    default:\n      return 'internal-error';\n  }\n}","map":null,"metadata":{},"sourceType":"script"}