{"ast":null,"code":"\"use strict\";\n\nmodule.exports = fetch;\n\nvar asPromise = require(\"@protobufjs/aspromise\"),\n    inquire = require(\"@protobufjs/inquire\");\n\nvar fs = inquire(\"fs\");\n/**\r\n * Node-style callback as used by {@link util.fetch}.\r\n * @typedef FetchCallback\r\n * @type {function}\r\n * @param {?Error} error Error, if any, otherwise `null`\r\n * @param {string} [contents] File contents, if there hasn't been an error\r\n * @returns {undefined}\r\n */\n\n/**\r\n * Options as used by {@link util.fetch}.\r\n * @typedef FetchOptions\r\n * @type {Object}\r\n * @property {boolean} [binary=false] Whether expecting a binary response\r\n * @property {boolean} [xhr=false] If `true`, forces the use of XMLHttpRequest\r\n */\n\n/**\r\n * Fetches the contents of a file.\r\n * @memberof util\r\n * @param {string} filename File path or url\r\n * @param {FetchOptions} options Fetch options\r\n * @param {FetchCallback} callback Callback function\r\n * @returns {undefined}\r\n */\n\nfunction fetch(filename, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  } else if (!options) options = {};\n\n  if (!callback) return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this\n  // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.\n\n  if (!options.xhr && fs && fs.readFile) return fs.readFile(filename, function fetchReadFileCallback(err, contents) {\n    return err && typeof XMLHttpRequest !== \"undefined\" ? fetch.xhr(filename, options, callback) : err ? callback(err) : callback(null, options.binary ? contents : contents.toString(\"utf8\"));\n  }); // use the XHR version otherwise.\n\n  return fetch.xhr(filename, options, callback);\n}\n/**\r\n * Fetches the contents of a file.\r\n * @name util.fetch\r\n * @function\r\n * @param {string} path File path or url\r\n * @param {FetchCallback} callback Callback function\r\n * @returns {undefined}\r\n * @variation 2\r\n */\n\n/**\r\n * Fetches the contents of a file.\r\n * @name util.fetch\r\n * @function\r\n * @param {string} path File path or url\r\n * @param {FetchOptions} [options] Fetch options\r\n * @returns {Promise<string|Uint8Array>} Promise\r\n * @variation 3\r\n */\n\n/**/\n\n\nfetch.xhr = function fetch_xhr(filename, options, callback) {\n  var xhr = new XMLHttpRequest();\n\n  xhr.onreadystatechange\n  /* works everywhere */\n  = function fetchOnReadyStateChange() {\n    if (xhr.readyState !== 4) return undefined; // local cors security errors return status 0 / empty string, too. afaik this cannot be\n    // reliably distinguished from an actually empty file for security reasons. feel free\n    // to send a pull request if you are aware of a solution.\n\n    if (xhr.status !== 0 && xhr.status !== 200) return callback(Error(\"status \" + xhr.status)); // if binary data is expected, make sure that some sort of array is returned, even if\n    // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.\n\n    if (options.binary) {\n      var buffer = xhr.response;\n\n      if (!buffer) {\n        buffer = [];\n\n        for (var i = 0; i < xhr.responseText.length; ++i) {\n          buffer.push(xhr.responseText.charCodeAt(i) & 255);\n        }\n      }\n\n      return callback(null, typeof Uint8Array !== \"undefined\" ? new Uint8Array(buffer) : buffer);\n    }\n\n    return callback(null, xhr.responseText);\n  };\n\n  if (options.binary) {\n    // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers\n    if (\"overrideMimeType\" in xhr) xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\n    xhr.responseType = \"arraybuffer\";\n  }\n\n  xhr.open(\"GET\", filename);\n  xhr.send();\n};","map":null,"metadata":{},"sourceType":"script"}