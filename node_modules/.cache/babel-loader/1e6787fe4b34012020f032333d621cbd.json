{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar assert = require(\"assert\");\n\nvar rbtree = require(\"functional-red-black-tree\");\n\nvar google_gax_1 = require(\"google-gax\");\n\nvar backoff_1 = require(\"./backoff\");\n\nvar document_1 = require(\"./document\");\n\nvar document_change_1 = require(\"./document-change\");\n\nvar logger_1 = require(\"./logger\");\n\nvar path_1 = require(\"./path\");\n\nvar timestamp_1 = require(\"./timestamp\");\n\nvar types_1 = require(\"./types\");\n\nvar util_1 = require(\"./util\");\n/*!\n * Target ID used by watch. Watch uses a fixed target id since we only support\n * one target per stream.\n * @type {number}\n */\n\n\nvar WATCH_TARGET_ID = 0x1;\n/*!\n * Idle timeout used to detect Watch streams that stall (see\n * https://github.com/googleapis/nodejs-firestore/issues/1057, b/156308554).\n * Under normal load, the Watch backend will send a TARGET_CHANGE message\n * roughly every 30 seconds. As discussed with the backend team, we reset the\n * Watch stream if we do not receive any message within 120 seconds.\n */\n\nexports.WATCH_IDLE_TIMEOUT_MS = 120 * 1000;\n/*!\n * Sentinel value for a document remove.\n */\n\nvar REMOVED = {};\n/*!\n * The change type for document change events.\n */\n// tslint:disable-next-line:variable-name\n\nvar ChangeType = {\n  added: 'added',\n  modified: 'modified',\n  removed: 'removed'\n};\n/*!\n * The comparator used for document watches (which should always get called with\n * the same document).\n */\n\nvar DOCUMENT_WATCH_COMPARATOR = function DOCUMENT_WATCH_COMPARATOR(doc1, doc2) {\n  assert(doc1 === doc2, 'Document watches only support one document.');\n  return 0;\n};\n\nvar EMPTY_FUNCTION = function EMPTY_FUNCTION() {};\n/**\n * Watch provides listen functionality and exposes the 'onSnapshot' observer. It\n * can be used with a valid Firestore Listen target.\n *\n * @class\n * @private\n * @internal\n */\n\n\nvar Watch = /*#__PURE__*/function () {\n  /**\n   * @private\n   * @internal\n   * @hideconstructor\n   *\n   * @param firestore The Firestore Database client.\n   */\n  function Watch(firestore) {\n    var _converter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : types_1.defaultConverter();\n\n    _classCallCheck(this, Watch);\n\n    this._converter = _converter;\n    /**\n     * Indicates whether we are interested in data from the stream. Set to false in the\n     * 'unsubscribe()' callback.\n     * @private\n     * @internal\n     */\n\n    this.isActive = true;\n    /**\n     * The current stream to the backend.\n     * @private\n     * @internal\n     */\n\n    this.currentStream = null;\n    /**\n     * The server assigns and updates the resume token.\n     * @private\n     * @internal\n     */\n\n    this.resumeToken = undefined;\n    /**\n     * A map of document names to QueryDocumentSnapshots for the last sent snapshot.\n     * @private\n     * @internal\n     */\n\n    this.docMap = new Map();\n    /**\n     * The accumulated map of document changes (keyed by document name) for the\n     * current snapshot.\n     * @private\n     * @internal\n     */\n\n    this.changeMap = new Map();\n    /**\n     * The current state of the query results. *\n     * @private\n     * @internal\n     */\n\n    this.current = false;\n    /**\n     * We need this to track whether we've pushed an initial set of changes,\n     * since we should push those even when there are no changes, if there\n     * aren't docs.\n     * @private\n     * @internal\n     */\n\n    this.hasPushed = false;\n    this.firestore = firestore;\n    this.backoff = new backoff_1.ExponentialBackoff();\n    this.requestTag = util_1.requestTag();\n    this.onNext = EMPTY_FUNCTION;\n    this.onError = EMPTY_FUNCTION;\n  }\n  /**\n   * Starts a watch and attaches a listener for document change events.\n   *\n   * @private\n   * @internal\n   * @param onNext A callback to be called every time a new snapshot is\n   * available.\n   * @param onError A callback to be called if the listen fails or is cancelled.\n   * No further callbacks will occur.\n   *\n   * @returns An unsubscribe function that can be called to cancel the snapshot\n   * listener.\n   */\n\n\n  _createClass(Watch, [{\n    key: \"onSnapshot\",\n    value: function onSnapshot(onNext, onError) {\n      var _this = this;\n\n      assert(this.onNext === EMPTY_FUNCTION, 'onNext should not already be defined.');\n      assert(this.onError === EMPTY_FUNCTION, 'onError should not already be defined.');\n      assert(this.docTree === undefined, 'docTree should not already be defined.');\n      this.onNext = onNext;\n      this.onError = onError;\n      this.docTree = rbtree(this.getComparator());\n      this.initStream();\n\n      var unsubscribe = function unsubscribe() {\n        logger_1.logger('Watch.onSnapshot', _this.requestTag, 'Unsubscribe called'); // Prevent further callbacks.\n\n        _this.onNext = function () {};\n\n        _this.onError = function () {};\n\n        _this.shutdown();\n      };\n\n      this.firestore.registerListener();\n      return unsubscribe;\n    }\n    /**\n     * Returns the current count of all documents, including the changes from\n     * the current changeMap.\n     * @private\n     * @internal\n     */\n\n  }, {\n    key: \"currentSize\",\n    value: function currentSize() {\n      var changes = this.extractCurrentChanges(timestamp_1.Timestamp.now());\n      return this.docMap.size + changes.adds.length - changes.deletes.length;\n    }\n    /**\n     * Splits up document changes into removals, additions, and updates.\n     * @private\n     * @internal\n     */\n\n  }, {\n    key: \"extractCurrentChanges\",\n    value: function extractCurrentChanges(readTime) {\n      var _this2 = this;\n\n      var deletes = [];\n      var adds = [];\n      var updates = [];\n      this.changeMap.forEach(function (value, name) {\n        if (value === REMOVED) {\n          if (_this2.docMap.has(name)) {\n            deletes.push(name);\n          }\n        } else if (_this2.docMap.has(name)) {\n          value.readTime = readTime;\n          updates.push(value.build());\n        } else {\n          value.readTime = readTime;\n          adds.push(value.build());\n        }\n      });\n      return {\n        deletes: deletes,\n        adds: adds,\n        updates: updates\n      };\n    }\n    /**\n     * Helper to clear the docs on RESET or filter mismatch.\n     * @private\n     * @internal\n     */\n\n  }, {\n    key: \"resetDocs\",\n    value: function resetDocs() {\n      var _this3 = this;\n\n      logger_1.logger('Watch.resetDocs', this.requestTag, 'Resetting documents');\n      this.changeMap.clear();\n      this.resumeToken = undefined;\n      this.docTree.forEach(function (snapshot) {\n        // Mark each document as deleted. If documents are not deleted, they\n        // will be send again by the server.\n        _this3.changeMap.set(snapshot.ref.path, REMOVED);\n      });\n      this.current = false;\n    }\n    /**\n     * Closes the stream and calls onError() if the stream is still active.\n     * @private\n     * @internal\n     */\n\n  }, {\n    key: \"closeStream\",\n    value: function closeStream(err) {\n      if (this.isActive) {\n        logger_1.logger('Watch.closeStream', this.requestTag, 'Invoking onError: ', err);\n        this.onError(err);\n      }\n\n      this.shutdown();\n    }\n    /**\n     * Re-opens the stream unless the specified error is considered permanent.\n     * Clears the change map.\n     * @private\n     * @internal\n     */\n\n  }, {\n    key: \"maybeReopenStream\",\n    value: function maybeReopenStream(err) {\n      if (this.isActive && !this.isPermanentWatchError(err)) {\n        logger_1.logger('Watch.maybeReopenStream', this.requestTag, 'Stream ended, re-opening after retryable error:', err);\n        this.changeMap.clear();\n\n        if (this.isResourceExhaustedError(err)) {\n          this.backoff.resetToMax();\n        }\n\n        this.initStream();\n      } else {\n        this.closeStream(err);\n      }\n    }\n    /**\n     * Cancels the current idle timeout and reschedules a new timer.\n     *\n     * @private\n     * @internal\n     */\n\n  }, {\n    key: \"resetIdleTimeout\",\n    value: function resetIdleTimeout() {\n      var _this4 = this;\n\n      if (this.idleTimeoutHandle) {\n        clearTimeout(this.idleTimeoutHandle);\n      }\n\n      this.idleTimeoutHandle = backoff_1.delayExecution(function () {\n        var _a;\n\n        logger_1.logger('Watch.resetIdleTimeout', _this4.requestTag, 'Resetting stream after idle timeout');\n        (_a = _this4.currentStream) === null || _a === void 0 ? void 0 : _a.end();\n        _this4.currentStream = null;\n        var error = new google_gax_1.GoogleError('Watch stream idle timeout');\n        error.code = google_gax_1.Status.UNKNOWN;\n\n        _this4.maybeReopenStream(error);\n      }, exports.WATCH_IDLE_TIMEOUT_MS);\n    }\n    /**\n     * Helper to restart the outgoing stream to the backend.\n     * @private\n     * @internal\n     */\n\n  }, {\n    key: \"resetStream\",\n    value: function resetStream() {\n      logger_1.logger('Watch.resetStream', this.requestTag, 'Restarting stream');\n\n      if (this.currentStream) {\n        this.currentStream.end();\n        this.currentStream = null;\n      }\n\n      this.initStream();\n    }\n    /**\n     * Initializes a new stream to the backend with backoff.\n     * @private\n     * @internal\n     */\n\n  }, {\n    key: \"initStream\",\n    value: function initStream() {\n      var _this5 = this;\n\n      this.backoff.backoffAndWait().then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var request;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (_this5.isActive) {\n                  _context.next = 3;\n                  break;\n                }\n\n                logger_1.logger('Watch.initStream', _this5.requestTag, 'Not initializing inactive stream');\n                return _context.abrupt(\"return\");\n\n              case 3:\n                _context.next = 5;\n                return _this5.firestore.initializeIfNeeded(_this5.requestTag);\n\n              case 5:\n                request = {};\n                request.database = _this5.firestore.formattedName;\n                request.addTarget = _this5.getTarget(_this5.resumeToken); // Note that we need to call the internal _listen API to pass additional\n                // header values in readWriteStream.\n\n                return _context.abrupt(\"return\", _this5.firestore.requestStream('listen', request, _this5.requestTag).then(function (backendStream) {\n                  if (!_this5.isActive) {\n                    logger_1.logger('Watch.initStream', _this5.requestTag, 'Closing inactive stream');\n                    backendStream.emit('end');\n                    return;\n                  }\n\n                  logger_1.logger('Watch.initStream', _this5.requestTag, 'Opened new stream');\n                  _this5.currentStream = backendStream;\n\n                  _this5.resetIdleTimeout();\n\n                  _this5.currentStream.on('data', function (proto) {\n                    _this5.resetIdleTimeout();\n\n                    _this5.onData(proto);\n                  }).on('error', function (err) {\n                    if (_this5.currentStream === backendStream) {\n                      _this5.currentStream = null;\n\n                      _this5.maybeReopenStream(err);\n                    }\n                  }).on('end', function () {\n                    if (_this5.currentStream === backendStream) {\n                      _this5.currentStream = null;\n                      var err = new google_gax_1.GoogleError('Stream ended unexpectedly');\n                      err.code = google_gax_1.Status.UNKNOWN;\n\n                      _this5.maybeReopenStream(err);\n                    }\n                  });\n\n                  _this5.currentStream.resume();\n                }));\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }))).catch(function (err) {\n        _this5.closeStream(err);\n      });\n    }\n    /**\n     * Handles 'data' events and closes the stream if the response type is\n     * invalid.\n     * @private\n     * @internal\n     */\n\n  }, {\n    key: \"onData\",\n    value: function onData(proto) {\n      if (proto.targetChange) {\n        logger_1.logger('Watch.onData', this.requestTag, 'Processing target change');\n        var change = proto.targetChange;\n        var noTargetIds = !change.targetIds || change.targetIds.length === 0;\n\n        if (change.targetChangeType === 'NO_CHANGE') {\n          if (noTargetIds && change.readTime && this.current) {\n            // This means everything is up-to-date, so emit the current\n            // set of docs as a snapshot, if there were changes.\n            this.pushSnapshot(timestamp_1.Timestamp.fromProto(change.readTime), change.resumeToken);\n          }\n        } else if (change.targetChangeType === 'ADD') {\n          if (WATCH_TARGET_ID !== change.targetIds[0]) {\n            this.closeStream(Error('Unexpected target ID sent by server'));\n          }\n        } else if (change.targetChangeType === 'REMOVE') {\n          var code = google_gax_1.Status.INTERNAL;\n          var message = 'internal error';\n\n          if (change.cause) {\n            code = change.cause.code;\n            message = change.cause.message;\n          } // @todo: Surface a .code property on the exception.\n\n\n          this.closeStream(new Error('Error ' + code + ': ' + message));\n        } else if (change.targetChangeType === 'RESET') {\n          // Whatever changes have happened so far no longer matter.\n          this.resetDocs();\n        } else if (change.targetChangeType === 'CURRENT') {\n          this.current = true;\n        } else {\n          this.closeStream(new Error('Unknown target change type: ' + JSON.stringify(change)));\n        }\n\n        if (change.resumeToken && this.affectsTarget(change.targetIds, WATCH_TARGET_ID)) {\n          this.backoff.reset();\n        }\n      } else if (proto.documentChange) {\n        logger_1.logger('Watch.onData', this.requestTag, 'Processing change event'); // No other targetIds can show up here, but we still need to see\n        // if the targetId was in the added list or removed list.\n\n        var targetIds = proto.documentChange.targetIds || [];\n        var removedTargetIds = proto.documentChange.removedTargetIds || [];\n        var changed = false;\n        var removed = false;\n\n        for (var i = 0; i < targetIds.length; i++) {\n          if (targetIds[i] === WATCH_TARGET_ID) {\n            changed = true;\n          }\n        }\n\n        for (var _i = 0; _i < removedTargetIds.length; _i++) {\n          if (removedTargetIds[_i] === WATCH_TARGET_ID) {\n            removed = true;\n          }\n        }\n\n        var document = proto.documentChange.document;\n        var name = document.name;\n        var relativeName = path_1.QualifiedResourcePath.fromSlashSeparatedString(name).relativeName;\n\n        if (changed) {\n          logger_1.logger('Watch.onData', this.requestTag, 'Received document change');\n          var ref = this.firestore.doc(relativeName);\n          var snapshot = new document_1.DocumentSnapshotBuilder(ref.withConverter(this._converter));\n          snapshot.fieldsProto = document.fields || {};\n          snapshot.createTime = timestamp_1.Timestamp.fromProto(document.createTime);\n          snapshot.updateTime = timestamp_1.Timestamp.fromProto(document.updateTime);\n          this.changeMap.set(relativeName, snapshot);\n        } else if (removed) {\n          logger_1.logger('Watch.onData', this.requestTag, 'Received document remove');\n          this.changeMap.set(relativeName, REMOVED);\n        }\n      } else if (proto.documentDelete || proto.documentRemove) {\n        logger_1.logger('Watch.onData', this.requestTag, 'Processing remove event');\n        var _name = (proto.documentDelete || proto.documentRemove).document;\n        var _relativeName = path_1.QualifiedResourcePath.fromSlashSeparatedString(_name).relativeName;\n        this.changeMap.set(_relativeName, REMOVED);\n      } else if (proto.filter) {\n        logger_1.logger('Watch.onData', this.requestTag, 'Processing filter update');\n\n        if (proto.filter.count !== this.currentSize()) {\n          // We need to remove all the current results.\n          this.resetDocs(); // The filter didn't match, so re-issue the query.\n\n          this.resetStream();\n        }\n      } else {\n        this.closeStream(new Error('Unknown listen response type: ' + JSON.stringify(proto)));\n      }\n    }\n    /**\n     * Checks if the current target id is included in the list of target ids.\n     * If no targetIds are provided, returns true.\n     * @private\n     * @internal\n     */\n\n  }, {\n    key: \"affectsTarget\",\n    value: function affectsTarget(targetIds, currentId) {\n      if (targetIds === undefined || targetIds.length === 0) {\n        return true;\n      }\n\n      var _iterator = _createForOfIteratorHelper(targetIds),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var targetId = _step.value;\n\n          if (targetId === currentId) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return false;\n    }\n    /**\n     * Assembles a new snapshot from the current set of changes and invokes the\n     * user's callback. Clears the current changes on completion.\n     * @private\n     * @internal\n     */\n\n  }, {\n    key: \"pushSnapshot\",\n    value: function pushSnapshot(readTime, nextResumeToken) {\n      var appliedChanges = this.computeSnapshot(readTime);\n\n      if (!this.hasPushed || appliedChanges.length > 0) {\n        logger_1.logger('Watch.pushSnapshot', this.requestTag, 'Sending snapshot with %d changes and %d documents', String(appliedChanges.length), this.docTree.length); // We pass the current set of changes, even if `docTree` is modified later.\n\n        var currentTree = this.docTree;\n        this.onNext(readTime, currentTree.length, function () {\n          return currentTree.keys;\n        }, function () {\n          return appliedChanges;\n        });\n        this.hasPushed = true;\n      }\n\n      this.changeMap.clear();\n      this.resumeToken = nextResumeToken;\n    }\n    /**\n     * Applies a document delete to the document tree and the document map.\n     * Returns the corresponding DocumentChange event.\n     * @private\n     * @internal\n     */\n\n  }, {\n    key: \"deleteDoc\",\n    value: function deleteDoc(name) {\n      assert(this.docMap.has(name), 'Document to delete does not exist');\n      var oldDocument = this.docMap.get(name);\n      var existing = this.docTree.find(oldDocument);\n      var oldIndex = existing.index;\n      this.docTree = existing.remove();\n      this.docMap.delete(name);\n      return new document_change_1.DocumentChange(ChangeType.removed, oldDocument, oldIndex, -1);\n    }\n    /**\n     * Applies a document add to the document tree and the document map. Returns\n     * the corresponding DocumentChange event.\n     * @private\n     * @internal\n     */\n\n  }, {\n    key: \"addDoc\",\n    value: function addDoc(newDocument) {\n      var name = newDocument.ref.path;\n      assert(!this.docMap.has(name), 'Document to add already exists');\n      this.docTree = this.docTree.insert(newDocument, null);\n      var newIndex = this.docTree.find(newDocument).index;\n      this.docMap.set(name, newDocument);\n      return new document_change_1.DocumentChange(ChangeType.added, newDocument, -1, newIndex);\n    }\n    /**\n     * Applies a document modification to the document tree and the document map.\n     * Returns the DocumentChange event for successful modifications.\n     * @private\n     * @internal\n     */\n\n  }, {\n    key: \"modifyDoc\",\n    value: function modifyDoc(newDocument) {\n      var name = newDocument.ref.path;\n      assert(this.docMap.has(name), 'Document to modify does not exist');\n      var oldDocument = this.docMap.get(name);\n\n      if (!oldDocument.updateTime.isEqual(newDocument.updateTime)) {\n        var removeChange = this.deleteDoc(name);\n        var addChange = this.addDoc(newDocument);\n        return new document_change_1.DocumentChange(ChangeType.modified, newDocument, removeChange.oldIndex, addChange.newIndex);\n      }\n\n      return null;\n    }\n    /**\n     * Applies the mutations in changeMap to both the document tree and the\n     * document lookup map. Modified docMap in-place and returns the updated\n     * state.\n     * @private\n     * @internal\n     */\n\n  }, {\n    key: \"computeSnapshot\",\n    value: function computeSnapshot(readTime) {\n      var _this6 = this;\n\n      var changeSet = this.extractCurrentChanges(readTime);\n      var appliedChanges = []; // Process the sorted changes in the order that is expected by our clients\n      // (removals, additions, and then modifications). We also need to sort the\n      // individual changes to assure that oldIndex/newIndex keep incrementing.\n\n      changeSet.deletes.sort(function (name1, name2) {\n        // Deletes are sorted based on the order of the existing document.\n        return _this6.getComparator()(_this6.docMap.get(name1), _this6.docMap.get(name2));\n      });\n      changeSet.deletes.forEach(function (name) {\n        var change = _this6.deleteDoc(name);\n\n        appliedChanges.push(change);\n      });\n      changeSet.adds.sort(this.getComparator());\n      changeSet.adds.forEach(function (snapshot) {\n        var change = _this6.addDoc(snapshot);\n\n        appliedChanges.push(change);\n      });\n      changeSet.updates.sort(this.getComparator());\n      changeSet.updates.forEach(function (snapshot) {\n        var change = _this6.modifyDoc(snapshot);\n\n        if (change) {\n          appliedChanges.push(change);\n        }\n      });\n      assert(this.docTree.length === this.docMap.size, 'The update document ' + 'tree and document map should have the same number of entries.');\n      return appliedChanges;\n    }\n    /**\n     * Determines whether a watch error is considered permanent and should not be\n     * retried. Errors that don't provide a GRPC error code are always considered\n     * transient in this context.\n     *\n     * @private\n     * @internal\n     * @param error An error object.\n     * @return Whether the error is permanent.\n     */\n\n  }, {\n    key: \"isPermanentWatchError\",\n    value: function isPermanentWatchError(error) {\n      if (error.code === undefined) {\n        logger_1.logger('Watch.isPermanentError', this.requestTag, 'Unable to determine error code: ', error);\n        return false;\n      }\n\n      switch (error.code) {\n        case google_gax_1.Status.ABORTED:\n        case google_gax_1.Status.CANCELLED:\n        case google_gax_1.Status.UNKNOWN:\n        case google_gax_1.Status.DEADLINE_EXCEEDED:\n        case google_gax_1.Status.RESOURCE_EXHAUSTED:\n        case google_gax_1.Status.INTERNAL:\n        case google_gax_1.Status.UNAVAILABLE:\n        case google_gax_1.Status.UNAUTHENTICATED:\n          return false;\n\n        default:\n          return true;\n      }\n    }\n    /**\n     * Determines whether we need to initiate a longer backoff due to system\n     * overload.\n     *\n     * @private\n     * @internal\n     * @param error A GRPC Error object that exposes an error code.\n     * @return Whether we need to back off our retries.\n     */\n\n  }, {\n    key: \"isResourceExhaustedError\",\n    value: function isResourceExhaustedError(error) {\n      return error.code === google_gax_1.Status.RESOURCE_EXHAUSTED;\n    }\n    /** Closes the stream and clears all timeouts. */\n\n  }, {\n    key: \"shutdown\",\n    value: function shutdown() {\n      var _a;\n\n      if (this.isActive) {\n        this.isActive = false;\n\n        if (this.idleTimeoutHandle) {\n          clearTimeout(this.idleTimeoutHandle);\n          this.idleTimeoutHandle = undefined;\n        }\n\n        this.firestore.unregisterListener();\n      }\n\n      (_a = this.currentStream) === null || _a === void 0 ? void 0 : _a.end();\n      this.currentStream = null;\n    }\n  }]);\n\n  return Watch;\n}();\n/**\n * Creates a new Watch instance to listen on DocumentReferences.\n *\n * @private\n * @internal\n */\n\n\nvar DocumentWatch = /*#__PURE__*/function (_Watch) {\n  _inherits(DocumentWatch, _Watch);\n\n  function DocumentWatch(firestore, ref) {\n    var _this7;\n\n    _classCallCheck(this, DocumentWatch);\n\n    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(DocumentWatch).call(this, firestore, ref._converter));\n    _this7.ref = ref;\n    return _this7;\n  }\n\n  _createClass(DocumentWatch, [{\n    key: \"getComparator\",\n    value: function getComparator() {\n      return DOCUMENT_WATCH_COMPARATOR;\n    }\n  }, {\n    key: \"getTarget\",\n    value: function getTarget(resumeToken) {\n      var formattedName = this.ref.formattedName;\n      return {\n        documents: {\n          documents: [formattedName]\n        },\n        targetId: WATCH_TARGET_ID,\n        resumeToken: resumeToken\n      };\n    }\n  }]);\n\n  return DocumentWatch;\n}(Watch);\n\nexports.DocumentWatch = DocumentWatch;\n/**\n * Creates a new Watch instance to listen on Queries.\n *\n * @private\n * @internal\n */\n\nvar QueryWatch = /*#__PURE__*/function (_Watch2) {\n  _inherits(QueryWatch, _Watch2);\n\n  function QueryWatch(firestore, query, converter) {\n    var _this8;\n\n    _classCallCheck(this, QueryWatch);\n\n    _this8 = _possibleConstructorReturn(this, _getPrototypeOf(QueryWatch).call(this, firestore, converter));\n    _this8.query = query;\n    _this8.comparator = query.comparator();\n    return _this8;\n  }\n\n  _createClass(QueryWatch, [{\n    key: \"getComparator\",\n    value: function getComparator() {\n      return this.query.comparator();\n    }\n  }, {\n    key: \"getTarget\",\n    value: function getTarget(resumeToken) {\n      var query = this.query.toProto();\n      return {\n        query: query,\n        targetId: WATCH_TARGET_ID,\n        resumeToken: resumeToken\n      };\n    }\n  }]);\n\n  return QueryWatch;\n}(Watch);\n\nexports.QueryWatch = QueryWatch;","map":null,"metadata":{},"sourceType":"script"}