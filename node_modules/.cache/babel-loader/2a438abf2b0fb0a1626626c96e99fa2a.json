{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PagedApiCaller = void 0;\n\nvar call_1 = require(\"../call\");\n\nvar googleError_1 = require(\"../googleError\");\n\nvar resourceCollector_1 = require(\"./resourceCollector\");\n\nvar PagedApiCaller = /*#__PURE__*/function () {\n  /**\n   * Creates an API caller that returns a stream to performs page-streaming.\n   *\n   * @private\n   * @constructor\n   * @param {PageDescriptor} pageDescriptor - indicates the structure\n   *   of page streaming to be performed.\n   */\n  function PagedApiCaller(pageDescriptor) {\n    _classCallCheck(this, PagedApiCaller);\n\n    this.pageDescriptor = pageDescriptor;\n  }\n  /**\n   * This function translates between regular gRPC calls (that accepts a request and returns a response,\n   * and does not know anything about pages and page tokens) and the users' callback (that expects\n   * to see resources from one page, a request to get the next page, and the raw response from the server).\n   *\n   * It generates a function that can be passed as a callback function to a gRPC call, will understand\n   * pagination-specific fields in the response, and call the users' callback after having those fields\n   * parsed.\n   *\n   * @param request Request object. It needs to be passed to all subsequent next page requests\n   * (the main content of the request object stays unchanged, only the next page token changes)\n   * @param callback The user's callback that expects the page content, next page request, and raw response.\n   */\n\n\n  _createClass(PagedApiCaller, [{\n    key: \"generateParseResponseCallback\",\n    value: function generateParseResponseCallback(request, callback) {\n      var resourceFieldName = this.pageDescriptor.resourceField;\n      var responsePageTokenFieldName = this.pageDescriptor.responsePageTokenField;\n      var requestPageTokenFieldName = this.pageDescriptor.requestPageTokenField;\n      return function (err, response) {\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        if (!request) {\n          callback(new googleError_1.GoogleError('Undefined request in pagination method callback.'));\n          return;\n        }\n\n        if (!response) {\n          callback(new googleError_1.GoogleError('Undefined response in pagination method callback.'));\n          return;\n        }\n\n        var resources = response[resourceFieldName] || [];\n        var pageToken = response[responsePageTokenFieldName];\n        var nextPageRequest = null;\n\n        if (pageToken) {\n          nextPageRequest = Object.assign({}, request);\n          nextPageRequest[requestPageTokenFieldName] = pageToken;\n        }\n\n        callback(err, resources, nextPageRequest, response);\n      };\n    }\n    /**\n     * Adds a special ability to understand pagination-specific fields to the existing gRPC call.\n     * The original gRPC call just calls callback(err, result).\n     * The wrapped one will call callback(err, resources, nextPageRequest, rawResponse) instead.\n     *\n     * @param func gRPC call (normally, a service stub call). The gRPC call is expected to accept four parameters:\n     * request, metadata, call options, and callback.\n     */\n\n  }, {\n    key: \"wrap\",\n    value: function wrap(func) {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      var self = this;\n      return function wrappedCall(argument, metadata, options, callback) {\n        return func(argument, metadata, options, self.generateParseResponseCallback(argument, callback));\n      };\n    }\n    /**\n     * Makes it possible to use both callback-based and promise-based calls.\n     * Returns an OngoingCall or OngoingCallPromise object.\n     * Regardless of which one is returned, it always has a `.callback` to call.\n     *\n     * @param settings Call settings. Can only be used to replace Promise with another promise implementation.\n     * @param [callback] Callback to be called, if any.\n     */\n\n  }, {\n    key: \"init\",\n    value: function init(callback) {\n      if (callback) {\n        return new call_1.OngoingCall(callback);\n      }\n\n      return new call_1.OngoingCallPromise();\n    }\n    /**\n     * Implements auto-pagination logic.\n     *\n     * @param apiCall A function that performs gRPC request and calls its callback with a response or an error.\n     * It's supposed to be a gRPC service stub function wrapped into several layers of wrappers that make it\n     * accept just two parameters: (request, callback).\n     * @param request A request object that came from the user.\n     * @param settings Call settings. We are interested in `maxResults`, autoPaginate`, `pageToken`, and `pageSize`\n     * (they are all optional).\n     * @param ongoingCall An instance of OngoingCall or OngoingCallPromise that can be used for call cancellation,\n     * and is used to return results to the user.\n     */\n\n  }, {\n    key: \"call\",\n    value: function call(apiCall, request, settings, ongoingCall) {\n      request = Object.assign({}, request); // If settings object contain pageToken or pageSize, override the corresponding fields in the request object.\n\n      if (settings.pageToken) {\n        request[this.pageDescriptor.requestPageTokenField] = settings.pageToken;\n      }\n\n      if (settings.pageSize) {\n        request[this.pageDescriptor.requestPageSizeField] = settings.pageSize;\n      }\n\n      if (!settings.autoPaginate) {\n        // they don't want auto-pagination this time - okay, just call once\n        ongoingCall.call(apiCall, request);\n        return;\n      }\n\n      var maxResults = settings.maxResults || -1;\n      var resourceCollector = new resourceCollector_1.ResourceCollector(apiCall, maxResults);\n      resourceCollector.processAllPages(request).then(function (resources) {\n        return ongoingCall.callback(null, resources);\n      }, function (err) {\n        return ongoingCall.callback(err);\n      });\n    }\n  }, {\n    key: \"fail\",\n    value: function fail(ongoingCall, err) {\n      ongoingCall.callback(err);\n    }\n  }, {\n    key: \"result\",\n    value: function result(ongoingCall) {\n      return ongoingCall.promise;\n    }\n  }]);\n\n  return PagedApiCaller;\n}();\n\nexports.PagedApiCaller = PagedApiCaller;","map":null,"metadata":{},"sourceType":"script"}