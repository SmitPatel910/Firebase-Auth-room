{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar convert_1 = require(\"./convert\");\n\nvar path_1 = require(\"./path\");\n/*!\n * The type order as defined by the backend.\n */\n\n\nvar TypeOrder;\n\n(function (TypeOrder) {\n  TypeOrder[TypeOrder[\"NULL\"] = 0] = \"NULL\";\n  TypeOrder[TypeOrder[\"BOOLEAN\"] = 1] = \"BOOLEAN\";\n  TypeOrder[TypeOrder[\"NUMBER\"] = 2] = \"NUMBER\";\n  TypeOrder[TypeOrder[\"TIMESTAMP\"] = 3] = \"TIMESTAMP\";\n  TypeOrder[TypeOrder[\"STRING\"] = 4] = \"STRING\";\n  TypeOrder[TypeOrder[\"BLOB\"] = 5] = \"BLOB\";\n  TypeOrder[TypeOrder[\"REF\"] = 6] = \"REF\";\n  TypeOrder[TypeOrder[\"GEO_POINT\"] = 7] = \"GEO_POINT\";\n  TypeOrder[TypeOrder[\"ARRAY\"] = 8] = \"ARRAY\";\n  TypeOrder[TypeOrder[\"OBJECT\"] = 9] = \"OBJECT\";\n})(TypeOrder || (TypeOrder = {}));\n/*!\n * @private\n * @internal\n */\n\n\nfunction typeOrder(val) {\n  var valueType = convert_1.detectValueType(val);\n\n  switch (valueType) {\n    case 'nullValue':\n      return TypeOrder.NULL;\n\n    case 'integerValue':\n      return TypeOrder.NUMBER;\n\n    case 'doubleValue':\n      return TypeOrder.NUMBER;\n\n    case 'stringValue':\n      return TypeOrder.STRING;\n\n    case 'booleanValue':\n      return TypeOrder.BOOLEAN;\n\n    case 'arrayValue':\n      return TypeOrder.ARRAY;\n\n    case 'timestampValue':\n      return TypeOrder.TIMESTAMP;\n\n    case 'geoPointValue':\n      return TypeOrder.GEO_POINT;\n\n    case 'bytesValue':\n      return TypeOrder.BLOB;\n\n    case 'referenceValue':\n      return TypeOrder.REF;\n\n    case 'mapValue':\n      return TypeOrder.OBJECT;\n\n    default:\n      throw new Error('Unexpected value type: ' + valueType);\n  }\n}\n/*!\n * @private\n * @internal\n */\n\n\nfunction primitiveComparator(left, right) {\n  if (left < right) {\n    return -1;\n  }\n\n  if (left > right) {\n    return 1;\n  }\n\n  return 0;\n}\n\nexports.primitiveComparator = primitiveComparator;\n/*!\n * Utility function to compare doubles (using Firestore semantics for NaN).\n * @private\n * @internal\n */\n\nfunction compareNumbers(left, right) {\n  if (left < right) {\n    return -1;\n  }\n\n  if (left > right) {\n    return 1;\n  }\n\n  if (left === right) {\n    return 0;\n  } // one or both are NaN.\n\n\n  if (isNaN(left)) {\n    return isNaN(right) ? 0 : -1;\n  }\n\n  return 1;\n}\n/*!\n * @private\n * @internal\n */\n\n\nfunction compareNumberProtos(left, right) {\n  var leftValue, rightValue;\n\n  if (left.integerValue !== undefined) {\n    leftValue = Number(left.integerValue);\n  } else {\n    leftValue = Number(left.doubleValue);\n  }\n\n  if (right.integerValue !== undefined) {\n    rightValue = Number(right.integerValue);\n  } else {\n    rightValue = Number(right.doubleValue);\n  }\n\n  return compareNumbers(leftValue, rightValue);\n}\n/*!\n * @private\n * @internal\n */\n\n\nfunction compareTimestamps(left, right) {\n  var seconds = primitiveComparator(left.seconds || 0, right.seconds || 0);\n\n  if (seconds !== 0) {\n    return seconds;\n  }\n\n  return primitiveComparator(left.nanos || 0, right.nanos || 0);\n}\n/*!\n * @private\n * @internal\n */\n\n\nfunction compareBlobs(left, right) {\n  if (!(left instanceof Buffer) || !(right instanceof Buffer)) {\n    throw new Error('Blobs can only be compared if they are Buffers.');\n  }\n\n  return Buffer.compare(left, right);\n}\n/*!\n * @private\n * @internal\n */\n\n\nfunction compareReferenceProtos(left, right) {\n  var leftPath = path_1.QualifiedResourcePath.fromSlashSeparatedString(left.referenceValue);\n  var rightPath = path_1.QualifiedResourcePath.fromSlashSeparatedString(right.referenceValue);\n  return leftPath.compareTo(rightPath);\n}\n/*!\n * @private\n * @internal\n */\n\n\nfunction compareGeoPoints(left, right) {\n  return primitiveComparator(left.latitude || 0, right.latitude || 0) || primitiveComparator(left.longitude || 0, right.longitude || 0);\n}\n/*!\n * @private\n * @internal\n */\n\n\nfunction compareArrays(left, right) {\n  for (var i = 0; i < left.length && i < right.length; i++) {\n    var valueComparison = compare(left[i], right[i]);\n\n    if (valueComparison !== 0) {\n      return valueComparison;\n    }\n  } // If all the values matched so far, just check the length.\n\n\n  return primitiveComparator(left.length, right.length);\n}\n\nexports.compareArrays = compareArrays;\n/*!\n * @private\n * @internal\n */\n\nfunction compareObjects(left, right) {\n  // This requires iterating over the keys in the object in order and doing a\n  // deep comparison.\n  var leftKeys = Object.keys(left);\n  var rightKeys = Object.keys(right);\n  leftKeys.sort();\n  rightKeys.sort();\n\n  for (var i = 0; i < leftKeys.length && i < rightKeys.length; i++) {\n    var keyComparison = primitiveComparator(leftKeys[i], rightKeys[i]);\n\n    if (keyComparison !== 0) {\n      return keyComparison;\n    }\n\n    var key = leftKeys[i];\n    var valueComparison = compare(left[key], right[key]);\n\n    if (valueComparison !== 0) {\n      return valueComparison;\n    }\n  } // If all the keys matched so far, just check the length.\n\n\n  return primitiveComparator(leftKeys.length, rightKeys.length);\n}\n/*!\n * @private\n * @internal\n */\n\n\nfunction compare(left, right) {\n  // First compare the types.\n  var leftType = typeOrder(left);\n  var rightType = typeOrder(right);\n  var typeComparison = primitiveComparator(leftType, rightType);\n\n  if (typeComparison !== 0) {\n    return typeComparison;\n  } // So they are the same type.\n\n\n  switch (leftType) {\n    case TypeOrder.NULL:\n      // Nulls are all equal.\n      return 0;\n\n    case TypeOrder.BOOLEAN:\n      return primitiveComparator(left.booleanValue, right.booleanValue);\n\n    case TypeOrder.STRING:\n      return primitiveComparator(left.stringValue, right.stringValue);\n\n    case TypeOrder.NUMBER:\n      return compareNumberProtos(left, right);\n\n    case TypeOrder.TIMESTAMP:\n      return compareTimestamps(left.timestampValue, right.timestampValue);\n\n    case TypeOrder.BLOB:\n      return compareBlobs(left.bytesValue, right.bytesValue);\n\n    case TypeOrder.REF:\n      return compareReferenceProtos(left, right);\n\n    case TypeOrder.GEO_POINT:\n      return compareGeoPoints(left.geoPointValue, right.geoPointValue);\n\n    case TypeOrder.ARRAY:\n      return compareArrays(left.arrayValue.values || [], right.arrayValue.values || []);\n\n    case TypeOrder.OBJECT:\n      return compareObjects(left.mapValue.fields || {}, right.mapValue.fields || {});\n\n    default:\n      throw new Error(\"Encountered unknown type order: \".concat(leftType));\n  }\n}\n\nexports.compare = compare;","map":null,"metadata":{},"sourceType":"script"}