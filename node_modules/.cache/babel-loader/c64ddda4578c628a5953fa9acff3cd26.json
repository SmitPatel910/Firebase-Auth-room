{"ast":null,"code":"var _objectSpread = require(\"C:\\\\Users\\\\Smit\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread\");\n\nvar _defineProperty = require(\"C:\\\\Users\\\\Smit\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Smit\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Smit\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _require = require('./runtime_support'),\n    keyObjectSupported = _require.keyObjectSupported;\n\nvar _createPublicKey;\n\nvar _createPrivateKey2;\n\nvar createSecretKey;\nvar KeyObject;\nvar asInput;\n\nif (keyObjectSupported) {\n  var _require2 = require('crypto');\n\n  _createPublicKey = _require2.createPublicKey;\n  _createPrivateKey2 = _require2.createPrivateKey;\n  createSecretKey = _require2.createSecretKey;\n  KeyObject = _require2.KeyObject;\n\n  asInput = function asInput(input) {\n    return input;\n  };\n} else {\n  var _require3 = require('os'),\n      EOL = _require3.EOL;\n\n  var errors = require('../errors');\n\n  var isObject = require('./is_object');\n\n  var asn1 = require('./asn1');\n\n  var toInput = Symbol('toInput');\n  var namedCurve = Symbol('namedCurve');\n\n  asInput = function asInput(keyObject, needsPublic) {\n    if (keyObject instanceof KeyObject) {\n      return keyObject[toInput](needsPublic);\n    }\n\n    return createSecretKey(keyObject)[toInput](needsPublic);\n  };\n\n  var pemToDer = function pemToDer(pem) {\n    return Buffer.from(pem.replace(/(?:-----(?:BEGIN|END)(?: (?:RSA|EC))? (?:PRIVATE|PUBLIC) KEY-----|\\s)/g, ''), 'base64');\n  };\n\n  var derToPem = function derToPem(der, label) {\n    return \"-----BEGIN \".concat(label, \"-----\").concat(EOL).concat((der.toString('base64').match(/.{1,64}/g) || []).join(EOL)).concat(EOL, \"-----END \").concat(label, \"-----\");\n  };\n\n  var unsupported = function unsupported(input) {\n    var label = typeof input === 'string' ? input : \"OID \".concat(input.join('.'));\n    throw new errors.JOSENotSupported(\"\".concat(label, \" is not supported in your Node.js runtime version\"));\n  };\n\n  KeyObject = /*#__PURE__*/function () {\n    \"use strict\";\n\n    function KeyObject() {\n      _classCallCheck(this, KeyObject);\n    }\n\n    _createClass(KeyObject, [{\n      key: \"export\",\n      value: function _export() {\n        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n            cipher = _ref.cipher,\n            passphrase = _ref.passphrase,\n            type = _ref.type,\n            format = _ref.format;\n\n        if (this._type === 'secret') {\n          return this._buffer;\n        }\n\n        if (this._type === 'public') {\n          if (this.asymmetricKeyType === 'rsa') {\n            switch (type) {\n              case 'pkcs1':\n                if (format === 'pem') {\n                  return this._pem;\n                }\n\n                return pemToDer(this._pem);\n\n              case 'spki':\n                {\n                  var PublicKeyInfo = asn1.get('PublicKeyInfo');\n                  var pem = PublicKeyInfo.encode({\n                    algorithm: {\n                      algorithm: 'rsaEncryption',\n                      parameters: {\n                        type: 'null'\n                      }\n                    },\n                    publicKey: {\n                      unused: 0,\n                      data: pemToDer(this._pem)\n                    }\n                  }, 'pem', {\n                    label: 'PUBLIC KEY'\n                  });\n                  return format === 'pem' ? pem : pemToDer(pem);\n                }\n\n              default:\n                throw new TypeError(\"The value \".concat(type, \" is invalid for option \\\"type\\\"\"));\n            }\n          }\n\n          if (this.asymmetricKeyType === 'ec') {\n            if (type !== 'spki') {\n              throw new TypeError(\"The value \".concat(type, \" is invalid for option \\\"type\\\"\"));\n            }\n\n            if (format === 'pem') {\n              return this._pem;\n            }\n\n            return pemToDer(this._pem);\n          }\n        }\n\n        if (this._type === 'private') {\n          if (passphrase !== undefined || cipher !== undefined) {\n            throw new errors.JOSENotSupported('encrypted private keys are not supported in your Node.js runtime version');\n          }\n\n          if (type === 'pkcs8') {\n            if (this._pkcs8) {\n              if (format === 'der' && typeof this._pkcs8 === 'string') {\n                return pemToDer(this._pkcs8);\n              }\n\n              if (format === 'pem' && Buffer.isBuffer(this._pkcs8)) {\n                return derToPem(this._pkcs8, 'PRIVATE KEY');\n              }\n\n              return this._pkcs8;\n            }\n\n            if (this.asymmetricKeyType === 'rsa') {\n              var parsed = this._asn1;\n              var RSAPrivateKey = asn1.get('RSAPrivateKey');\n              var privateKey = RSAPrivateKey.encode(parsed);\n              var PrivateKeyInfo = asn1.get('PrivateKeyInfo');\n              var pkcs8 = PrivateKeyInfo.encode({\n                version: 0,\n                privateKey: privateKey,\n                algorithm: {\n                  algorithm: 'rsaEncryption',\n                  parameters: {\n                    type: 'null'\n                  }\n                }\n              });\n              this._pkcs8 = pkcs8;\n              return this.export({\n                type: type,\n                format: format\n              });\n            }\n\n            if (this.asymmetricKeyType === 'ec') {\n              var _parsed = this._asn1;\n              var ECPrivateKey = asn1.get('ECPrivateKey');\n\n              var _privateKey = ECPrivateKey.encode({\n                version: _parsed.version,\n                privateKey: _parsed.privateKey,\n                publicKey: _parsed.publicKey\n              });\n\n              var _PrivateKeyInfo = asn1.get('PrivateKeyInfo');\n\n              var _pkcs = _PrivateKeyInfo.encode({\n                version: 0,\n                privateKey: _privateKey,\n                algorithm: {\n                  algorithm: 'ecPublicKey',\n                  parameters: this._asn1.parameters\n                }\n              });\n\n              this._pkcs8 = _pkcs;\n              return this.export({\n                type: type,\n                format: format\n              });\n            }\n          }\n\n          if (this.asymmetricKeyType === 'rsa' && type === 'pkcs1') {\n            if (format === 'pem') {\n              return this._pem;\n            }\n\n            return pemToDer(this._pem);\n          } else if (this.asymmetricKeyType === 'ec' && type === 'sec1') {\n            if (format === 'pem') {\n              return this._pem;\n            }\n\n            return pemToDer(this._pem);\n          } else {\n            throw new TypeError(\"The value \".concat(type, \" is invalid for option \\\"type\\\"\"));\n          }\n        }\n      }\n    }, {\n      key: toInput,\n      value: function value(needsPublic) {\n        switch (this._type) {\n          case 'secret':\n            return this._buffer;\n\n          case 'public':\n            return this._pem;\n\n          default:\n            if (needsPublic) {\n              if (!('_pub' in this)) {\n                this._pub = _createPublicKey(this);\n              }\n\n              return this._pub[toInput](false);\n            }\n\n            return this._pem;\n        }\n      }\n    }, {\n      key: \"type\",\n      get: function get() {\n        return this._type;\n      }\n    }, {\n      key: \"asymmetricKeyType\",\n      get: function get() {\n        return this._asymmetricKeyType;\n      }\n    }, {\n      key: \"symmetricKeySize\",\n      get: function get() {\n        return this._symmetricKeySize;\n      }\n    }]);\n\n    return KeyObject;\n  }();\n\n  createSecretKey = function createSecretKey(buffer) {\n    if (!Buffer.isBuffer(buffer) || !buffer.length) {\n      throw new TypeError('input must be a non-empty Buffer instance');\n    }\n\n    var keyObject = new KeyObject();\n    keyObject._buffer = Buffer.from(buffer);\n    keyObject._symmetricKeySize = buffer.length;\n    keyObject._type = 'secret';\n    return keyObject;\n  };\n\n  _createPublicKey = function createPublicKey(input) {\n    if (input instanceof KeyObject) {\n      if (input.type !== 'private') {\n        throw new TypeError(\"Invalid key object type \".concat(input.type, \", expected private.\"));\n      }\n\n      switch (input.asymmetricKeyType) {\n        case 'ec':\n          {\n            var PublicKeyInfo = asn1.get('PublicKeyInfo');\n\n            var _key = PublicKeyInfo.encode({\n              algorithm: {\n                algorithm: 'ecPublicKey',\n                parameters: input._asn1.parameters\n              },\n              publicKey: input._asn1.publicKey\n            });\n\n            return _createPublicKey({\n              key: _key,\n              format: 'der',\n              type: 'spki'\n            });\n          }\n\n        case 'rsa':\n          {\n            var RSAPublicKey = asn1.get('RSAPublicKey');\n\n            var _key2 = RSAPublicKey.encode(input._asn1);\n\n            return _createPublicKey({\n              key: _key2,\n              format: 'der',\n              type: 'pkcs1'\n            });\n          }\n      }\n    }\n\n    if (typeof input === 'string' || Buffer.isBuffer(input)) {\n      input = {\n        key: input,\n        format: 'pem'\n      };\n    }\n\n    if (!isObject(input)) {\n      throw new TypeError('input must be a string, Buffer or an object');\n    }\n\n    var _input = input,\n        format = _input.format,\n        passphrase = _input.passphrase;\n    var _input2 = input,\n        key = _input2.key,\n        type = _input2.type;\n\n    if (typeof key !== 'string' && !Buffer.isBuffer(key)) {\n      throw new TypeError('key must be a string or Buffer');\n    }\n\n    if (format !== 'pem' && format !== 'der') {\n      throw new TypeError('format must be one of \"pem\" or \"der\"');\n    }\n\n    var label;\n\n    if (format === 'pem') {\n      key = key.toString();\n\n      switch (key.split(/\\r?\\n/g)[0].toString()) {\n        case '-----BEGIN PUBLIC KEY-----':\n          type = 'spki';\n          label = 'PUBLIC KEY';\n          break;\n\n        case '-----BEGIN RSA PUBLIC KEY-----':\n          type = 'pkcs1';\n          label = 'RSA PUBLIC KEY';\n          break;\n\n        case '-----BEGIN CERTIFICATE-----':\n          throw new errors.JOSENotSupported('X.509 certificates are not supported in your Node.js runtime version');\n\n        case '-----BEGIN PRIVATE KEY-----':\n        case '-----BEGIN EC PRIVATE KEY-----':\n        case '-----BEGIN RSA PRIVATE KEY-----':\n          return _createPublicKey(_createPrivateKey2(key));\n\n        default:\n          throw new TypeError('unknown/unsupported PEM type');\n      }\n    }\n\n    switch (type) {\n      case 'spki':\n        {\n          var _PublicKeyInfo = asn1.get('PublicKeyInfo');\n\n          var parsed = _PublicKeyInfo.decode(key, format, {\n            label: label\n          });\n\n          var _type, keyObject;\n\n          switch (parsed.algorithm.algorithm) {\n            case 'ecPublicKey':\n              {\n                keyObject = new KeyObject();\n                keyObject._asn1 = parsed;\n                keyObject._asymmetricKeyType = 'ec';\n                keyObject._type = 'public';\n                keyObject._pem = _PublicKeyInfo.encode(parsed, 'pem', {\n                  label: 'PUBLIC KEY'\n                });\n                break;\n              }\n\n            case 'rsaEncryption':\n              {\n                _type = 'pkcs1';\n                keyObject = _createPublicKey({\n                  type: _type,\n                  key: parsed.publicKey.data,\n                  format: 'der'\n                });\n                break;\n              }\n\n            default:\n              unsupported(parsed.algorithm.algorithm);\n          }\n\n          return keyObject;\n        }\n\n      case 'pkcs1':\n        {\n          var _RSAPublicKey = asn1.get('RSAPublicKey');\n\n          var _parsed2 = _RSAPublicKey.decode(key, format, {\n            label: label\n          }); // special case when private pkcs1 PEM / DER is used with createPublicKey\n\n\n          if (_parsed2.n === BigInt(0)) {\n            return _createPublicKey(_createPrivateKey2({\n              key: key,\n              format: format,\n              type: type,\n              passphrase: passphrase\n            }));\n          }\n\n          var _keyObject = new KeyObject();\n\n          _keyObject._asn1 = _parsed2;\n          _keyObject._asymmetricKeyType = 'rsa';\n          _keyObject._type = 'public';\n          _keyObject._pem = _RSAPublicKey.encode(_parsed2, 'pem', {\n            label: 'RSA PUBLIC KEY'\n          });\n          return _keyObject;\n        }\n\n      case 'pkcs8':\n      case 'sec1':\n        return _createPublicKey(_createPrivateKey2({\n          format: format,\n          key: key,\n          type: type,\n          passphrase: passphrase\n        }));\n\n      default:\n        throw new TypeError(\"The value \".concat(type, \" is invalid for option \\\"type\\\"\"));\n    }\n  };\n\n  _createPrivateKey2 = function createPrivateKey(input, hints) {\n    if (typeof input === 'string' || Buffer.isBuffer(input)) {\n      input = {\n        key: input,\n        format: 'pem'\n      };\n    }\n\n    if (!isObject(input)) {\n      throw new TypeError('input must be a string, Buffer or an object');\n    }\n\n    var _input3 = input,\n        format = _input3.format,\n        passphrase = _input3.passphrase;\n    var _input4 = input,\n        key = _input4.key,\n        type = _input4.type;\n\n    if (typeof key !== 'string' && !Buffer.isBuffer(key)) {\n      throw new TypeError('key must be a string or Buffer');\n    }\n\n    if (passphrase !== undefined) {\n      throw new errors.JOSENotSupported('encrypted private keys are not supported in your Node.js runtime version');\n    }\n\n    if (format !== 'pem' && format !== 'der') {\n      throw new TypeError('format must be one of \"pem\" or \"der\"');\n    }\n\n    var label;\n\n    if (format === 'pem') {\n      key = key.toString();\n\n      switch (key.split(/\\r?\\n/g)[0].toString()) {\n        case '-----BEGIN PRIVATE KEY-----':\n          type = 'pkcs8';\n          label = 'PRIVATE KEY';\n          break;\n\n        case '-----BEGIN EC PRIVATE KEY-----':\n          type = 'sec1';\n          label = 'EC PRIVATE KEY';\n          break;\n\n        case '-----BEGIN RSA PRIVATE KEY-----':\n          type = 'pkcs1';\n          label = 'RSA PRIVATE KEY';\n          break;\n\n        default:\n          throw new TypeError('unknown/unsupported PEM type');\n      }\n    }\n\n    switch (type) {\n      case 'pkcs8':\n        {\n          var PrivateKeyInfo = asn1.get('PrivateKeyInfo');\n          var parsed = PrivateKeyInfo.decode(key, format, {\n            label: label\n          });\n\n          var _type2, keyObject;\n\n          switch (parsed.algorithm.algorithm) {\n            case 'ecPublicKey':\n              {\n                _type2 = 'sec1';\n                keyObject = _createPrivateKey2({\n                  type: _type2,\n                  key: parsed.privateKey,\n                  format: 'der'\n                }, _defineProperty({}, namedCurve, parsed.algorithm.parameters.value));\n                break;\n              }\n\n            case 'rsaEncryption':\n              {\n                _type2 = 'pkcs1';\n                keyObject = _createPrivateKey2({\n                  type: _type2,\n                  key: parsed.privateKey,\n                  format: 'der'\n                });\n                break;\n              }\n\n            default:\n              unsupported(parsed.algorithm.algorithm);\n          }\n\n          keyObject._pkcs8 = key;\n          return keyObject;\n        }\n\n      case 'pkcs1':\n        {\n          var RSAPrivateKey = asn1.get('RSAPrivateKey');\n\n          var _parsed3 = RSAPrivateKey.decode(key, format, {\n            label: label\n          });\n\n          var _keyObject2 = new KeyObject();\n\n          _keyObject2._asn1 = _parsed3;\n          _keyObject2._asymmetricKeyType = 'rsa';\n          _keyObject2._type = 'private';\n          _keyObject2._pem = RSAPrivateKey.encode(_parsed3, 'pem', {\n            label: 'RSA PRIVATE KEY'\n          });\n          return _keyObject2;\n        }\n\n      case 'sec1':\n        {\n          var ECPrivateKey = asn1.get('ECPrivateKey');\n\n          var _parsed4 = ECPrivateKey.decode(key, format, {\n            label: label\n          });\n\n          if (!('parameters' in _parsed4) && !hints[namedCurve]) {\n            throw new Error('invalid sec1');\n          } else if (!('parameters' in _parsed4)) {\n            _parsed4 = _objectSpread({}, _parsed4, {\n              parameters: {\n                type: 'namedCurve',\n                value: hints[namedCurve]\n              }\n            });\n          }\n\n          var _keyObject3 = new KeyObject();\n\n          _keyObject3._asn1 = _parsed4;\n          _keyObject3._asymmetricKeyType = 'ec';\n          _keyObject3._type = 'private';\n          _keyObject3._pem = ECPrivateKey.encode(_parsed4, 'pem', {\n            label: 'EC PRIVATE KEY'\n          });\n          return _keyObject3;\n        }\n\n      default:\n        throw new TypeError(\"The value \".concat(type, \" is invalid for option \\\"type\\\"\"));\n    }\n  };\n}\n\nmodule.exports = {\n  createPublicKey: _createPublicKey,\n  createPrivateKey: _createPrivateKey2,\n  createSecretKey: createSecretKey,\n  KeyObject: KeyObject,\n  asInput: asInput\n};","map":null,"metadata":{},"sourceType":"script"}