{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar validate_1 = require(\"./validate\");\n/*!\n * Number of nanoseconds in a millisecond.\n *\n * @type {number}\n */\n\n\nvar MS_TO_NANOS = 1000000;\n/*!\n * The minimum legal value for the \"seconds\" property of a Timestamp object.\n *\n * This value corresponds to 0001-01-01T00:00:00Z.\n *\n * @type {number}\n */\n\nvar MIN_SECONDS = -62135596800;\n/*!\n * The maximum legal value for the \"seconds\" property of a Timestamp object.\n *\n * This value corresponds to 9999-12-31T23:59:59.999999999Z.\n *\n * @type {number}\n */\n\nvar MAX_SECONDS = 253402300799;\n/**\n * A Timestamp represents a point in time independent of any time zone or\n * calendar, represented as seconds and fractions of seconds at nanosecond\n * resolution in UTC Epoch time. It is encoded using the Proleptic Gregorian\n * Calendar which extends the Gregorian calendar backwards to year one. It is\n * encoded assuming all minutes are 60 seconds long, i.e. leap seconds are\n * \"smeared\" so that no leap second table is needed for interpretation. Range is\n * from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z.\n *\n * @see https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto\n */\n\nvar Timestamp = /*#__PURE__*/function () {\n  /**\n   * Creates a new timestamp.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.set({ startTime:new Firestore.Timestamp(42, 0) });\n   *\n   * @param {number} seconds The number of seconds of UTC time since Unix epoch\n   * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n   * 9999-12-31T23:59:59Z inclusive.\n   * @param {number} nanoseconds The non-negative fractions of a second at\n   * nanosecond resolution. Negative second values with fractions must still\n   * have non-negative nanoseconds values that count forward in time. Must be\n   * from 0 to 999,999,999 inclusive.\n   */\n  function Timestamp(seconds, nanoseconds) {\n    _classCallCheck(this, Timestamp);\n\n    validate_1.validateInteger('seconds', seconds, {\n      minValue: MIN_SECONDS,\n      maxValue: MAX_SECONDS\n    });\n    validate_1.validateInteger('nanoseconds', nanoseconds, {\n      minValue: 0,\n      maxValue: 999999999\n    });\n    this._seconds = seconds;\n    this._nanoseconds = nanoseconds;\n  }\n  /**\n   * Creates a new timestamp with the current date, with millisecond precision.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.set({ updateTime:Firestore.Timestamp.now() });\n   *\n   * @return {Timestamp} A new `Timestamp` representing the current date.\n   */\n\n\n  _createClass(Timestamp, [{\n    key: \"toDate\",\n\n    /**\n     * Returns a new `Date` corresponding to this timestamp. This may lose\n     * precision.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(snap => {\n     *   console.log(`Document updated at: ${snap.updateTime.toDate()}`);\n     * });\n     *\n     * @return {Date} JavaScript `Date` object representing the same point in time\n     * as this `Timestamp`, with millisecond precision.\n     */\n    value: function toDate() {\n      return new Date(this._seconds * 1000 + Math.round(this._nanoseconds / MS_TO_NANOS));\n    }\n    /**\n     * Returns the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(snap => {\n     *   let startTime = snap.get('startTime');\n     *   let endTime = snap.get('endTime');\n     *   console.log(`Duration: ${endTime - startTime}`);\n     * });\n     *\n     * @return {number} The point in time corresponding to this timestamp,\n     * represented as the number of milliseconds since Unix epoch\n     * 1970-01-01T00:00:00Z.\n     */\n\n  }, {\n    key: \"toMillis\",\n    value: function toMillis() {\n      return this._seconds * 1000 + Math.floor(this._nanoseconds / MS_TO_NANOS);\n    }\n    /**\n     * Returns 'true' if this `Timestamp` is equal to the provided one.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(snap => {\n     *   if (snap.createTime.isEqual(snap.updateTime)) {\n     *     console.log('Document is in its initial state.');\n     *   }\n     * });\n     *\n     * @param {any} other The `Timestamp` to compare against.\n     * @return {boolean} 'true' if this `Timestamp` is equal to the provided one.\n     */\n\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(other) {\n      return this === other || other instanceof Timestamp && this._seconds === other.seconds && this._nanoseconds === other.nanoseconds;\n    }\n    /**\n     * Generates the Protobuf `Timestamp` object for this timestamp.\n     *\n     * @private\n     * @internal\n     * @returns {Object} The `Timestamp` Protobuf object.\n     */\n\n  }, {\n    key: \"toProto\",\n    value: function toProto() {\n      var timestamp = {};\n\n      if (this.seconds) {\n        timestamp.seconds = this.seconds.toString();\n      }\n\n      if (this.nanoseconds) {\n        timestamp.nanos = this.nanoseconds;\n      }\n\n      return {\n        timestampValue: timestamp\n      };\n    }\n    /**\n     * Converts this object to a primitive `string`, which allows `Timestamp` objects to be compared\n     * using the `>`, `<=`, `>=` and `>` operators.\n     *\n     * @return {string} a string encoding of this object.\n     */\n\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      // This method returns a string of the form <seconds>.<nanoseconds> where <seconds> is\n      // translated to have a non-negative value and both <seconds> and <nanoseconds> are left-padded\n      // with zeroes to be a consistent length. Strings with this format then have a lexicographical\n      // ordering that matches the expected ordering. The <seconds> translation is done to avoid\n      // having a leading negative sign (i.e. a leading '-' character) in its string representation,\n      // which would affect its lexicographical ordering.\n      var adjustedSeconds = this.seconds - MIN_SECONDS; // Note: Up to 12 decimal digits are required to represent all valid 'seconds' values.\n\n      var formattedSeconds = String(adjustedSeconds).padStart(12, '0');\n      var formattedNanoseconds = String(this.nanoseconds).padStart(9, '0');\n      return formattedSeconds + '.' + formattedNanoseconds;\n    }\n  }, {\n    key: \"seconds\",\n\n    /**\n     * The number of seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(snap => {\n     *   let updated = snap.updateTime;\n     *   console.log(`Updated at ${updated.seconds}s ${updated.nanoseconds}ns`);\n     * });\n     *\n     * @type {number}\n     */\n    get: function get() {\n      return this._seconds;\n    }\n    /**\n     * The non-negative fractions of a second at nanosecond resolution.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(snap => {\n     *   let updated = snap.updateTime;\n     *   console.log(`Updated at ${updated.seconds}s ${updated.nanoseconds}ns`);\n     * });\n     *\n     * @type {number}\n     */\n\n  }, {\n    key: \"nanoseconds\",\n    get: function get() {\n      return this._nanoseconds;\n    }\n  }], [{\n    key: \"now\",\n    value: function now() {\n      return Timestamp.fromMillis(Date.now());\n    }\n    /**\n     * Creates a new timestamp from the given date.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * let date = Date.parse('01 Jan 2000 00:00:00 GMT');\n     * documentRef.set({ startTime:Firestore.Timestamp.fromDate(date) });\n     *\n     * @param {Date} date The date to initialize the `Timestamp` from.\n     * @return {Timestamp} A new `Timestamp` representing the same point in time\n     * as the given date.\n     */\n\n  }, {\n    key: \"fromDate\",\n    value: function fromDate(date) {\n      return Timestamp.fromMillis(date.getTime());\n    }\n    /**\n     * Creates a new timestamp from the given number of milliseconds.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.set({ startTime:Firestore.Timestamp.fromMillis(42) });\n     *\n     * @param {number} milliseconds Number of milliseconds since Unix epoch\n     * 1970-01-01T00:00:00Z.\n     * @return {Timestamp}  A new `Timestamp` representing the same point in time\n     * as the given number of milliseconds.\n     */\n\n  }, {\n    key: \"fromMillis\",\n    value: function fromMillis(milliseconds) {\n      var seconds = Math.floor(milliseconds / 1000);\n      var nanos = Math.floor((milliseconds - seconds * 1000) * MS_TO_NANOS);\n      return new Timestamp(seconds, nanos);\n    }\n    /**\n     * Generates a `Timestamp` object from a Timestamp proto.\n     *\n     * @private\n     * @internal\n     * @param {Object} timestamp The `Timestamp` Protobuf object.\n     */\n\n  }, {\n    key: \"fromProto\",\n    value: function fromProto(timestamp) {\n      return new Timestamp(Number(timestamp.seconds || 0), timestamp.nanos || 0);\n    }\n  }]);\n\n  return Timestamp;\n}();\n\nexports.Timestamp = Timestamp;","map":null,"metadata":{},"sourceType":"script"}