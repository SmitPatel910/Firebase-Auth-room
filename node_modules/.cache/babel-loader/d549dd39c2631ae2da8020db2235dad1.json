{"ast":null,"code":"/*! firebase-admin v9.11.0 */\n\"use strict\";\n/*!\n * @license\n * Copyright 2021 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CryptoSignerErrorCode = exports.CryptoSignerError = exports.cryptoSignerFromApp = exports.IAMSigner = exports.ServiceAccountSigner = void 0;\n\nvar credential_internal_1 = require(\"../credential/credential-internal\");\n\nvar api_request_1 = require(\"./api-request\");\n\nvar validator = require(\"../utils/validator\");\n\nvar ALGORITHM_RS256 = 'RS256';\n/**\n * A CryptoSigner implementation that uses an explicitly specified service account private key to\n * sign data. Performs all operations locally, and does not make any RPC calls.\n */\n\nvar ServiceAccountSigner =\n/** @class */\nfunction () {\n  /**\n   * Creates a new CryptoSigner instance from the given service account credential.\n   *\n   * @param {ServiceAccountCredential} credential A service account credential.\n   */\n  function ServiceAccountSigner(credential) {\n    this.credential = credential;\n    this.algorithm = ALGORITHM_RS256;\n\n    if (!credential) {\n      throw new CryptoSignerError({\n        code: CryptoSignerErrorCode.INVALID_CREDENTIAL,\n        message: 'INTERNAL ASSERT: Must provide a service account credential to initialize ServiceAccountSigner.'\n      });\n    }\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  ServiceAccountSigner.prototype.sign = function (buffer) {\n    var crypto = require('crypto'); // eslint-disable-line @typescript-eslint/no-var-requires\n\n\n    var sign = crypto.createSign('RSA-SHA256');\n    sign.update(buffer);\n    return Promise.resolve(sign.sign(this.credential.privateKey));\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  ServiceAccountSigner.prototype.getAccountId = function () {\n    return Promise.resolve(this.credential.clientEmail);\n  };\n\n  return ServiceAccountSigner;\n}();\n\nexports.ServiceAccountSigner = ServiceAccountSigner;\n/**\n * A CryptoSigner implementation that uses the remote IAM service to sign data. If initialized without\n * a service account ID, attempts to discover a service account ID by consulting the local Metadata\n * service. This will succeed in managed environments like Google Cloud Functions and App Engine.\n *\n * @see https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts/signBlob\n * @see https://cloud.google.com/compute/docs/storing-retrieving-metadata\n */\n\nvar IAMSigner =\n/** @class */\nfunction () {\n  function IAMSigner(httpClient, serviceAccountId) {\n    this.algorithm = ALGORITHM_RS256;\n\n    if (!httpClient) {\n      throw new CryptoSignerError({\n        code: CryptoSignerErrorCode.INVALID_ARGUMENT,\n        message: 'INTERNAL ASSERT: Must provide a HTTP client to initialize IAMSigner.'\n      });\n    }\n\n    if (typeof serviceAccountId !== 'undefined' && !validator.isNonEmptyString(serviceAccountId)) {\n      throw new CryptoSignerError({\n        code: CryptoSignerErrorCode.INVALID_ARGUMENT,\n        message: 'INTERNAL ASSERT: Service account ID must be undefined or a non-empty string.'\n      });\n    }\n\n    this.httpClient = httpClient;\n    this.serviceAccountId = serviceAccountId;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  IAMSigner.prototype.sign = function (buffer) {\n    var _this = this;\n\n    return this.getAccountId().then(function (serviceAccount) {\n      var request = {\n        method: 'POST',\n        url: \"https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/\" + serviceAccount + \":signBlob\",\n        data: {\n          payload: buffer.toString('base64')\n        }\n      };\n      return _this.httpClient.send(request);\n    }).then(function (response) {\n      // Response from IAM is base64 encoded. Decode it into a buffer and return.\n      return Buffer.from(response.data.signedBlob, 'base64');\n    }).catch(function (err) {\n      if (err instanceof api_request_1.HttpError) {\n        throw new CryptoSignerError({\n          code: CryptoSignerErrorCode.SERVER_ERROR,\n          message: err.message,\n          cause: err\n        });\n      }\n\n      throw err;\n    });\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  IAMSigner.prototype.getAccountId = function () {\n    var _this = this;\n\n    if (validator.isNonEmptyString(this.serviceAccountId)) {\n      return Promise.resolve(this.serviceAccountId);\n    }\n\n    var request = {\n      method: 'GET',\n      url: 'http://metadata/computeMetadata/v1/instance/service-accounts/default/email',\n      headers: {\n        'Metadata-Flavor': 'Google'\n      }\n    };\n    var client = new api_request_1.HttpClient();\n    return client.send(request).then(function (response) {\n      if (!response.text) {\n        throw new CryptoSignerError({\n          code: CryptoSignerErrorCode.INTERNAL_ERROR,\n          message: 'HTTP Response missing payload'\n        });\n      }\n\n      _this.serviceAccountId = response.text;\n      return response.text;\n    }).catch(function (err) {\n      throw new CryptoSignerError({\n        code: CryptoSignerErrorCode.INVALID_CREDENTIAL,\n        message: 'Failed to determine service account. Make sure to initialize ' + 'the SDK with a service account credential. Alternatively specify a service ' + (\"account with iam.serviceAccounts.signBlob permission. Original error: \" + err)\n      });\n    });\n  };\n\n  return IAMSigner;\n}();\n\nexports.IAMSigner = IAMSigner;\n/**\n * Creates a new CryptoSigner instance for the given app. If the app has been initialized with a\n * service account credential, creates a ServiceAccountSigner.\n *\n * @param {FirebaseApp} app A FirebaseApp instance.\n * @return {CryptoSigner} A CryptoSigner instance.\n */\n\nfunction cryptoSignerFromApp(app) {\n  var credential = app.options.credential;\n\n  if (credential instanceof credential_internal_1.ServiceAccountCredential) {\n    return new ServiceAccountSigner(credential);\n  }\n\n  return new IAMSigner(new api_request_1.AuthorizedHttpClient(app), app.options.serviceAccountId);\n}\n\nexports.cryptoSignerFromApp = cryptoSignerFromApp;\n/**\n * CryptoSigner error code structure.\n *\n * @param {ErrorInfo} errorInfo The error information (code and message).\n * @constructor\n */\n\nvar CryptoSignerError =\n/** @class */\nfunction (_super) {\n  __extends(CryptoSignerError, _super);\n\n  function CryptoSignerError(errorInfo) {\n    var _this = _super.call(this, errorInfo.message) || this;\n\n    _this.errorInfo = errorInfo;\n    /* tslint:disable:max-line-length */\n    // Set the prototype explicitly. See the following link for more details:\n    // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n\n    /* tslint:enable:max-line-length */\n\n    _this.__proto__ = CryptoSignerError.prototype;\n    return _this;\n  }\n\n  Object.defineProperty(CryptoSignerError.prototype, \"code\", {\n    /** @return {string} The error code. */\n    get: function get() {\n      return this.errorInfo.code;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(CryptoSignerError.prototype, \"message\", {\n    /** @return {string} The error message. */\n    get: function get() {\n      return this.errorInfo.message;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(CryptoSignerError.prototype, \"cause\", {\n    /** @return {object} The error data. */\n    get: function get() {\n      return this.errorInfo.cause;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return CryptoSignerError;\n}(Error);\n\nexports.CryptoSignerError = CryptoSignerError;\n/**\n * Crypto Signer error codes and their default messages.\n */\n\nvar CryptoSignerErrorCode =\n/** @class */\nfunction () {\n  function CryptoSignerErrorCode() {}\n\n  CryptoSignerErrorCode.INVALID_ARGUMENT = 'invalid-argument';\n  CryptoSignerErrorCode.INTERNAL_ERROR = 'internal-error';\n  CryptoSignerErrorCode.INVALID_CREDENTIAL = 'invalid-credential';\n  CryptoSignerErrorCode.SERVER_ERROR = 'server-error';\n  return CryptoSignerErrorCode;\n}();\n\nexports.CryptoSignerErrorCode = CryptoSignerErrorCode;","map":null,"metadata":{},"sourceType":"script"}