{"ast":null,"code":"/**\n * @preserve date-and-time (c) KNOWLEDGECODE | MIT\n */\nvar date = {},\n    locales = {},\n    plugins = {},\n    lang = 'en',\n    _res = {\n  MMMM: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n  MMM: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n  dddd: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n  ddd: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n  dd: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],\n  A: ['AM', 'PM']\n},\n    _formatter = {\n  YYYY: function YYYY(d\n  /*, formatString*/\n  ) {\n    return ('000' + d.getFullYear()).slice(-4);\n  },\n  YY: function YY(d\n  /*, formatString*/\n  ) {\n    return ('0' + d.getFullYear()).slice(-2);\n  },\n  Y: function Y(d\n  /*, formatString*/\n  ) {\n    return '' + d.getFullYear();\n  },\n  MMMM: function MMMM(d\n  /*, formatString*/\n  ) {\n    return this.res.MMMM[d.getMonth()];\n  },\n  MMM: function MMM(d\n  /*, formatString*/\n  ) {\n    return this.res.MMM[d.getMonth()];\n  },\n  MM: function MM(d\n  /*, formatString*/\n  ) {\n    return ('0' + (d.getMonth() + 1)).slice(-2);\n  },\n  M: function M(d\n  /*, formatString*/\n  ) {\n    return '' + (d.getMonth() + 1);\n  },\n  DD: function DD(d\n  /*, formatString*/\n  ) {\n    return ('0' + d.getDate()).slice(-2);\n  },\n  D: function D(d\n  /*, formatString*/\n  ) {\n    return '' + d.getDate();\n  },\n  HH: function HH(d\n  /*, formatString*/\n  ) {\n    return ('0' + d.getHours()).slice(-2);\n  },\n  H: function H(d\n  /*, formatString*/\n  ) {\n    return '' + d.getHours();\n  },\n  A: function A(d\n  /*, formatString*/\n  ) {\n    return this.res.A[d.getHours() > 11 | 0];\n  },\n  hh: function hh(d\n  /*, formatString*/\n  ) {\n    return ('0' + (d.getHours() % 12 || 12)).slice(-2);\n  },\n  h: function h(d\n  /*, formatString*/\n  ) {\n    return '' + (d.getHours() % 12 || 12);\n  },\n  mm: function mm(d\n  /*, formatString*/\n  ) {\n    return ('0' + d.getMinutes()).slice(-2);\n  },\n  m: function m(d\n  /*, formatString*/\n  ) {\n    return '' + d.getMinutes();\n  },\n  ss: function ss(d\n  /*, formatString*/\n  ) {\n    return ('0' + d.getSeconds()).slice(-2);\n  },\n  s: function s(d\n  /*, formatString*/\n  ) {\n    return '' + d.getSeconds();\n  },\n  SSS: function SSS(d\n  /*, formatString*/\n  ) {\n    return ('00' + d.getMilliseconds()).slice(-3);\n  },\n  SS: function SS(d\n  /*, formatString*/\n  ) {\n    return ('0' + (d.getMilliseconds() / 10 | 0)).slice(-2);\n  },\n  S: function S(d\n  /*, formatString*/\n  ) {\n    return '' + (d.getMilliseconds() / 100 | 0);\n  },\n  dddd: function dddd(d\n  /*, formatString*/\n  ) {\n    return this.res.dddd[d.getDay()];\n  },\n  ddd: function ddd(d\n  /*, formatString*/\n  ) {\n    return this.res.ddd[d.getDay()];\n  },\n  dd: function dd(d\n  /*, formatString*/\n  ) {\n    return this.res.dd[d.getDay()];\n  },\n  Z: function Z(d\n  /*, formatString*/\n  ) {\n    var offset = d.utc ? 0 : d.getTimezoneOffset() / 0.6;\n    return (offset > 0 ? '-' : '+') + ('000' + Math.abs(offset - offset % 100 * 0.4)).slice(-4);\n  },\n  post: function post(str) {\n    return str;\n  }\n},\n    _parser = {\n  YYYY: function YYYY(str\n  /*, formatString */\n  ) {\n    return this.exec(/^\\d{4}/, str);\n  },\n  Y: function Y(str\n  /*, formatString */\n  ) {\n    return this.exec(/^\\d{1,4}/, str);\n  },\n  MMMM: function MMMM(str\n  /*, formatString */\n  ) {\n    var result = this.find(this.res.MMMM, str);\n    result.value++;\n    return result;\n  },\n  MMM: function MMM(str\n  /*, formatString */\n  ) {\n    var result = this.find(this.res.MMM, str);\n    result.value++;\n    return result;\n  },\n  MM: function MM(str\n  /*, formatString */\n  ) {\n    return this.exec(/^\\d\\d/, str);\n  },\n  M: function M(str\n  /*, formatString */\n  ) {\n    return this.exec(/^\\d\\d?/, str);\n  },\n  DD: function DD(str\n  /*, formatString */\n  ) {\n    return this.exec(/^\\d\\d/, str);\n  },\n  D: function D(str\n  /*, formatString */\n  ) {\n    return this.exec(/^\\d\\d?/, str);\n  },\n  HH: function HH(str\n  /*, formatString */\n  ) {\n    return this.exec(/^\\d\\d/, str);\n  },\n  H: function H(str\n  /*, formatString */\n  ) {\n    return this.exec(/^\\d\\d?/, str);\n  },\n  A: function A(str\n  /*, formatString */\n  ) {\n    return this.find(this.res.A, str);\n  },\n  hh: function hh(str\n  /*, formatString */\n  ) {\n    return this.exec(/^\\d\\d/, str);\n  },\n  h: function h(str\n  /*, formatString */\n  ) {\n    return this.exec(/^\\d\\d?/, str);\n  },\n  mm: function mm(str\n  /*, formatString */\n  ) {\n    return this.exec(/^\\d\\d/, str);\n  },\n  m: function m(str\n  /*, formatString */\n  ) {\n    return this.exec(/^\\d\\d?/, str);\n  },\n  ss: function ss(str\n  /*, formatString */\n  ) {\n    return this.exec(/^\\d\\d/, str);\n  },\n  s: function s(str\n  /*, formatString */\n  ) {\n    return this.exec(/^\\d\\d?/, str);\n  },\n  SSS: function SSS(str\n  /*, formatString */\n  ) {\n    return this.exec(/^\\d{1,3}/, str);\n  },\n  SS: function SS(str\n  /*, formatString */\n  ) {\n    var result = this.exec(/^\\d\\d?/, str);\n    result.value *= 10;\n    return result;\n  },\n  S: function S(str\n  /*, formatString */\n  ) {\n    var result = this.exec(/^\\d/, str);\n    result.value *= 100;\n    return result;\n  },\n  Z: function Z(str\n  /*, formatString */\n  ) {\n    var result = this.exec(/^[\\+-]\\d{2}[0-5]\\d/, str);\n    result.value = (result.value / 100 | 0) * -60 - result.value % 100;\n    return result;\n  },\n  h12: function h12(h, a) {\n    return (h === 12 ? 0 : h) + a * 12;\n  },\n  exec: function exec(re, str) {\n    var result = (re.exec(str) || [''])[0];\n    return {\n      value: result | 0,\n      length: result.length\n    };\n  },\n  find: function find(array, str) {\n    var index = -1,\n        length = 0;\n\n    for (var i = 0, len = array.length, item; i < len; i++) {\n      item = array[i];\n\n      if (!str.indexOf(item) && item.length > length) {\n        index = i;\n        length = item.length;\n      }\n    }\n\n    return {\n      value: index,\n      length: length\n    };\n  },\n  pre: function pre(str) {\n    return str;\n  }\n},\n    customize = function customize(code, base, locale) {\n  var extend = function extend(proto, props, res) {\n    var Locale = function Locale(r) {\n      if (r) {\n        this.res = r;\n      }\n    };\n\n    Locale.prototype = proto;\n    Locale.prototype.constructor = Locale;\n    var newLocale = new Locale(res),\n        value;\n\n    for (var key in props || {}) {\n      value = props[key];\n      newLocale[key] = value.slice ? value.slice() : value;\n    }\n\n    return newLocale;\n  },\n      loc = {\n    res: extend(base.res, locale.res)\n  };\n\n  loc.formatter = extend(base.formatter, locale.formatter, loc.res);\n  loc.parser = extend(base.parser, locale.parser, loc.res);\n  locales[code] = loc;\n};\n/**\n * Compiling a format string\n * @param {string} formatString - a format string\n * @returns {Array.<string>} a compiled object\n */\n\n\ndate.compile = function (formatString) {\n  var re = /\\[([^\\[\\]]|\\[[^\\[\\]]*])*]|([A-Za-z])\\2+|\\.{3}|./g,\n      keys,\n      pattern = [formatString];\n\n  while (keys = re.exec(formatString)) {\n    pattern[pattern.length] = keys[0];\n  }\n\n  return pattern;\n};\n/**\n * Formatting a Date and Time\n * @param {Date} dateObj - a Date object\n * @param {string|Array.<string>} arg - a format string or its compiled object\n * @param {boolean} [utc] - output as UTC\n * @returns {string} a formatted string\n */\n\n\ndate.format = function (dateObj, arg, utc) {\n  var pattern = typeof arg === 'string' ? date.compile(arg) : arg,\n      d = date.addMinutes(dateObj, utc ? dateObj.getTimezoneOffset() : 0),\n      formatter = locales[lang].formatter,\n      str = '';\n  d.utc = utc || false;\n\n  for (var i = 1, len = pattern.length, token; i < len; i++) {\n    token = pattern[i];\n    str += formatter[token] ? formatter.post(formatter[token](d, pattern[0])) : token.replace(/\\[(.*)]/, '$1');\n  }\n\n  return str;\n};\n/**\n * Pre-parsing a Date and Time string\n * @param {string} dateString - a date string\n * @param {string|Array.<string>} arg - a format string or its compiled object\n * @returns {Object} a date structure\n */\n\n\ndate.preparse = function (dateString, arg) {\n  var pattern = typeof arg === 'string' ? date.compile(arg) : arg,\n      dt = {\n    Y: 1970,\n    M: 1,\n    D: 1,\n    H: 0,\n    A: 0,\n    h: 0,\n    m: 0,\n    s: 0,\n    S: 0,\n    Z: 0,\n    _index: 0,\n    _length: 0,\n    _match: 0\n  },\n      comment = /\\[(.*)]/,\n      parser = locales[lang].parser,\n      offset = 0;\n  dateString = parser.pre(dateString);\n\n  for (var i = 1, len = pattern.length, token, result; i < len; i++) {\n    token = pattern[i];\n\n    if (parser[token]) {\n      result = parser[token](dateString.slice(offset), pattern[0]);\n\n      if (!result.length) {\n        break;\n      }\n\n      offset += result.length;\n      dt[token.charAt(0)] = result.value;\n      dt._match++;\n    } else if (token === dateString.charAt(offset) || token === ' ') {\n      offset++;\n    } else if (comment.test(token) && !dateString.slice(offset).indexOf(comment.exec(token)[1])) {\n      offset += token.length - 2;\n    } else if (token === '...') {\n      offset = dateString.length;\n      break;\n    } else {\n      break;\n    }\n  }\n\n  dt.H = dt.H || parser.h12(dt.h, dt.A);\n  dt._index = offset;\n  dt._length = dateString.length;\n  return dt;\n};\n/**\n * Validation\n * @param {Object|string} arg1 - a date structure or a date string\n * @param {string|Array.<string>} [arg2] - a format string or its compiled object\n * @returns {boolean} whether the date string is a valid date\n */\n\n\ndate.isValid = function (arg1, arg2) {\n  var dt = typeof arg1 === 'string' ? date.preparse(arg1, arg2) : arg1,\n      last = [31, 28 + date.isLeapYear(dt.Y) | 0, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][dt.M - 1];\n  return !(dt._index < 1 || dt._length < 1 || dt._index - dt._length || dt._match < 1 || dt.Y < 1 || dt.Y > 9999 || dt.M < 1 || dt.M > 12 || dt.D < 1 || dt.D > last || dt.H < 0 || dt.H > 23 || dt.m < 0 || dt.m > 59 || dt.s < 0 || dt.s > 59 || dt.S < 0 || dt.S > 999 || dt.Z < -720 || dt.Z > 840);\n};\n/**\n * Parsing a Date and Time string\n * @param {string} dateString - a date string\n * @param {string|Array.<string>} arg - a format string or its compiled object\n * @param {boolean} [utc] - input as UTC\n * @returns {Date} a constructed date\n */\n\n\ndate.parse = function (dateString, arg, utc) {\n  var dt = date.preparse(dateString, arg);\n\n  if (date.isValid(dt)) {\n    dt.M -= dt.Y < 100 ? 22801 : 1; // 22801 = 1900 * 12 + 1\n\n    if (utc || dt.Z) {\n      return new Date(Date.UTC(dt.Y, dt.M, dt.D, dt.H, dt.m + dt.Z, dt.s, dt.S));\n    }\n\n    return new Date(dt.Y, dt.M, dt.D, dt.H, dt.m, dt.s, dt.S);\n  }\n\n  return new Date(NaN);\n};\n/**\n * Transforming a Date and Time string\n * @param {string} dateString - a date string\n * @param {string|Array.<string>} arg1 - a format string or its compiled object\n * @param {string|Array.<string>} arg2 - a transformed format string or its compiled object\n * @param {boolean} [utc] - output as UTC\n * @returns {string} a formatted string\n */\n\n\ndate.transform = function (dateString, arg1, arg2, utc) {\n  return date.format(date.parse(dateString, arg1), arg2, utc);\n};\n/**\n * Adding years\n * @param {Date} dateObj - a date object\n * @param {number} years - number of years to add\n * @returns {Date} a date after adding the value\n */\n\n\ndate.addYears = function (dateObj, years) {\n  return date.addMonths(dateObj, years * 12);\n};\n/**\n * Adding months\n * @param {Date} dateObj - a date object\n * @param {number} months - number of months to add\n * @returns {Date} a date after adding the value\n */\n\n\ndate.addMonths = function (dateObj, months) {\n  var d = new Date(dateObj.getTime());\n  d.setMonth(d.getMonth() + months);\n  return d;\n};\n/**\n * Adding days\n * @param {Date} dateObj - a date object\n * @param {number} days - number of days to add\n * @returns {Date} a date after adding the value\n */\n\n\ndate.addDays = function (dateObj, days) {\n  var d = new Date(dateObj.getTime());\n  d.setDate(d.getDate() + days);\n  return d;\n};\n/**\n * Adding hours\n * @param {Date} dateObj - a date object\n * @param {number} hours - number of hours to add\n * @returns {Date} a date after adding the value\n */\n\n\ndate.addHours = function (dateObj, hours) {\n  return date.addMinutes(dateObj, hours * 60);\n};\n/**\n * Adding minutes\n * @param {Date} dateObj - a date object\n * @param {number} minutes - number of minutes to add\n * @returns {Date} a date after adding the value\n */\n\n\ndate.addMinutes = function (dateObj, minutes) {\n  return date.addSeconds(dateObj, minutes * 60);\n};\n/**\n * Adding seconds\n * @param {Date} dateObj - a date object\n * @param {number} seconds - number of seconds to add\n * @returns {Date} a date after adding the value\n */\n\n\ndate.addSeconds = function (dateObj, seconds) {\n  return date.addMilliseconds(dateObj, seconds * 1000);\n};\n/**\n * Adding milliseconds\n * @param {Date} dateObj - a date object\n * @param {number} milliseconds - number of milliseconds to add\n * @returns {Date} a date after adding the value\n */\n\n\ndate.addMilliseconds = function (dateObj, milliseconds) {\n  return new Date(dateObj.getTime() + milliseconds);\n};\n/**\n * Subtracting two dates\n * @param {Date} date1 - a Date object\n * @param {Date} date2 - a Date object\n * @returns {Object} a result object subtracting date2 from date1\n */\n\n\ndate.subtract = function (date1, date2) {\n  var delta = date1.getTime() - date2.getTime();\n  return {\n    toMilliseconds: function toMilliseconds() {\n      return delta;\n    },\n    toSeconds: function toSeconds() {\n      return delta / 1000;\n    },\n    toMinutes: function toMinutes() {\n      return delta / 60000;\n    },\n    toHours: function toHours() {\n      return delta / 3600000;\n    },\n    toDays: function toDays() {\n      return delta / 86400000;\n    }\n  };\n};\n/**\n * Whether year is leap year\n * @param {number} y - year\n * @returns {boolean} whether year is leap year\n */\n\n\ndate.isLeapYear = function (y) {\n  return !(y % 4) && !!(y % 100) || !(y % 400);\n};\n/**\n * Comparison of two dates\n * @param {Date} date1 - a Date object\n * @param {Date} date2 - a Date object\n * @returns {boolean} whether the two dates are the same day (time is ignored)\n */\n\n\ndate.isSameDay = function (date1, date2) {\n  return date1.toDateString() === date2.toDateString();\n};\n/**\n * Changing the locale or defining new locales\n * @param {Function|string} [code] - locale installer | language code\n * @param {Object} [locale] - locale definition\n * @returns {string} current language code\n */\n\n\ndate.locale = function (code, locale) {\n  if (locale) {\n    customize(code, {\n      res: _res,\n      formatter: _formatter,\n      parser: _parser\n    }, locale);\n  } else {\n    lang = (typeof code === 'function' ? code : date.locale[code] || function () {})(date) || lang;\n  }\n\n  return lang;\n};\n/**\n * Feature extension\n * @param {Object} extension - extension object\n * @returns {void}\n */\n\n\ndate.extend = function (extension) {\n  var extender = extension.extender || {};\n\n  for (var key in extender) {\n    if (!date[key]) {\n      date[key] = extender[key];\n    }\n  }\n\n  if (extension.formatter || extension.parser || extension.res) {\n    customize(lang, locales[lang], extension);\n  }\n};\n/**\n * Importing or defining plugins\n * @param {Function|string} name - plugin installer | plugin name\n * @param {Object} [plugin] - plugin object\n * @returns {void}\n */\n\n\ndate.plugin = function (name, plugin) {\n  if (plugin) {\n    if (!plugins[name]) {\n      date.extend(plugins[name] = plugin);\n    }\n  } else {\n    (typeof name === 'function' ? name : date.plugin[name] || function () {})(date);\n  }\n}; // Create default locale (English)\n\n\ndate.locale(lang, {});\nexport default date;","map":null,"metadata":{},"sourceType":"module"}