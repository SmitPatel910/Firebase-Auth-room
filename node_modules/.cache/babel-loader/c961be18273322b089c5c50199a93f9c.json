{"ast":null,"code":"var _objectSpread = require(\"C:\\\\Users\\\\Smit\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread\");\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\Smit\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar isObject = require('../help/is_object');\n\nvar validateCrit = require('../help/validate_crit');\n\nvar _require = require('../errors'),\n    JWSInvalid = _require.JWSInvalid;\n\nvalidateCrit = validateCrit.bind(undefined, JWSInvalid);\n\nvar compactSerializer = function compactSerializer(payload, _ref) {\n  var _ref2 = _slicedToArray(_ref, 1),\n      recipient = _ref2[0];\n\n  return \"\".concat(recipient.protected, \".\").concat(payload, \".\").concat(recipient.signature);\n};\n\ncompactSerializer.validate = function (jws, _ref3) {\n  var _ref3$ = _ref3[0],\n      unprotectedHeader = _ref3$.unprotectedHeader,\n      protectedHeader = _ref3$.protectedHeader,\n      length = _ref3.length;\n\n  if (length !== 1 || unprotectedHeader) {\n    throw new JWSInvalid('JWS Compact Serialization doesn\\'t support multiple recipients or JWS unprotected headers');\n  }\n\n  validateCrit(protectedHeader, unprotectedHeader, protectedHeader ? protectedHeader.crit : undefined);\n};\n\nvar flattenedSerializer = function flattenedSerializer(payload, _ref4) {\n  var _ref5 = _slicedToArray(_ref4, 1),\n      recipient = _ref5[0];\n\n  var header = recipient.header,\n      signature = recipient.signature,\n      prot = recipient.protected;\n  return _objectSpread({\n    payload: payload\n  }, prot ? {\n    protected: prot\n  } : undefined, header ? {\n    header: header\n  } : undefined, {\n    signature: signature\n  });\n};\n\nflattenedSerializer.validate = function (jws, _ref6) {\n  var _ref6$ = _ref6[0],\n      unprotectedHeader = _ref6$.unprotectedHeader,\n      protectedHeader = _ref6$.protectedHeader,\n      length = _ref6.length;\n\n  if (length !== 1) {\n    throw new JWSInvalid('Flattened JWS JSON Serialization doesn\\'t support multiple recipients');\n  }\n\n  validateCrit(protectedHeader, unprotectedHeader, protectedHeader ? protectedHeader.crit : undefined);\n};\n\nvar generalSerializer = function generalSerializer(payload, recipients) {\n  return {\n    payload: payload,\n    signatures: recipients.map(function (_ref7) {\n      var header = _ref7.header,\n          signature = _ref7.signature,\n          prot = _ref7.protected;\n      return _objectSpread({}, prot ? {\n        protected: prot\n      } : undefined, header ? {\n        header: header\n      } : undefined, {\n        signature: signature\n      });\n    })\n  };\n};\n\ngeneralSerializer.validate = function (jws, recipients) {\n  var validateB64 = false;\n  recipients.forEach(function (_ref8) {\n    var protectedHeader = _ref8.protectedHeader,\n        unprotectedHeader = _ref8.unprotectedHeader;\n\n    if (protectedHeader && !validateB64 && 'b64' in protectedHeader) {\n      validateB64 = true;\n    }\n\n    validateCrit(protectedHeader, unprotectedHeader, protectedHeader ? protectedHeader.crit : undefined);\n  });\n\n  if (validateB64) {\n    var values = recipients.map(function (_ref9) {\n      var protectedHeader = _ref9.protectedHeader;\n      return protectedHeader && protectedHeader.b64;\n    });\n\n    if (!values.every(function (actual, i, _ref10) {\n      var _ref11 = _slicedToArray(_ref10, 1),\n          expected = _ref11[0];\n\n      return actual === expected;\n    })) {\n      throw new JWSInvalid('the \"b64\" Header Parameter value MUST be the same for all recipients');\n    }\n  }\n};\n\nvar isJSON = function isJSON(input) {\n  return isObject(input) && (typeof input.payload === 'string' || Buffer.isBuffer(input.payload));\n};\n\nvar isValidRecipient = function isValidRecipient(recipient) {\n  return isObject(recipient) && typeof recipient.signature === 'string' && (recipient.header === undefined || isObject(recipient.header)) && (recipient.protected === undefined || typeof recipient.protected === 'string');\n};\n\nvar isMultiRecipient = function isMultiRecipient(input) {\n  if (Array.isArray(input.signatures) && input.signatures.every(isValidRecipient)) {\n    return true;\n  }\n\n  return false;\n};\n\nvar detect = function detect(input) {\n  if (typeof input === 'string' && input.split('.').length === 3) {\n    return 'compact';\n  }\n\n  if (isJSON(input)) {\n    if (isMultiRecipient(input)) {\n      return 'general';\n    }\n\n    if (isValidRecipient(input)) {\n      return 'flattened';\n    }\n  }\n\n  throw new JWSInvalid('JWS malformed or invalid serialization');\n};\n\nmodule.exports = {\n  compact: compactSerializer,\n  flattened: flattenedSerializer,\n  general: generalSerializer,\n  detect: detect\n};","map":null,"metadata":{},"sourceType":"script"}