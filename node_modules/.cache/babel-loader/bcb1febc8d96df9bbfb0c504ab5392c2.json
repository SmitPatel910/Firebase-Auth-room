{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spread = this && this.__spread || function () {\n  for (var ar = [], i = 0; i < arguments.length; i++) {\n    ar = ar.concat(__read(arguments[i]));\n  }\n\n  return ar;\n};\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar lru_cache_1 = __importDefault(require(\"lru-cache\"));\n\nvar events_1 = require(\"events\");\n\nvar lodash_clonedeep_1 = __importDefault(require(\"lodash.clonedeep\"));\n\nvar freeze_1 = require(\"./freeze\");\n\nvar sync_1 = require(\"./sync\");\n\nfunction asyncMemoizer(options) {\n  var cache = new lru_cache_1.default(options);\n  var load = options.load;\n  var hash = options.hash;\n  var bypass = options.bypass;\n  var itemMaxAge = options.itemMaxAge;\n  var freeze = options.freeze;\n  var clone = options.clone;\n  var queueMaxAge = options.queueMaxAge || 1000;\n  var loading = new Map();\n  var emitter = new events_1.EventEmitter();\n  var memoizerMethods = Object.assign({\n    del: del,\n    reset: function reset() {\n      return cache.reset();\n    },\n    keys: cache.keys.bind(cache),\n    on: emitter.on.bind(emitter),\n    once: emitter.once.bind(emitter)\n  }, options);\n\n  if (options.disable) {\n    return Object.assign(load, memoizerMethods);\n  }\n\n  function del() {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var key = hash.apply(void 0, __spread(args));\n    cache.del(key);\n  }\n\n  function add(key, parameters, result) {\n    if (freeze) {\n      result.forEach(freeze_1.deepFreeze);\n    }\n\n    if (itemMaxAge) {\n      cache.set(key, result, itemMaxAge.apply(void 0, __spread(parameters.concat(result))));\n    } else {\n      cache.set(key, result);\n    }\n  }\n\n  function runCallbacks(callbacks, args) {\n    var e_1, _a;\n\n    try {\n      for (var callbacks_1 = __values(callbacks), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {\n        var callback = callbacks_1_1.value; // Simulate async call when returning from cache\n        // and yield between callback resolution\n\n        if (clone) {\n          setImmediate.apply(void 0, __spread([callback], args.map(lodash_clonedeep_1.default)));\n        } else {\n          setImmediate.apply(void 0, __spread([callback], args));\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return)) _a.call(callbacks_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  }\n\n  function emit(event) {\n    var parameters = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      parameters[_i - 1] = arguments[_i];\n    }\n\n    emitter.emit.apply(emitter, __spread([event], parameters));\n  }\n\n  function memoizedFunction() {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var parameters = args.slice(0, -1);\n    var callback = args.slice(-1).pop();\n    var key;\n\n    if (bypass && bypass.apply(void 0, __spread(parameters))) {\n      emit.apply(void 0, __spread(['miss'], parameters));\n      return load.apply(void 0, __spread(args));\n    }\n\n    if (parameters.length === 0 && !hash) {\n      //the load function only receives callback.\n      key = '_';\n    } else {\n      key = hash.apply(void 0, __spread(parameters));\n    }\n\n    var fromCache = cache.get(key);\n\n    if (fromCache) {\n      emit.apply(void 0, __spread(['hit'], parameters)); // found, invoke callback\n\n      return runCallbacks([callback], [null].concat(fromCache));\n    }\n\n    var pendingLoad = loading.get(key);\n\n    if (pendingLoad && pendingLoad.expiresAt > Date.now()) {\n      // request already in progress, queue and return\n      pendingLoad.queue.push(callback);\n      emit.apply(void 0, __spread(['queue'], parameters));\n      return;\n    }\n\n    emit.apply(void 0, __spread(['miss'], parameters));\n    var started = Date.now(); // no pending request or not resolved before expiration\n    // create a new queue and invoke load\n\n    var queue = [callback];\n    loading.set(key, {\n      queue: queue,\n      expiresAt: started + queueMaxAge\n    });\n\n    var loadHandler = function loadHandler() {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var err = args[0];\n\n      if (!err) {\n        add(key, parameters, args.slice(1));\n      } // this can potentially delete a different queue than `queue` if\n      // this callback was called after expiration.\n      // that will only cause a new call to be performed and a new queue to be\n      // created\n\n\n      loading.delete(key);\n      emit.apply(void 0, __spread(['loaded', Date.now() - started], parameters));\n      runCallbacks(queue, args);\n    };\n\n    load.apply(void 0, __spread(parameters, [loadHandler]));\n  }\n\n  ;\n  return Object.assign(memoizedFunction, memoizerMethods);\n}\n\nexports.asyncMemoizer = asyncMemoizer;\nasyncMemoizer.sync = sync_1.syncMemoizer;","map":null,"metadata":{},"sourceType":"script"}