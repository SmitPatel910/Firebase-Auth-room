{"ast":null,"code":"\"use strict\"; // Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toProto3JSON = void 0;\n\nvar assert = require(\"assert\");\n\nvar any_1 = require(\"./any\");\n\nvar bytes_1 = require(\"./bytes\");\n\nvar util_1 = require(\"./util\");\n\nvar enum_1 = require(\"./enum\");\n\nvar value_1 = require(\"./value\");\n\nvar duration_1 = require(\"./duration\");\n\nvar timestamp_1 = require(\"./timestamp\");\n\nvar wrappers_1 = require(\"./wrappers\");\n\nvar fieldmask_1 = require(\"./fieldmask\");\n\nvar id = function id(x) {\n  return x;\n};\n\nfunction toProto3JSON(obj) {\n  var objType = obj.$type;\n\n  if (!objType) {\n    throw new Error('Cannot serialize object to proto3 JSON since its .$type is unknown. Use Type.fromObject(obj) before calling toProto3JSON.');\n  }\n\n  objType.resolveAll();\n  var typeName = util_1.getFullyQualifiedTypeName(objType); // Types that require special handling according to\n  // https://developers.google.com/protocol-buffers/docs/proto3#json\n\n  if (typeName === '.google.protobuf.Any') {\n    return any_1.googleProtobufAnyToProto3JSON(obj);\n  }\n\n  if (typeName === '.google.protobuf.Value') {\n    return value_1.googleProtobufValueToProto3JSON(obj);\n  }\n\n  if (typeName === '.google.protobuf.Struct') {\n    return value_1.googleProtobufStructToProto3JSON(obj);\n  }\n\n  if (typeName === '.google.protobuf.ListValue') {\n    return value_1.googleProtobufListValueToProto3JSON(obj);\n  }\n\n  if (typeName === '.google.protobuf.Duration') {\n    return duration_1.googleProtobufDurationToProto3JSON(obj);\n  }\n\n  if (typeName === '.google.protobuf.Timestamp') {\n    return timestamp_1.googleProtobufTimestampToProto3JSON(obj);\n  }\n\n  if (typeName === '.google.protobuf.FieldMask') {\n    return fieldmask_1.googleProtobufFieldMaskToProto3JSON(obj);\n  }\n\n  if (util_1.wrapperTypes.has(typeName)) {\n    return wrappers_1.wrapperToProto3JSON(obj);\n  }\n\n  var result = {};\n\n  for (var _i = 0, _Object$entries = Object.entries(obj); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n        key = _Object$entries$_i[0],\n        value = _Object$entries$_i[1];\n\n    var field = objType.fields[key];\n    var fieldResolvedType = field.resolvedType;\n    var fieldFullyQualifiedTypeName = fieldResolvedType ? util_1.getFullyQualifiedTypeName(fieldResolvedType) : null;\n\n    if (value === null) {\n      result[key] = null;\n      continue;\n    }\n\n    if (Array.isArray(value)) {\n      // if the repeated value has a complex type, convert it to proto3 JSON, otherwise use as is\n      result[key] = value.map(fieldResolvedType ? function (element) {\n        return toProto3JSON(element);\n      } : id);\n      continue;\n    }\n\n    if (field.map) {\n      var map = {};\n\n      for (var _i2 = 0, _Object$entries2 = Object.entries(value); _i2 < _Object$entries2.length; _i2++) {\n        var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),\n            mapKey = _Object$entries2$_i[0],\n            mapValue = _Object$entries2$_i[1];\n\n        // if the map value has a complex type, convert it to proto3 JSON, otherwise use as is\n        map[mapKey] = fieldResolvedType ? toProto3JSON(mapValue) : mapValue;\n      }\n\n      result[key] = map;\n      continue;\n    }\n\n    if (fieldFullyQualifiedTypeName === '.google.protobuf.NullValue') {\n      result[key] = null;\n      continue;\n    }\n\n    if (fieldResolvedType && 'values' in fieldResolvedType && value !== null) {\n      result[key] = enum_1.resolveEnumValueToString(fieldResolvedType, value);\n      continue;\n    }\n\n    if (fieldResolvedType) {\n      result[key] = toProto3JSON(value);\n      continue;\n    }\n\n    if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || value === null) {\n      result[key] = value;\n      continue;\n    }\n\n    if (Buffer.isBuffer(value) || value instanceof Uint8Array) {\n      result[key] = bytes_1.bytesToProto3JSON(value);\n      continue;\n    } // The remaining case is Long, everything else is an internal error\n\n\n    assert(value.constructor.name === 'Long', \"toProto3JSON: don't know how to convert field \".concat(key, \" with value \").concat(value));\n    result[key] = value.toString();\n    continue;\n  }\n\n  return result;\n}\n\nexports.toProto3JSON = toProto3JSON;","map":null,"metadata":{},"sourceType":"script"}