{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar assert = require(\"assert\");\n\nvar _1 = require(\".\");\n\nvar util_1 = require(\"./util\");\n\nvar reference_1 = require(\"./reference\");\n/*!\n * Datastore allowed numeric IDs where Firestore only allows strings. Numeric\n * IDs are exposed to Firestore as __idNUM__, so this is the lowest possible\n * negative numeric value expressed in that format.\n *\n * This constant is used to specify startAt/endAt values when querying for all\n * descendants in a single collection.\n */\n\n\nexports.REFERENCE_NAME_MIN_ID = '__id-9223372036854775808__';\n/*!\n * The query limit used for recursive deletes when fetching all descendants of\n * the specified reference to delete. This is done to prevent the query stream\n * from streaming documents faster than Firestore can delete.\n */\n// Visible for testing.\n\nexports.RECURSIVE_DELETE_MAX_PENDING_OPS = 5000;\n/*!\n * The number of pending BulkWriter operations at which RecursiveDelete\n * starts the next limit query to fetch descendants. By starting the query\n * while there are pending operations, Firestore can improve BulkWriter\n * throughput. This helps prevent BulkWriter from idling while Firestore\n * fetches the next query.\n */\n\nexports.RECURSIVE_DELETE_MIN_PENDING_OPS = 1000;\n/**\n * Class used to store state required for running a recursive delete operation.\n * Each recursive delete call should use a new instance of the class.\n * @private\n * @internal\n */\n\nvar RecursiveDelete = /*#__PURE__*/function () {\n  /**\n   *\n   * @param firestore The Firestore instance to use.\n   * @param writer The BulkWriter instance to use for delete operations.\n   * @param ref The document or collection reference to recursively delete.\n   * @param maxLimit The query limit to use when fetching descendants\n   * @param minLimit The number of pending BulkWriter operations at which\n   * RecursiveDelete starts the next limit query to fetch descendants.\n   */\n  function RecursiveDelete(firestore, writer, ref, maxLimit, minLimit) {\n    _classCallCheck(this, RecursiveDelete);\n\n    this.firestore = firestore;\n    this.writer = writer;\n    this.ref = ref;\n    this.maxLimit = maxLimit;\n    this.minLimit = minLimit;\n    /**\n     * The number of deletes that failed with a permanent error.\n     * @private\n     * @internal\n     */\n\n    this.errorCount = 0;\n    /**\n     * Whether there are still documents to delete that still need to be fetched.\n     * @private\n     * @internal\n     */\n\n    this.documentsPending = true;\n    /**\n     * Whether run() has been called.\n     * @private\n     * @internal\n     */\n\n    this.started = false;\n    /**\n     * A deferred promise that resolves when the recursive delete operation\n     * is completed.\n     * @private\n     * @internal\n     */\n\n    this.completionDeferred = new util_1.Deferred();\n    /**\n     * Whether a query stream is currently in progress. Only one stream can be\n     * run at a time.\n     * @private\n     * @internal\n     */\n\n    this.streamInProgress = false;\n    /**\n     * The number of pending BulkWriter operations. Used to determine when the\n     * next query can be run.\n     * @private\n     * @internal\n     */\n\n    this.pendingOpsCount = 0;\n    this.errorStack = '';\n    this.maxPendingOps = maxLimit;\n    this.minPendingOps = minLimit;\n  }\n  /**\n   * Recursively deletes the reference provided in the class constructor.\n   * Returns a promise that resolves when all descendants have been deleted, or\n   * if an error occurs.\n   */\n\n\n  _createClass(RecursiveDelete, [{\n    key: \"run\",\n    value: function run() {\n      assert(!this.started, 'RecursiveDelete.run() should only be called once.'); // Capture the error stack to preserve stack tracing across async calls.\n\n      this.errorStack = Error().stack;\n\n      this.writer._verifyNotClosed();\n\n      this.setupStream();\n      return this.completionDeferred.promise;\n    }\n    /**\n     * Creates a query stream and attaches event handlers to it.\n     * @private\n     * @internal\n     */\n\n  }, {\n    key: \"setupStream\",\n    value: function setupStream() {\n      var _this = this;\n\n      var stream = this.getAllDescendants(this.ref instanceof _1.CollectionReference ? this.ref : this.ref);\n      this.streamInProgress = true;\n      var streamedDocsCount = 0;\n      stream.on('error', function (err) {\n        err.code = 14\n        /* UNAVAILABLE */\n        ;\n        err.stack = 'Failed to fetch children documents: ' + err.stack;\n        _this.lastError = err;\n\n        _this.onQueryEnd();\n      }).on('data', function (snap) {\n        streamedDocsCount++;\n        _this.lastDocumentSnap = snap;\n\n        _this.deleteRef(snap.ref);\n      }).on('end', function () {\n        _this.streamInProgress = false; // If there are fewer than the number of documents specified in the\n        // limit() field, we know that the query is complete.\n\n        if (streamedDocsCount < _this.minPendingOps) {\n          _this.onQueryEnd();\n        } else if (_this.pendingOpsCount === 0) {\n          _this.setupStream();\n        }\n      });\n    }\n    /**\n     * Retrieves all descendant documents nested under the provided reference.\n     * @param ref The reference to fetch all descendants for.\n     * @private\n     * @internal\n     * @return {Stream<QueryDocumentSnapshot>} Stream of descendant documents.\n     */\n\n  }, {\n    key: \"getAllDescendants\",\n    value: function getAllDescendants(ref) {\n      // The parent is the closest ancestor document to the location we're\n      // deleting. If we are deleting a document, the parent is the path of that\n      // document. If we are deleting a collection, the parent is the path of the\n      // document containing that collection (or the database root, if it is a\n      // root collection).\n      var parentPath = ref._resourcePath;\n\n      if (ref instanceof _1.CollectionReference) {\n        parentPath = parentPath.popLast();\n      }\n\n      var collectionId = ref instanceof _1.CollectionReference ? ref.id : ref.parent.id;\n      var query = new _1.Query(this.firestore, reference_1.QueryOptions.forKindlessAllDescendants(parentPath, collectionId,\n      /* requireConsistency= */\n      false)); // Query for names only to fetch empty snapshots.\n\n      query = query.select(_1.FieldPath.documentId()).limit(this.maxPendingOps);\n\n      if (ref instanceof _1.CollectionReference) {\n        // To find all descendants of a collection reference, we need to use a\n        // composite filter that captures all documents that start with the\n        // collection prefix. The MIN_KEY constant represents the minimum key in\n        // this collection, and a null byte + the MIN_KEY represents the minimum\n        // key is the next possible collection.\n        var nullChar = String.fromCharCode(0);\n        var startAt = collectionId + '/' + exports.REFERENCE_NAME_MIN_ID;\n        var endAt = collectionId + nullChar + '/' + exports.REFERENCE_NAME_MIN_ID;\n        query = query.where(_1.FieldPath.documentId(), '>=', startAt).where(_1.FieldPath.documentId(), '<', endAt);\n      }\n\n      if (this.lastDocumentSnap) {\n        query = query.startAfter(this.lastDocumentSnap);\n      }\n\n      return query.stream();\n    }\n    /**\n     * Called when all descendants of the provided reference have been streamed\n     * or if a permanent error occurs during the stream. Deletes the developer\n     * provided reference and wraps any errors that occurred.\n     * @private\n     * @internal\n     */\n\n  }, {\n    key: \"onQueryEnd\",\n    value: function onQueryEnd() {\n      var _this2 = this;\n\n      this.documentsPending = false;\n\n      if (this.ref instanceof _1.DocumentReference) {\n        this.writer.delete(this.ref).catch(function (err) {\n          return _this2.incrementErrorCount(err);\n        });\n      }\n\n      this.writer.flush().then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _a, error;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (_this2.lastError === undefined) {\n                  _this2.completionDeferred.resolve();\n                } else {\n                  error = new (require('google-gax').GoogleError)(\"\".concat(_this2.errorCount, \" \") + \"\".concat(_this2.errorCount !== 1 ? 'deletes' : 'delete', \" \") + 'failed. The last delete failed with: ');\n\n                  if (_this2.lastError.code !== undefined) {\n                    error.code = _this2.lastError.code;\n                  }\n\n                  error = util_1.wrapError(error, _this2.errorStack); // Wrap the BulkWriter error last to provide the full stack trace.\n\n                  _this2.completionDeferred.reject(_this2.lastError.stack ? util_1.wrapError(error, (_a = _this2.lastError.stack) !== null && _a !== void 0 ? _a : '') : error);\n                }\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      })));\n    }\n    /**\n     * Deletes the provided reference and starts the next stream if conditions\n     * are met.\n     * @private\n     * @internal\n     */\n\n  }, {\n    key: \"deleteRef\",\n    value: function deleteRef(docRef) {\n      var _this3 = this;\n\n      this.pendingOpsCount++;\n      this.writer.delete(docRef).catch(function (err) {\n        _this3.incrementErrorCount(err);\n      }).then(function () {\n        _this3.pendingOpsCount--; // We wait until the previous stream has ended in order to sure the\n        // startAfter document is correct. Starting the next stream while\n        // there are pending operations allows Firestore to maximize\n        // BulkWriter throughput.\n\n        if (_this3.documentsPending && !_this3.streamInProgress && _this3.pendingOpsCount < _this3.minPendingOps) {\n          _this3.setupStream();\n        }\n      });\n    }\n  }, {\n    key: \"incrementErrorCount\",\n    value: function incrementErrorCount(err) {\n      this.errorCount++;\n      this.lastError = err;\n    }\n  }]);\n\n  return RecursiveDelete;\n}();\n\nexports.RecursiveDelete = RecursiveDelete;","map":null,"metadata":{},"sourceType":"script"}