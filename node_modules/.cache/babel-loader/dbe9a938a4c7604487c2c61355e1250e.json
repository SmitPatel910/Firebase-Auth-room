{"ast":null,"code":"/*! firebase-admin v9.11.0 */\n\"use strict\";\n/*!\n * Copyright 2020 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DatabaseService = void 0;\n\nvar url_1 = require(\"url\");\n\nvar path = require(\"path\");\n\nvar error_1 = require(\"../utils/error\");\n\nvar validator = require(\"../utils/validator\");\n\nvar api_request_1 = require(\"../utils/api-request\");\n\nvar index_1 = require(\"../utils/index\");\n\nvar TOKEN_REFRESH_THRESHOLD_MILLIS = 5 * 60 * 1000;\n\nvar DatabaseService =\n/** @class */\nfunction () {\n  function DatabaseService(app) {\n    this.databases = {};\n\n    if (!validator.isNonNullObject(app) || !('options' in app)) {\n      throw new error_1.FirebaseDatabaseError({\n        code: 'invalid-argument',\n        message: 'First argument passed to admin.database() must be a valid Firebase app instance.'\n      });\n    }\n\n    this.appInternal = app;\n  }\n  /**\n   * @internal\n   */\n\n\n  DatabaseService.prototype.delete = function () {\n    var _this = this;\n\n    if (this.tokenListener) {\n      this.appInternal.INTERNAL.removeAuthTokenListener(this.tokenListener);\n      clearTimeout(this.tokenRefreshTimeout);\n    }\n\n    var promises = [];\n\n    for (var _i = 0, _a = Object.keys(this.databases); _i < _a.length; _i++) {\n      var dbUrl = _a[_i];\n      var db = this.databases[dbUrl];\n      promises.push(db.INTERNAL.delete());\n    }\n\n    return Promise.all(promises).then(function () {\n      _this.databases = {};\n    });\n  };\n\n  Object.defineProperty(DatabaseService.prototype, \"app\", {\n    /**\n     * Returns the app associated with this DatabaseService instance.\n     *\n     * @return The app associated with this DatabaseService instance.\n     */\n    get: function get() {\n      return this.appInternal;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  DatabaseService.prototype.getDatabase = function (url) {\n    var dbUrl = this.ensureUrl(url);\n\n    if (!validator.isNonEmptyString(dbUrl)) {\n      throw new error_1.FirebaseDatabaseError({\n        code: 'invalid-argument',\n        message: 'Database URL must be a valid, non-empty URL string.'\n      });\n    }\n\n    var db = this.databases[dbUrl];\n\n    if (typeof db === 'undefined') {\n      var rtdb = require('@firebase/database'); // eslint-disable-line @typescript-eslint/no-var-requires\n\n\n      db = rtdb.initStandalone(this.appInternal, dbUrl, index_1.getSdkVersion()).instance;\n      var rulesClient_1 = new DatabaseRulesClient(this.app, dbUrl);\n\n      db.getRules = function () {\n        return rulesClient_1.getRules();\n      };\n\n      db.getRulesJSON = function () {\n        return rulesClient_1.getRulesJSON();\n      };\n\n      db.setRules = function (source) {\n        return rulesClient_1.setRules(source);\n      };\n\n      this.databases[dbUrl] = db;\n    }\n\n    if (!this.tokenListener) {\n      this.tokenListener = this.onTokenChange.bind(this);\n      this.appInternal.INTERNAL.addAuthTokenListener(this.tokenListener);\n    }\n\n    return db;\n  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  DatabaseService.prototype.onTokenChange = function (_) {\n    var token = this.appInternal.INTERNAL.getCachedToken();\n\n    if (token) {\n      var delayMillis = token.expirationTime - TOKEN_REFRESH_THRESHOLD_MILLIS - Date.now(); // If the new token is set to expire soon (unlikely), do nothing. Somebody will eventually\n      // notice and refresh the token, at which point this callback will fire again.\n\n      if (delayMillis > 0) {\n        this.scheduleTokenRefresh(delayMillis);\n      }\n    }\n  };\n\n  DatabaseService.prototype.scheduleTokenRefresh = function (delayMillis) {\n    var _this = this;\n\n    clearTimeout(this.tokenRefreshTimeout);\n    this.tokenRefreshTimeout = setTimeout(function () {\n      _this.appInternal.INTERNAL.getToken(\n      /*forceRefresh=*/\n      true).catch(function () {// Ignore the error since this might just be an intermittent failure. If we really cannot\n        // refresh the token, an error will be logged once the existing token expires and we try\n        // to fetch a fresh one.\n      });\n    }, delayMillis);\n  };\n\n  DatabaseService.prototype.ensureUrl = function (url) {\n    if (typeof url !== 'undefined') {\n      return url;\n    } else if (typeof this.appInternal.options.databaseURL !== 'undefined') {\n      return this.appInternal.options.databaseURL;\n    }\n\n    throw new error_1.FirebaseDatabaseError({\n      code: 'invalid-argument',\n      message: 'Can\\'t determine Firebase Database URL.'\n    });\n  };\n\n  return DatabaseService;\n}();\n\nexports.DatabaseService = DatabaseService;\nvar RULES_URL_PATH = '.settings/rules.json';\n/**\n * A helper client for managing RTDB security rules.\n */\n\nvar DatabaseRulesClient =\n/** @class */\nfunction () {\n  function DatabaseRulesClient(app, dbUrl) {\n    var parsedUrl = new url_1.URL(dbUrl);\n    var emulatorHost = process.env.FIREBASE_DATABASE_EMULATOR_HOST;\n\n    if (emulatorHost) {\n      var namespace = extractNamespace(parsedUrl);\n      parsedUrl = new url_1.URL(\"http://\" + emulatorHost + \"?ns=\" + namespace);\n    }\n\n    parsedUrl.pathname = path.join(parsedUrl.pathname, RULES_URL_PATH);\n    this.dbUrl = parsedUrl.toString();\n    this.httpClient = new api_request_1.AuthorizedHttpClient(app);\n  }\n  /**\n   * Gets the currently applied security rules as a string. The return value consists of\n   * the rules source including comments.\n   *\n   * @return A promise fulfilled with the rules as a raw string.\n   */\n\n\n  DatabaseRulesClient.prototype.getRules = function () {\n    var _this = this;\n\n    var req = {\n      method: 'GET',\n      url: this.dbUrl\n    };\n    return this.httpClient.send(req).then(function (resp) {\n      if (!resp.text) {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'HTTP response missing data.');\n      }\n\n      return resp.text;\n    }).catch(function (err) {\n      throw _this.handleError(err);\n    });\n  };\n  /**\n   * Gets the currently applied security rules as a parsed JSON object. Any comments in\n   * the original source are stripped away.\n   *\n   * @return {Promise<object>} A promise fulfilled with the parsed rules source.\n   */\n\n\n  DatabaseRulesClient.prototype.getRulesJSON = function () {\n    var _this = this;\n\n    var req = {\n      method: 'GET',\n      url: this.dbUrl,\n      data: {\n        format: 'strict'\n      }\n    };\n    return this.httpClient.send(req).then(function (resp) {\n      return resp.data;\n    }).catch(function (err) {\n      throw _this.handleError(err);\n    });\n  };\n  /**\n   * Sets the specified rules on the Firebase Database instance. If the rules source is\n   * specified as a string or a Buffer, it may include comments.\n   *\n   * @param {string|Buffer|object} source Source of the rules to apply. Must not be `null`\n   *  or empty.\n   * @return {Promise<void>} Resolves when the rules are set on the Database.\n   */\n\n\n  DatabaseRulesClient.prototype.setRules = function (source) {\n    var _this = this;\n\n    if (!validator.isNonEmptyString(source) && !validator.isBuffer(source) && !validator.isNonNullObject(source)) {\n      var error = new error_1.FirebaseDatabaseError({\n        code: 'invalid-argument',\n        message: 'Source must be a non-empty string, Buffer or an object.'\n      });\n      return Promise.reject(error);\n    }\n\n    var req = {\n      method: 'PUT',\n      url: this.dbUrl,\n      data: source,\n      headers: {\n        'content-type': 'application/json; charset=utf-8'\n      }\n    };\n    return this.httpClient.send(req).then(function () {\n      return;\n    }).catch(function (err) {\n      throw _this.handleError(err);\n    });\n  };\n\n  DatabaseRulesClient.prototype.handleError = function (err) {\n    if (err instanceof api_request_1.HttpError) {\n      return new error_1.FirebaseDatabaseError({\n        code: error_1.AppErrorCodes.INTERNAL_ERROR,\n        message: this.getErrorMessage(err)\n      });\n    }\n\n    return err;\n  };\n\n  DatabaseRulesClient.prototype.getErrorMessage = function (err) {\n    var intro = 'Error while accessing security rules';\n\n    try {\n      var body = err.response.data;\n\n      if (body && body.error) {\n        return intro + \": \" + body.error.trim();\n      }\n    } catch (_a) {// Ignore parsing errors\n    }\n\n    return intro + \": \" + err.response.text;\n  };\n\n  return DatabaseRulesClient;\n}();\n\nfunction extractNamespace(parsedUrl) {\n  var ns = parsedUrl.searchParams.get('ns');\n\n  if (ns) {\n    return ns;\n  }\n\n  var hostname = parsedUrl.hostname;\n  var dotIndex = hostname.indexOf('.');\n  return hostname.substring(0, dotIndex).toLowerCase();\n}","map":null,"metadata":{},"sourceType":"script"}