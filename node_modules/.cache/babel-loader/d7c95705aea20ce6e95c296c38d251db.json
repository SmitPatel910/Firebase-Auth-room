{"ast":null,"code":"var isObject = require('../help/is_object');\n\nvar epoch = require('../help/epoch');\n\nvar secs = require('../help/secs');\n\nvar getKey = require('../help/get_key');\n\nvar _require = require('../jws/verify'),\n    verify = _require.bare;\n\nvar _require2 = require('../errors'),\n    JWTClaimInvalid = _require2.JWTClaimInvalid,\n    JWTExpired = _require2.JWTExpired;\n\nvar _require3 = require('./shared_validations'),\n    isString = _require3.isString,\n    isNotString = _require3.isNotString,\n    isNotArrayOfStrings = _require3.isNotArrayOfStrings,\n    isTimestamp = _require3.isTimestamp,\n    isStringOrArrayOfStrings = _require3.isStringOrArrayOfStrings;\n\nvar decode = require('./decode');\n\nvar isPayloadString = isString.bind(undefined, JWTClaimInvalid);\nvar isOptionString = isString.bind(undefined, TypeError);\n\nvar normalizeTyp = function normalizeTyp(value) {\n  return value.toLowerCase().replace(/^application\\//, '');\n};\n\nvar validateOptions = function validateOptions(_ref) {\n  var algorithms = _ref.algorithms,\n      audience = _ref.audience,\n      clockTolerance = _ref.clockTolerance,\n      _ref$complete = _ref.complete,\n      complete = _ref$complete === void 0 ? false : _ref$complete,\n      crit = _ref.crit,\n      _ref$ignoreExp = _ref.ignoreExp,\n      ignoreExp = _ref$ignoreExp === void 0 ? false : _ref$ignoreExp,\n      _ref$ignoreIat = _ref.ignoreIat,\n      ignoreIat = _ref$ignoreIat === void 0 ? false : _ref$ignoreIat,\n      _ref$ignoreNbf = _ref.ignoreNbf,\n      ignoreNbf = _ref$ignoreNbf === void 0 ? false : _ref$ignoreNbf,\n      issuer = _ref.issuer,\n      jti = _ref.jti,\n      maxTokenAge = _ref.maxTokenAge,\n      _ref$now = _ref.now,\n      now = _ref$now === void 0 ? new Date() : _ref$now,\n      subject = _ref.subject,\n      typ = _ref.typ;\n\n  if (typeof complete !== 'boolean') {\n    throw new TypeError('options.complete must be a boolean');\n  }\n\n  if (typeof ignoreExp !== 'boolean') {\n    throw new TypeError('options.ignoreExp must be a boolean');\n  }\n\n  if (typeof ignoreNbf !== 'boolean') {\n    throw new TypeError('options.ignoreNbf must be a boolean');\n  }\n\n  if (typeof ignoreIat !== 'boolean') {\n    throw new TypeError('options.ignoreIat must be a boolean');\n  }\n\n  isOptionString(maxTokenAge, 'options.maxTokenAge');\n  isOptionString(subject, 'options.subject');\n  isOptionString(jti, 'options.jti');\n  isOptionString(clockTolerance, 'options.clockTolerance');\n  isOptionString(typ, 'options.typ');\n\n  if (issuer !== undefined && isNotString(issuer) && isNotArrayOfStrings(issuer)) {\n    throw new TypeError('options.issuer must be a string or an array of strings');\n  }\n\n  if (audience !== undefined && isNotString(audience) && isNotArrayOfStrings(audience)) {\n    throw new TypeError('options.audience must be a string or an array of strings');\n  }\n\n  if (algorithms !== undefined && isNotArrayOfStrings(algorithms)) {\n    throw new TypeError('options.algorithms must be an array of strings');\n  }\n\n  if (!(now instanceof Date) || !now.getTime()) {\n    throw new TypeError('options.now must be a valid Date object');\n  }\n\n  if (ignoreIat && maxTokenAge !== undefined) {\n    throw new TypeError('options.ignoreIat and options.maxTokenAge cannot used together');\n  }\n\n  if (crit !== undefined && isNotArrayOfStrings(crit)) {\n    throw new TypeError('options.crit must be an array of strings');\n  }\n\n  return {\n    algorithms: algorithms,\n    audience: audience,\n    clockTolerance: clockTolerance,\n    complete: complete,\n    crit: crit,\n    ignoreExp: ignoreExp,\n    ignoreIat: ignoreIat,\n    ignoreNbf: ignoreNbf,\n    issuer: issuer,\n    jti: jti,\n    maxTokenAge: maxTokenAge,\n    now: now,\n    subject: subject,\n    typ: typ\n  };\n};\n\nvar validateTypes = function validateTypes(_ref2, options) {\n  var header = _ref2.header,\n      payload = _ref2.payload;\n  isPayloadString(header.alg, '\"alg\" header parameter', 'alg', true);\n  isTimestamp(payload.iat, 'iat', !!options.maxTokenAge);\n  isTimestamp(payload.exp, 'exp');\n  isTimestamp(payload.nbf, 'nbf');\n  isPayloadString(payload.jti, '\"jti\" claim', 'jti', !!options.jti);\n  isStringOrArrayOfStrings(payload.iss, 'iss', !!options.issuer);\n  isPayloadString(payload.sub, '\"sub\" claim', 'sub', !!options.subject);\n  isStringOrArrayOfStrings(payload.aud, 'aud', !!options.audience);\n  isPayloadString(header.typ, '\"typ\" header parameter', 'typ', !!options.typ);\n};\n\nvar checkAudiencePresence = function checkAudiencePresence(audPayload, audOption) {\n  if (typeof audPayload === 'string') {\n    return audOption.includes(audPayload);\n  } // Each principal intended to process the JWT MUST\n  // identify itself with a value in the audience claim\n\n\n  audPayload = new Set(audPayload);\n  return audOption.some(Set.prototype.has.bind(audPayload));\n};\n\nmodule.exports = function (token, key) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!isObject(options)) {\n    throw new TypeError('options must be an object');\n  }\n\n  var _options = options = validateOptions(options),\n      algorithms = _options.algorithms,\n      audience = _options.audience,\n      clockTolerance = _options.clockTolerance,\n      complete = _options.complete,\n      crit = _options.crit,\n      ignoreExp = _options.ignoreExp,\n      ignoreIat = _options.ignoreIat,\n      ignoreNbf = _options.ignoreNbf,\n      issuer = _options.issuer,\n      jti = _options.jti,\n      maxTokenAge = _options.maxTokenAge,\n      now = _options.now,\n      subject = _options.subject,\n      typ = _options.typ;\n\n  var decoded = decode(token, {\n    complete: true\n  });\n  key = getKey(key, true);\n\n  if (complete) {\n    var _verify = verify(true, 'preparsed', {\n      decoded: decoded,\n      token: token\n    }, key, {\n      crit: crit,\n      algorithms: algorithms,\n      complete: true\n    });\n\n    key = _verify.key;\n    decoded.key = key;\n  } else {\n    verify(true, 'preparsed', {\n      decoded: decoded,\n      token: token\n    }, key, {\n      crit: crit,\n      algorithms: algorithms\n    });\n  }\n\n  var unix = epoch(now);\n  validateTypes(decoded, options);\n\n  if (issuer && (typeof decoded.payload.iss !== 'string' || !(typeof issuer === 'string' ? [issuer] : issuer).includes(decoded.payload.iss))) {\n    throw new JWTClaimInvalid('unexpected \"iss\" claim value', 'iss', 'check_failed');\n  }\n\n  if (subject && decoded.payload.sub !== subject) {\n    throw new JWTClaimInvalid('unexpected \"sub\" claim value', 'sub', 'check_failed');\n  }\n\n  if (jti && decoded.payload.jti !== jti) {\n    throw new JWTClaimInvalid('unexpected \"jti\" claim value', 'jti', 'check_failed');\n  }\n\n  if (audience && !checkAudiencePresence(decoded.payload.aud, typeof audience === 'string' ? [audience] : audience)) {\n    throw new JWTClaimInvalid('unexpected \"aud\" claim value', 'aud', 'check_failed');\n  }\n\n  if (typ && normalizeTyp(decoded.header.typ) !== normalizeTyp(typ)) {\n    throw new JWTClaimInvalid('unexpected \"typ\" JWT header value', 'typ', 'check_failed');\n  }\n\n  var tolerance = clockTolerance ? secs(clockTolerance) : 0;\n\n  if (!ignoreIat && !('exp' in decoded.payload) && 'iat' in decoded.payload && decoded.payload.iat > unix + tolerance) {\n    throw new JWTClaimInvalid('\"iat\" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed');\n  }\n\n  if (!ignoreNbf && 'nbf' in decoded.payload && decoded.payload.nbf > unix + tolerance) {\n    throw new JWTClaimInvalid('\"nbf\" claim timestamp check failed', 'nbf', 'check_failed');\n  }\n\n  if (!ignoreExp && 'exp' in decoded.payload && decoded.payload.exp <= unix - tolerance) {\n    throw new JWTExpired('\"exp\" claim timestamp check failed', 'exp', 'check_failed');\n  }\n\n  if (maxTokenAge) {\n    var age = unix - decoded.payload.iat;\n    var max = secs(maxTokenAge);\n\n    if (age - tolerance > max) {\n      throw new JWTExpired('\"iat\" claim timestamp check failed (too far in the past)', 'iat', 'check_failed');\n    }\n\n    if (age < 0 - tolerance) {\n      throw new JWTClaimInvalid('\"iat\" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed');\n    }\n  }\n\n  return complete ? decoded : decoded.payload;\n};","map":null,"metadata":{},"sourceType":"script"}