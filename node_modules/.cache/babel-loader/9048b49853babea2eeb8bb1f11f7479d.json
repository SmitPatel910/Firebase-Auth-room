{"ast":null,"code":"\"use strict\"; // Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AwsRequestSigner = void 0;\n\nvar crypto_1 = require(\"../crypto/crypto\");\n/** AWS Signature Version 4 signing algorithm identifier.  */\n\n\nvar AWS_ALGORITHM = 'AWS4-HMAC-SHA256';\n/**\n * The termination string for the AWS credential scope value as defined in\n * https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html\n */\n\nvar AWS_REQUEST_TYPE = 'aws4_request';\n/**\n * Implements an AWS API request signer based on the AWS Signature Version 4\n * signing process.\n * https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html\n */\n\nvar AwsRequestSigner = /*#__PURE__*/function () {\n  /**\n   * Instantiates an AWS API request signer used to send authenticated signed\n   * requests to AWS APIs based on the AWS Signature Version 4 signing process.\n   * This also provides a mechanism to generate the signed request without\n   * sending it.\n   * @param getCredentials A mechanism to retrieve AWS security credentials\n   *   when needed.\n   * @param region The AWS region to use.\n   */\n  function AwsRequestSigner(getCredentials, region) {\n    _classCallCheck(this, AwsRequestSigner);\n\n    this.getCredentials = getCredentials;\n    this.region = region;\n    this.crypto = crypto_1.createCrypto();\n  }\n  /**\n   * Generates the signed request for the provided HTTP request for calling\n   * an AWS API. This follows the steps described at:\n   * https://docs.aws.amazon.com/general/latest/gr/sigv4_signing.html\n   * @param amzOptions The AWS request options that need to be signed.\n   * @return A promise that resolves with the GaxiosOptions containing the\n   *   signed HTTP request parameters.\n   */\n\n\n  _createClass(AwsRequestSigner, [{\n    key: \"getRequestOptions\",\n    value: function () {\n      var _getRequestOptions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(amzOptions) {\n        var requestPayloadData, url, method, requestPayload, additionalAmzHeaders, awsSecurityCredentials, uri, headerMap, headers, awsSignedReq;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (amzOptions.url) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new Error('\"url\" is required in \"amzOptions\"');\n\n              case 2:\n                // Stringify JSON requests. This will be set in the request body of the\n                // generated signed request.\n                requestPayloadData = typeof amzOptions.data === 'object' ? JSON.stringify(amzOptions.data) : amzOptions.data;\n                url = amzOptions.url;\n                method = amzOptions.method || 'GET';\n                requestPayload = amzOptions.body || requestPayloadData;\n                additionalAmzHeaders = amzOptions.headers;\n                _context.next = 9;\n                return this.getCredentials();\n\n              case 9:\n                awsSecurityCredentials = _context.sent;\n                uri = new URL(url);\n                _context.next = 13;\n                return generateAuthenticationHeaderMap({\n                  crypto: this.crypto,\n                  host: uri.host,\n                  canonicalUri: uri.pathname,\n                  canonicalQuerystring: uri.search.substr(1),\n                  method: method,\n                  region: this.region,\n                  securityCredentials: awsSecurityCredentials,\n                  requestPayload: requestPayload,\n                  additionalAmzHeaders: additionalAmzHeaders\n                });\n\n              case 13:\n                headerMap = _context.sent;\n                // Append additional optional headers, eg. X-Amz-Target, Content-Type, etc.\n                headers = Object.assign( // Add x-amz-date if available.\n                headerMap.amzDate ? {\n                  'x-amz-date': headerMap.amzDate\n                } : {}, {\n                  Authorization: headerMap.authorizationHeader,\n                  host: uri.host\n                }, additionalAmzHeaders || {});\n\n                if (awsSecurityCredentials.token) {\n                  Object.assign(headers, {\n                    'x-amz-security-token': awsSecurityCredentials.token\n                  });\n                }\n\n                awsSignedReq = {\n                  url: url,\n                  method: method,\n                  headers: headers\n                };\n\n                if (typeof requestPayload !== 'undefined') {\n                  awsSignedReq.body = requestPayload;\n                }\n\n                return _context.abrupt(\"return\", awsSignedReq);\n\n              case 19:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getRequestOptions(_x) {\n        return _getRequestOptions.apply(this, arguments);\n      }\n\n      return getRequestOptions;\n    }()\n  }]);\n\n  return AwsRequestSigner;\n}();\n\nexports.AwsRequestSigner = AwsRequestSigner;\n/**\n * Creates the HMAC-SHA256 hash of the provided message using the\n * provided key.\n *\n * @param crypto The crypto instance used to facilitate cryptographic\n *   operations.\n * @param key The HMAC-SHA256 key to use.\n * @param msg The message to hash.\n * @return The computed hash bytes.\n */\n\nfunction sign(_x2, _x3, _x4) {\n  return _sign.apply(this, arguments);\n}\n/**\n * Calculates the signing key used to calculate the signature for\n * AWS Signature Version 4 based on:\n * https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html\n *\n * @param crypto The crypto instance used to facilitate cryptographic\n *   operations.\n * @param key The AWS secret access key.\n * @param dateStamp The '%Y%m%d' date format.\n * @param region The AWS region.\n * @param serviceName The AWS service name, eg. sts.\n * @return The signing key bytes.\n */\n\n\nfunction _sign() {\n  _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(crypto, key, msg) {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return crypto.signWithHmacSha256(key, msg);\n\n          case 2:\n            return _context2.abrupt(\"return\", _context2.sent);\n\n          case 3:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _sign.apply(this, arguments);\n}\n\nfunction getSigningKey(_x5, _x6, _x7, _x8, _x9) {\n  return _getSigningKey.apply(this, arguments);\n}\n/**\n * Generates the authentication header map needed for generating the AWS\n * Signature Version 4 signed request.\n *\n * @param option The options needed to compute the authentication header map.\n * @return The AWS authentication header map which constitutes of the following\n *   components: amz-date, authorization header and canonical query string.\n */\n\n\nfunction _getSigningKey() {\n  _getSigningKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(crypto, key, dateStamp, region, serviceName) {\n    var kDate, kRegion, kService, kSigning;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return sign(crypto, \"AWS4\".concat(key), dateStamp);\n\n          case 2:\n            kDate = _context3.sent;\n            _context3.next = 5;\n            return sign(crypto, kDate, region);\n\n          case 5:\n            kRegion = _context3.sent;\n            _context3.next = 8;\n            return sign(crypto, kRegion, serviceName);\n\n          case 8:\n            kService = _context3.sent;\n            _context3.next = 11;\n            return sign(crypto, kService, 'aws4_request');\n\n          case 11:\n            kSigning = _context3.sent;\n            return _context3.abrupt(\"return\", kSigning);\n\n          case 13:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _getSigningKey.apply(this, arguments);\n}\n\nfunction generateAuthenticationHeaderMap(_x10) {\n  return _generateAuthenticationHeaderMap.apply(this, arguments);\n}\n\nfunction _generateAuthenticationHeaderMap() {\n  _generateAuthenticationHeaderMap = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(options) {\n    var additionalAmzHeaders, requestPayload, serviceName, now, amzDate, dateStamp, reformattedAdditionalAmzHeaders, amzHeaders, canonicalHeaders, signedHeadersList, signedHeaders, payloadHash, canonicalRequest, credentialScope, stringToSign, signingKey, signature, authorizationHeader;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            additionalAmzHeaders = options.additionalAmzHeaders || {};\n            requestPayload = options.requestPayload || ''; // iam.amazonaws.com host => iam service.\n            // sts.us-east-2.amazonaws.com => sts service.\n\n            serviceName = options.host.split('.')[0];\n            now = new Date(); // Format: '%Y%m%dT%H%M%SZ'.\n\n            amzDate = now.toISOString().replace(/[-:]/g, '').replace(/\\.[0-9]+/, ''); // Format: '%Y%m%d'.\n\n            dateStamp = now.toISOString().replace(/[-]/g, '').replace(/T.*/, ''); // Change all additional headers to be lower case.\n\n            reformattedAdditionalAmzHeaders = {};\n            Object.keys(additionalAmzHeaders).forEach(function (key) {\n              reformattedAdditionalAmzHeaders[key.toLowerCase()] = additionalAmzHeaders[key];\n            }); // Add AWS token if available.\n\n            if (options.securityCredentials.token) {\n              reformattedAdditionalAmzHeaders['x-amz-security-token'] = options.securityCredentials.token;\n            } // Header keys need to be sorted alphabetically.\n\n\n            amzHeaders = Object.assign({\n              host: options.host\n            }, // Previously the date was not fixed with x-amz- and could be provided manually.\n            // https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-header-value-trim.req\n            reformattedAdditionalAmzHeaders.date ? {} : {\n              'x-amz-date': amzDate\n            }, reformattedAdditionalAmzHeaders);\n            canonicalHeaders = '';\n            signedHeadersList = Object.keys(amzHeaders).sort();\n            signedHeadersList.forEach(function (key) {\n              canonicalHeaders += \"\".concat(key, \":\").concat(amzHeaders[key], \"\\n\");\n            });\n            signedHeaders = signedHeadersList.join(';');\n            _context4.next = 16;\n            return options.crypto.sha256DigestHex(requestPayload);\n\n          case 16:\n            payloadHash = _context4.sent;\n            // https://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html\n            canonicalRequest = \"\".concat(options.method, \"\\n\") + \"\".concat(options.canonicalUri, \"\\n\") + \"\".concat(options.canonicalQuerystring, \"\\n\") + \"\".concat(canonicalHeaders, \"\\n\") + \"\".concat(signedHeaders, \"\\n\") + \"\".concat(payloadHash);\n            credentialScope = \"\".concat(dateStamp, \"/\").concat(options.region, \"/\").concat(serviceName, \"/\").concat(AWS_REQUEST_TYPE); // https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html\n\n            _context4.t0 = \"\".concat(AWS_ALGORITHM, \"\\n\") + \"\".concat(amzDate, \"\\n\") + \"\".concat(credentialScope, \"\\n\");\n            _context4.next = 22;\n            return options.crypto.sha256DigestHex(canonicalRequest);\n\n          case 22:\n            _context4.t1 = _context4.sent;\n            stringToSign = _context4.t0 + _context4.t1;\n            _context4.next = 26;\n            return getSigningKey(options.crypto, options.securityCredentials.secretAccessKey, dateStamp, options.region, serviceName);\n\n          case 26:\n            signingKey = _context4.sent;\n            _context4.next = 29;\n            return sign(options.crypto, signingKey, stringToSign);\n\n          case 29:\n            signature = _context4.sent;\n            // https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n            authorizationHeader = \"\".concat(AWS_ALGORITHM, \" Credential=\").concat(options.securityCredentials.accessKeyId, \"/\") + \"\".concat(credentialScope, \", SignedHeaders=\").concat(signedHeaders, \", \") + \"Signature=\".concat(crypto_1.fromArrayBufferToHex(signature));\n            return _context4.abrupt(\"return\", {\n              // Do not return x-amz-date if date is available.\n              amzDate: reformattedAdditionalAmzHeaders.date ? undefined : amzDate,\n              authorizationHeader: authorizationHeader,\n              canonicalQuerystring: options.canonicalQuerystring\n            });\n\n          case 32:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _generateAuthenticationHeaderMap.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"script"}