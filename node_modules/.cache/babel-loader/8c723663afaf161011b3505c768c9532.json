{"ast":null,"code":"var RetryOperation = require('./retry_operation');\n\nexports.operation = function (options) {\n  var timeouts = exports.timeouts(options);\n  return new RetryOperation(timeouts, {\n    forever: options && (options.forever || options.retries === Infinity),\n    unref: options && options.unref,\n    maxRetryTime: options && options.maxRetryTime\n  });\n};\n\nexports.timeouts = function (options) {\n  if (options instanceof Array) {\n    return [].concat(options);\n  }\n\n  var opts = {\n    retries: 10,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: Infinity,\n    randomize: false\n  };\n\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  if (opts.minTimeout > opts.maxTimeout) {\n    throw new Error('minTimeout is greater than maxTimeout');\n  }\n\n  var timeouts = [];\n\n  for (var i = 0; i < opts.retries; i++) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  if (options && options.forever && !timeouts.length) {\n    timeouts.push(this.createTimeout(i, opts));\n  } // sort the array numerically ascending\n\n\n  timeouts.sort(function (a, b) {\n    return a - b;\n  });\n  return timeouts;\n};\n\nexports.createTimeout = function (attempt, opts) {\n  var random = opts.randomize ? Math.random() + 1 : 1;\n  var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));\n  timeout = Math.min(timeout, opts.maxTimeout);\n  return timeout;\n};\n\nexports.wrap = function (obj, options, methods) {\n  if (options instanceof Array) {\n    methods = options;\n    options = null;\n  }\n\n  if (!methods) {\n    methods = [];\n\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        methods.push(key);\n      }\n    }\n  }\n\n  for (var i = 0; i < methods.length; i++) {\n    var method = methods[i];\n    var original = obj[method];\n\n    obj[method] = function retryWrapper(original) {\n      var op = exports.operation(options);\n      var args = Array.prototype.slice.call(arguments, 1);\n      var callback = args.pop();\n      args.push(function (err) {\n        if (op.retry(err)) {\n          return;\n        }\n\n        if (err) {\n          arguments[0] = op.mainError();\n        }\n\n        callback.apply(this, arguments);\n      });\n      op.attempt(function () {\n        original.apply(obj, args);\n      });\n    }.bind(obj, original);\n\n    obj[method].options = options;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}