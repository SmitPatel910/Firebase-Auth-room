{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar convert_1 = require(\"./convert\");\n\nvar field_value_1 = require(\"./field-value\");\n\nvar geo_point_1 = require(\"./geo-point\");\n\nvar index_1 = require(\"./index\");\n\nvar path_1 = require(\"./path\");\n\nvar timestamp_1 = require(\"./timestamp\");\n\nvar util_1 = require(\"./util\");\n\nvar validate_1 = require(\"./validate\");\n/**\n * The maximum depth of a Firestore object.\n *\n * @private\n * @internal\n */\n\n\nvar MAX_DEPTH = 20;\n/**\n * Serializer that is used to convert between JavaScript types and their\n * Firestore Protobuf representation.\n *\n * @private\n * @internal\n */\n\nvar Serializer = /*#__PURE__*/function () {\n  function Serializer(firestore) {\n    _classCallCheck(this, Serializer);\n\n    // Instead of storing the `firestore` object, we store just a reference to\n    // its `.doc()` method. This avoid a circular reference, which breaks\n    // JSON.stringify().\n    this.createReference = function (path) {\n      return firestore.doc(path);\n    };\n\n    this.createInteger = function (n) {\n      return firestore._settings.useBigInt ? BigInt(n) : Number(n);\n    };\n\n    this.allowUndefined = !!firestore._settings.ignoreUndefinedProperties;\n  }\n  /**\n   * Encodes a JavaScript object into the Firestore 'Fields' representation.\n   *\n   * @private\n   * @internal\n   * @param obj The object to encode.\n   * @returns The Firestore 'Fields' representation\n   */\n\n\n  _createClass(Serializer, [{\n    key: \"encodeFields\",\n    value: function encodeFields(obj) {\n      var fields = {};\n\n      for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {\n        var prop = _Object$keys[_i];\n        var val = this.encodeValue(obj[prop]);\n\n        if (val) {\n          fields[prop] = val;\n        }\n      }\n\n      return fields;\n    }\n    /**\n     * Encodes a JavaScript value into the Firestore 'Value' representation.\n     *\n     * @private\n     * @internal\n     * @param val The object to encode\n     * @returns The Firestore Proto or null if we are deleting a field.\n     */\n\n  }, {\n    key: \"encodeValue\",\n    value: function encodeValue(val) {\n      if (val instanceof field_value_1.FieldTransform) {\n        return null;\n      }\n\n      if (typeof val === 'string') {\n        return {\n          stringValue: val\n        };\n      }\n\n      if (typeof val === 'boolean') {\n        return {\n          booleanValue: val\n        };\n      }\n\n      if (typeof val === 'number') {\n        if (Number.isSafeInteger(val)) {\n          return {\n            integerValue: val\n          };\n        } else {\n          return {\n            doubleValue: val\n          };\n        }\n      }\n\n      if (typeof val === 'bigint') {\n        return {\n          integerValue: val.toString()\n        };\n      }\n\n      if (val instanceof Date) {\n        var timestamp = timestamp_1.Timestamp.fromDate(val);\n        return {\n          timestampValue: {\n            seconds: timestamp.seconds,\n            nanos: timestamp.nanoseconds\n          }\n        };\n      }\n\n      if (isMomentJsType(val)) {\n        var _timestamp = timestamp_1.Timestamp.fromDate(val.toDate());\n\n        return {\n          timestampValue: {\n            seconds: _timestamp.seconds,\n            nanos: _timestamp.nanoseconds\n          }\n        };\n      }\n\n      if (val === null) {\n        return {\n          nullValue: 'NULL_VALUE'\n        };\n      }\n\n      if (val instanceof Buffer || val instanceof Uint8Array) {\n        return {\n          bytesValue: val\n        };\n      }\n\n      if (util_1.isObject(val)) {\n        var toProto = val['toProto'];\n\n        if (typeof toProto === 'function') {\n          return toProto.bind(val)();\n        }\n      }\n\n      if (Array.isArray(val)) {\n        var array = {\n          arrayValue: {}\n        };\n\n        if (val.length > 0) {\n          array.arrayValue.values = [];\n\n          for (var i = 0; i < val.length; ++i) {\n            var enc = this.encodeValue(val[i]);\n\n            if (enc) {\n              array.arrayValue.values.push(enc);\n            }\n          }\n        }\n\n        return array;\n      }\n\n      if (typeof val === 'object' && util_1.isPlainObject(val)) {\n        var map = {\n          mapValue: {}\n        }; // If we encounter an empty object, we always need to send it to make sure\n        // the server creates a map entry.\n\n        if (!util_1.isEmpty(val)) {\n          map.mapValue.fields = this.encodeFields(val);\n\n          if (util_1.isEmpty(map.mapValue.fields)) {\n            return null;\n          }\n        }\n\n        return map;\n      }\n\n      if (val === undefined && this.allowUndefined) {\n        return null;\n      }\n\n      throw new Error(\"Cannot encode value: \".concat(val));\n    }\n    /**\n     * Decodes a single Firestore 'Value' Protobuf.\n     *\n     * @private\n     * @internal\n     * @param proto A Firestore 'Value' Protobuf.\n     * @returns The converted JS type.\n     */\n\n  }, {\n    key: \"decodeValue\",\n    value: function decodeValue(proto) {\n      var valueType = convert_1.detectValueType(proto);\n\n      switch (valueType) {\n        case 'stringValue':\n          {\n            return proto.stringValue;\n          }\n\n        case 'booleanValue':\n          {\n            return proto.booleanValue;\n          }\n\n        case 'integerValue':\n          {\n            return this.createInteger(proto.integerValue);\n          }\n\n        case 'doubleValue':\n          {\n            return proto.doubleValue;\n          }\n\n        case 'timestampValue':\n          {\n            return timestamp_1.Timestamp.fromProto(proto.timestampValue);\n          }\n\n        case 'referenceValue':\n          {\n            var resourcePath = path_1.QualifiedResourcePath.fromSlashSeparatedString(proto.referenceValue);\n            return this.createReference(resourcePath.relativeName);\n          }\n\n        case 'arrayValue':\n          {\n            var array = [];\n\n            if (Array.isArray(proto.arrayValue.values)) {\n              var _iterator = _createForOfIteratorHelper(proto.arrayValue.values),\n                  _step;\n\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  var value = _step.value;\n                  array.push(this.decodeValue(value));\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n            }\n\n            return array;\n          }\n\n        case 'nullValue':\n          {\n            return null;\n          }\n\n        case 'mapValue':\n          {\n            var obj = {};\n            var fields = proto.mapValue.fields;\n\n            if (fields) {\n              for (var _i2 = 0, _Object$keys2 = Object.keys(fields); _i2 < _Object$keys2.length; _i2++) {\n                var prop = _Object$keys2[_i2];\n                obj[prop] = this.decodeValue(fields[prop]);\n              }\n            }\n\n            return obj;\n          }\n\n        case 'geoPointValue':\n          {\n            return geo_point_1.GeoPoint.fromProto(proto.geoPointValue);\n          }\n\n        case 'bytesValue':\n          {\n            return proto.bytesValue;\n          }\n\n        default:\n          {\n            throw new Error('Cannot decode type from Firestore Value: ' + JSON.stringify(proto));\n          }\n      }\n    }\n  }]);\n\n  return Serializer;\n}();\n\nexports.Serializer = Serializer;\n/**\n * Validates a JavaScript value for usage as a Firestore value.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param value JavaScript value to validate.\n * @param desc A description of the expected type.\n * @param path The field path to validate.\n * @param options Validation options\n * @param level The current depth of the traversal. This is used to decide\n * whether undefined values or deletes are allowed.\n * @param inArray Whether we are inside an array.\n * @throws when the object is invalid.\n */\n\nfunction validateUserInput(arg, value, desc, options, path, level, inArray) {\n  if (path && path.size > MAX_DEPTH) {\n    throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, desc), \" Input object is deeper than \").concat(MAX_DEPTH, \" levels or contains a cycle.\"));\n  }\n\n  level = level || 0;\n  inArray = inArray || false;\n  var fieldPathMessage = path ? \" (found in field \\\"\".concat(path, \"\\\")\") : '';\n\n  if (Array.isArray(value)) {\n    for (var i = 0; i < value.length; ++i) {\n      validateUserInput(arg, value[i], desc, options, path ? path.append(String(i)) : new path_1.FieldPath(String(i)), level + 1,\n      /* inArray= */\n      true);\n    }\n  } else if (util_1.isPlainObject(value)) {\n    for (var _i3 = 0, _Object$keys3 = Object.keys(value); _i3 < _Object$keys3.length; _i3++) {\n      var prop = _Object$keys3[_i3];\n      validateUserInput(arg, value[prop], desc, options, path ? path.append(new path_1.FieldPath(prop)) : new path_1.FieldPath(prop), level + 1, inArray);\n    }\n  } else if (value === undefined) {\n    if (options.allowUndefined && level === 0) {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, desc), \" \\\"undefined\\\" values are only ignored inside of objects.\"));\n    } else if (!options.allowUndefined) {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, desc), \" Cannot use \\\"undefined\\\" as a Firestore value\").concat(fieldPathMessage, \". \") + 'If you want to ignore undefined values, enable `ignoreUndefinedProperties`.');\n    }\n  } else if (value instanceof field_value_1.DeleteTransform) {\n    if (inArray) {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, desc), \" \").concat(value.methodName, \"() cannot be used inside of an array\").concat(fieldPathMessage, \".\"));\n    } else if (options.allowDeletes === 'none') {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, desc), \" \").concat(value.methodName, \"() must appear at the top-level and can only be used in update() \") + \"or set() with {merge:true}\".concat(fieldPathMessage, \".\"));\n    } else if (options.allowDeletes === 'root') {\n      if (level === 0) {// Ok (update() with UpdateData).\n      } else if (level === 1 && (path === null || path === void 0 ? void 0 : path.size) === 1) {// Ok (update with varargs).\n      } else {\n        throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, desc), \" \").concat(value.methodName, \"() must appear at the top-level and can only be used in update() \") + \"or set() with {merge:true}\".concat(fieldPathMessage, \".\"));\n      }\n    }\n  } else if (value instanceof field_value_1.FieldTransform) {\n    if (inArray) {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, desc), \" \").concat(value.methodName, \"() cannot be used inside of an array\").concat(fieldPathMessage, \".\"));\n    } else if (!options.allowTransforms) {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, desc), \" \").concat(value.methodName, \"() can only be used in set(), create() or update()\").concat(fieldPathMessage, \".\"));\n    }\n  } else if (value instanceof path_1.FieldPath) {\n    throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, desc), \" Cannot use object of type \\\"FieldPath\\\" as a Firestore value\").concat(fieldPathMessage, \".\"));\n  } else if (value instanceof index_1.DocumentReference) {// Ok.\n  } else if (value instanceof geo_point_1.GeoPoint) {// Ok.\n  } else if (value instanceof timestamp_1.Timestamp || value instanceof Date) {// Ok.\n  } else if (isMomentJsType(value)) {// Ok.\n  } else if (value instanceof Buffer || value instanceof Uint8Array) {// Ok.\n  } else if (value === null) {// Ok.\n  } else if (typeof value === 'object') {\n    throw new Error(validate_1.customObjectMessage(arg, value, path));\n  }\n}\n\nexports.validateUserInput = validateUserInput;\n/**\n * Returns true if value is a MomentJs date object.\n * @private\n * @internal\n */\n\nfunction isMomentJsType(value) {\n  return typeof value === 'object' && value !== null && value.constructor && value.constructor.name === 'Moment' && typeof value.toDate === 'function';\n}","map":null,"metadata":{},"sourceType":"script"}