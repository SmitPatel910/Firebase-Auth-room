{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\Smit\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Smit\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Smit\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\Smit\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\Smit\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\Smit\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar net_1 = __importDefault(require(\"net\"));\n\nvar tls_1 = __importDefault(require(\"tls\"));\n\nvar url_1 = __importDefault(require(\"url\"));\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar once_1 = __importDefault(require(\"@tootallnate/once\"));\n\nvar agent_base_1 = require(\"agent-base\");\n\nvar debug = debug_1.default('http-proxy-agent');\n\nfunction isHTTPS(protocol) {\n  return typeof protocol === 'string' ? /^https:?$/i.test(protocol) : false;\n}\n/**\n * The `HttpProxyAgent` implements an HTTP Agent subclass that connects\n * to the specified \"HTTP proxy server\" in order to proxy HTTP requests.\n *\n * @api public\n */\n\n\nvar HttpProxyAgent = /*#__PURE__*/function (_agent_base_1$Agent) {\n  _inherits(HttpProxyAgent, _agent_base_1$Agent);\n\n  function HttpProxyAgent(_opts) {\n    var _this;\n\n    _classCallCheck(this, HttpProxyAgent);\n\n    var opts;\n\n    if (typeof _opts === 'string') {\n      opts = url_1.default.parse(_opts);\n    } else {\n      opts = _opts;\n    }\n\n    if (!opts) {\n      throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!');\n    }\n\n    debug('Creating new HttpProxyAgent instance: %o', opts);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(HttpProxyAgent).call(this, opts));\n    var proxy = Object.assign({}, opts); // If `true`, then connect to the proxy server over TLS.\n    // Defaults to `false`.\n\n    _this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol); // Prefer `hostname` over `host`, and set the `port` if needed.\n\n    proxy.host = proxy.hostname || proxy.host;\n\n    if (typeof proxy.port === 'string') {\n      proxy.port = parseInt(proxy.port, 10);\n    }\n\n    if (!proxy.port && proxy.host) {\n      proxy.port = _this.secureProxy ? 443 : 80;\n    }\n\n    if (proxy.host && proxy.path) {\n      // If both a `host` and `path` are specified then it's most likely\n      // the result of a `url.parse()` call... we need to remove the\n      // `path` portion so that `net.connect()` doesn't attempt to open\n      // that as a Unix socket file.\n      delete proxy.path;\n      delete proxy.pathname;\n    }\n\n    _this.proxy = proxy;\n    return _this;\n  }\n  /**\n   * Called when the node-core HTTP client library is creating a\n   * new HTTP request.\n   *\n   * @api protected\n   */\n\n\n  _createClass(HttpProxyAgent, [{\n    key: \"callback\",\n    value: function callback(req, opts) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var proxy, secureProxy, parsed, socket, first, endOfHeaders;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                proxy = this.proxy, secureProxy = this.secureProxy;\n                parsed = url_1.default.parse(req.path);\n\n                if (!parsed.protocol) {\n                  parsed.protocol = 'http:';\n                }\n\n                if (!parsed.hostname) {\n                  parsed.hostname = opts.hostname || opts.host || null;\n                }\n\n                if (parsed.port == null && typeof opts.port) {\n                  parsed.port = String(opts.port);\n                }\n\n                if (parsed.port === '80') {\n                  // if port is 80, then we can remove the port so that the\n                  // \":80\" portion is not on the produced URL\n                  delete parsed.port;\n                } // Change the `http.ClientRequest` instance's \"path\" field\n                // to the absolute path of the URL that will be requested.\n\n\n                req.path = url_1.default.format(parsed); // Inject the `Proxy-Authorization` header if necessary.\n\n                if (proxy.auth) {\n                  req.setHeader('Proxy-Authorization', \"Basic \".concat(Buffer.from(proxy.auth).toString('base64')));\n                } // Create a socket connection to the proxy server.\n\n\n                if (secureProxy) {\n                  debug('Creating `tls.Socket`: %o', proxy);\n                  socket = tls_1.default.connect(proxy);\n                } else {\n                  debug('Creating `net.Socket`: %o', proxy);\n                  socket = net_1.default.connect(proxy);\n                } // At this point, the http ClientRequest's internal `_header` field\n                // might have already been set. If this is the case then we'll need\n                // to re-generate the string since we just changed the `req.path`.\n\n\n                if (req._header) {\n                  debug('Regenerating stored HTTP header string for request');\n                  req._header = null;\n\n                  req._implicitHeader();\n\n                  if (req.output && req.output.length > 0) {\n                    // Node < 12\n                    debug('Patching connection write() output buffer with updated header');\n                    first = req.output[0];\n                    endOfHeaders = first.indexOf('\\r\\n\\r\\n') + 4;\n                    req.output[0] = req._header + first.substring(endOfHeaders);\n                    debug('Output buffer: %o', req.output);\n                  } else if (req.outputData && req.outputData.length > 0) {\n                    // Node >= 12\n                    debug('Patching connection write() output buffer with updated header');\n                    first = req.outputData[0].data;\n                    endOfHeaders = first.indexOf('\\r\\n\\r\\n') + 4;\n                    req.outputData[0].data = req._header + first.substring(endOfHeaders);\n                    debug('Output buffer: %o', req.outputData[0].data);\n                  }\n                } // Wait for the socket's `connect` event, so that this `callback()`\n                // function throws instead of the `http` request machinery. This is\n                // important for i.e. `PacProxyAgent` which determines a failed proxy\n                // connection via the `callback()` function throwing.\n\n\n                _context.next = 12;\n                return once_1.default(socket, 'connect');\n\n              case 12:\n                return _context.abrupt(\"return\", socket);\n\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }]);\n\n  return HttpProxyAgent;\n}(agent_base_1.Agent);\n\nexports.default = HttpProxyAgent;","map":null,"metadata":{},"sourceType":"script"}