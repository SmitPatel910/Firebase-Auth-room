{"ast":null,"code":"var _require = require('crypto'),\n    createHash = _require.createHash;\n\nvar ecdhComputeSecret = require('./compute_secret');\n\nvar concat = function concat(key, length, value) {\n  var iterations = Math.ceil(length / 32);\n  var res;\n\n  for (var iter = 1; iter <= iterations; iter++) {\n    var buf = Buffer.allocUnsafe(4 + key.length + value.length);\n    buf.writeUInt32BE(iter, 0);\n    key.copy(buf, 4);\n    value.copy(buf, 4 + key.length);\n\n    if (!res) {\n      res = createHash('sha256').update(buf).digest();\n    } else {\n      res = Buffer.concat([res, createHash('sha256').update(buf).digest()]);\n    }\n  }\n\n  return res.slice(0, length);\n};\n\nvar uint32be = function uint32be(value) {\n  var buf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Buffer.allocUnsafe(4);\n  buf.writeUInt32BE(value);\n  return buf;\n};\n\nvar lengthAndInput = function lengthAndInput(input) {\n  return Buffer.concat([uint32be(input.length), input]);\n};\n\nmodule.exports = function (alg, keyLen, privKey, pubKey) {\n  var _ref = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {},\n      _ref$apu = _ref.apu,\n      apu = _ref$apu === void 0 ? Buffer.alloc(0) : _ref$apu,\n      _ref$apv = _ref.apv,\n      apv = _ref$apv === void 0 ? Buffer.alloc(0) : _ref$apv;\n\n  var computeSecret = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : ecdhComputeSecret;\n  var value = Buffer.concat([lengthAndInput(Buffer.from(alg)), lengthAndInput(apu), lengthAndInput(apv), uint32be(keyLen)]);\n  var sharedSecret = computeSecret(privKey, pubKey);\n  return concat(sharedSecret, keyLen / 8, value);\n};","map":null,"metadata":{},"sourceType":"script"}