{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _get = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar deepEqual = require(\"fast-deep-equal\");\n\nvar assert = require(\"assert\");\n\nvar field_value_1 = require(\"./field-value\");\n\nvar path_1 = require(\"./path\");\n\nvar reference_1 = require(\"./reference\");\n\nvar types_1 = require(\"./types\");\n\nvar util_1 = require(\"./util\");\n/**\n * Returns a builder for DocumentSnapshot and QueryDocumentSnapshot instances.\n * Invoke `.build()' to assemble the final snapshot.\n *\n * @private\n * @internal\n */\n\n\nvar DocumentSnapshotBuilder = /*#__PURE__*/function () {\n  // We include the DocumentReference in the constructor in order to allow the\n  // DocumentSnapshotBuilder to be typed with <T> when it is constructed.\n  function DocumentSnapshotBuilder(ref) {\n    _classCallCheck(this, DocumentSnapshotBuilder);\n\n    this.ref = ref;\n  }\n  /**\n   * Builds the DocumentSnapshot.\n   *\n   * @private\n   * @internal\n   * @returns Returns either a QueryDocumentSnapshot (if `fieldsProto` was\n   * provided) or a DocumentSnapshot.\n   */\n\n\n  _createClass(DocumentSnapshotBuilder, [{\n    key: \"build\",\n    value: function build() {\n      assert(this.fieldsProto !== undefined === (this.createTime !== undefined), 'Create time should be set iff document exists.');\n      assert(this.fieldsProto !== undefined === (this.updateTime !== undefined), 'Update time should be set iff document exists.');\n      return this.fieldsProto ? new QueryDocumentSnapshot(this.ref, this.fieldsProto, this.readTime, this.createTime, this.updateTime) : new DocumentSnapshot(this.ref, undefined, this.readTime);\n    }\n  }]);\n\n  return DocumentSnapshotBuilder;\n}();\n\nexports.DocumentSnapshotBuilder = DocumentSnapshotBuilder;\n/**\n * A DocumentSnapshot is an immutable representation for a document in a\n * Firestore database. The data can be extracted with\n * [data()]{@link DocumentSnapshot#data} or\n * [get(fieldPath)]{@link DocumentSnapshot#get} to get a\n * specific field.\n *\n * <p>For a DocumentSnapshot that points to a non-existing document, any data\n * access will return 'undefined'. You can use the\n * [exists]{@link DocumentSnapshot#exists} property to explicitly verify a\n * document's existence.\n *\n * @class DocumentSnapshot\n */\n\nvar DocumentSnapshot = /*#__PURE__*/function () {\n  /**\n   * @hideconstructor\n   *\n   * @param ref The reference to the document.\n   * @param _fieldsProto The fields of the Firestore `Document` Protobuf backing\n   * this document (or undefined if the document does not exist).\n   * @param readTime The time when this snapshot was read  (or undefined if\n   * the document exists only locally).\n   * @param createTime The time when the document was created (or undefined if\n   * the document does not exist).\n   * @param updateTime The time when the document was last updated (or undefined\n   * if the document does not exist).\n   */\n  function DocumentSnapshot(ref, _fieldsProto, readTime, createTime, updateTime) {\n    _classCallCheck(this, DocumentSnapshot);\n\n    this._fieldsProto = _fieldsProto;\n    this._ref = ref;\n    this._serializer = ref.firestore._serializer;\n    this._readTime = readTime;\n    this._createTime = createTime;\n    this._updateTime = updateTime;\n  }\n  /**\n   * Creates a DocumentSnapshot from an object.\n   *\n   * @private\n   * @internal\n   * @param ref The reference to the document.\n   * @param obj The object to store in the DocumentSnapshot.\n   * @return The created DocumentSnapshot.\n   */\n\n\n  _createClass(DocumentSnapshot, [{\n    key: \"data\",\n\n    /**\n     * Retrieves all fields in the document as an object. Returns 'undefined' if\n     * the document doesn't exist.\n     *\n     * @returns {T|undefined} An object containing all fields in the document or\n     * 'undefined' if the document doesn't exist.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   let data = documentSnapshot.data();\n     *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\n     * });\n     */\n    value: function data() {\n      var fields = this._fieldsProto;\n\n      if (fields === undefined) {\n        return undefined;\n      } // We only want to use the converter and create a new QueryDocumentSnapshot\n      // if a converter has been provided.\n\n\n      if (this.ref._converter !== types_1.defaultConverter()) {\n        var untypedReference = new reference_1.DocumentReference(this.ref.firestore, this.ref._path);\n        return this.ref._converter.fromFirestore(new QueryDocumentSnapshot(untypedReference, this._fieldsProto, this.readTime, this.createTime, this.updateTime));\n      } else {\n        var obj = {};\n\n        for (var _i = 0, _Object$keys = Object.keys(fields); _i < _Object$keys.length; _i++) {\n          var prop = _Object$keys[_i];\n          obj[prop] = this._serializer.decodeValue(fields[prop]);\n        }\n\n        return obj;\n      }\n    }\n    /**\n     * Retrieves the field specified by `field`.\n     *\n     * @param {string|FieldPath} field The field path\n     * (e.g. 'foo' or 'foo.bar') to a specific field.\n     * @returns {*} The data at the specified field location or undefined if no\n     * such field exists.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.set({ a: { b: 'c' }}).then(() => {\n     *   return documentRef.get();\n     * }).then(documentSnapshot => {\n     *   let field = documentSnapshot.get('a.b');\n     *   console.log(`Retrieved field value: ${field}`);\n     * });\n     */\n    // We deliberately use `any` in the external API to not impose type-checking\n    // on end users.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  }, {\n    key: \"get\",\n    value: function get(field) {\n      path_1.validateFieldPath('field', field);\n      var protoField = this.protoField(field);\n\n      if (protoField === undefined) {\n        return undefined;\n      }\n\n      return this._serializer.decodeValue(protoField);\n    }\n    /**\n     * Retrieves the field specified by 'fieldPath' in its Protobuf JS\n     * representation.\n     *\n     * @private\n     * @internal\n     * @param field The path (e.g. 'foo' or 'foo.bar') to a specific field.\n     * @returns The Protobuf-encoded data at the specified field location or\n     * undefined if no such field exists.\n     */\n\n  }, {\n    key: \"protoField\",\n    value: function protoField(field) {\n      var fields = this._fieldsProto;\n\n      if (fields === undefined) {\n        return undefined;\n      }\n\n      var components = path_1.FieldPath.fromArgument(field).toArray();\n\n      while (components.length > 1) {\n        fields = fields[components.shift()];\n\n        if (!fields || !fields.mapValue) {\n          return undefined;\n        }\n\n        fields = fields.mapValue.fields;\n      }\n\n      return fields[components[0]];\n    }\n    /**\n     * Convert a document snapshot to the Firestore 'Write' proto.\n     *\n     * @private\n     * @internal\n     */\n\n  }, {\n    key: \"toWriteProto\",\n    value: function toWriteProto() {\n      return {\n        update: {\n          name: this._ref.formattedName,\n          fields: this._fieldsProto\n        }\n      };\n    }\n    /**\n     * Convert a document snapshot to the Firestore 'Document' proto.\n     *\n     * @private\n     * @internal\n     */\n\n  }, {\n    key: \"toDocumentProto\",\n    value: function toDocumentProto() {\n      var _a, _b;\n\n      return {\n        name: this._ref.formattedName,\n        createTime: (_a = this.createTime) === null || _a === void 0 ? void 0 : _a.toProto().timestampValue,\n        updateTime: (_b = this.updateTime) === null || _b === void 0 ? void 0 : _b.toProto().timestampValue,\n        fields: this._fieldsProto\n      };\n    }\n    /**\n     * Returns true if the document's data and path in this `DocumentSnapshot` is\n     * equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `DocumentSnapshot` is equal to the provided\n     * value.\n     */\n\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(other) {\n      // Since the read time is different on every document read, we explicitly\n      // ignore all document metadata in this comparison.\n      return this === other || other instanceof DocumentSnapshot && this._ref.isEqual(other._ref) && deepEqual(this._fieldsProto, other._fieldsProto);\n    }\n  }, {\n    key: \"exists\",\n\n    /**\n     * True if the document exists.\n     *\n     * @type {boolean}\n     * @name DocumentSnapshot#exists\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then((documentSnapshot) => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(`Data: ${JSON.stringify(documentSnapshot.data())}`);\n     *   }\n     * });\n     */\n    get: function get() {\n      return this._fieldsProto !== undefined;\n    }\n    /**\n     * A [DocumentReference]{@link DocumentReference} for the document\n     * stored in this snapshot.\n     *\n     * @type {DocumentReference}\n     * @name DocumentSnapshot#ref\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then((documentSnapshot) => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(`Found document at '${documentSnapshot.ref.path}'`);\n     *   }\n     * });\n     */\n\n  }, {\n    key: \"ref\",\n    get: function get() {\n      return this._ref;\n    }\n    /**\n     * The ID of the document for which this DocumentSnapshot contains data.\n     *\n     * @type {string}\n     * @name DocumentSnapshot#id\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then((documentSnapshot) => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(`Document found with name '${documentSnapshot.id}'`);\n     *   }\n     * });\n     */\n\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._ref.id;\n    }\n    /**\n     * The time the document was created. Undefined for documents that don't\n     * exist.\n     *\n     * @type {Timestamp|undefined}\n     * @name DocumentSnapshot#createTime\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   if (documentSnapshot.exists) {\n     *     let createTime = documentSnapshot.createTime;\n     *     console.log(`Document created at '${createTime.toDate()}'`);\n     *   }\n     * });\n     */\n\n  }, {\n    key: \"createTime\",\n    get: function get() {\n      return this._createTime;\n    }\n    /**\n     * The time the document was last updated (at the time the snapshot was\n     * generated). Undefined for documents that don't exist.\n     *\n     * @type {Timestamp|undefined}\n     * @name DocumentSnapshot#updateTime\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   if (documentSnapshot.exists) {\n     *     let updateTime = documentSnapshot.updateTime;\n     *     console.log(`Document updated at '${updateTime.toDate()}'`);\n     *   }\n     * });\n     */\n\n  }, {\n    key: \"updateTime\",\n    get: function get() {\n      return this._updateTime;\n    }\n    /**\n     * The time this snapshot was read.\n     *\n     * @type {Timestamp}\n     * @name DocumentSnapshot#readTime\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   let readTime = documentSnapshot.readTime;\n     *   console.log(`Document read at '${readTime.toDate()}'`);\n     * });\n     */\n\n  }, {\n    key: \"readTime\",\n    get: function get() {\n      if (this._readTime === undefined) {\n        throw new Error(\"Called 'readTime' on a local document\");\n      }\n\n      return this._readTime;\n    }\n  }], [{\n    key: \"fromObject\",\n    value: function fromObject(ref, obj) {\n      var serializer = ref.firestore._serializer;\n      return new DocumentSnapshot(ref, serializer.encodeFields(obj));\n    }\n    /**\n     * Creates a DocumentSnapshot from an UpdateMap.\n     *\n     * This methods expands the top-level field paths in a JavaScript map and\n     * turns { foo.bar : foobar } into { foo { bar : foobar }}\n     *\n     * @private\n     * @internal\n     * @param ref The reference to the document.\n     * @param data The field/value map to expand.\n     * @return The created DocumentSnapshot.\n     */\n\n  }, {\n    key: \"fromUpdateMap\",\n    value: function fromUpdateMap(ref, data) {\n      var serializer = ref.firestore._serializer;\n      /**\n       * Merges 'value' at the field path specified by the path array into\n       * 'target'.\n       */\n\n      function merge(target, value, path, pos) {\n        var key = path[pos];\n        var isLast = pos === path.length - 1;\n\n        if (target[key] === undefined) {\n          if (isLast) {\n            if (value instanceof field_value_1.FieldTransform) {\n              // If there is already data at this path, we need to retain it.\n              // Otherwise, we don't include it in the DocumentSnapshot.\n              return !util_1.isEmpty(target) ? target : null;\n            } // The merge is done.\n\n\n            var leafNode = serializer.encodeValue(value);\n\n            if (leafNode) {\n              target[key] = leafNode;\n            }\n\n            return target;\n          } else {\n            // We need to expand the target object.\n            var childNode = {\n              mapValue: {\n                fields: {}\n              }\n            };\n            var nestedValue = merge(childNode.mapValue.fields, value, path, pos + 1);\n\n            if (nestedValue) {\n              childNode.mapValue.fields = nestedValue;\n              target[key] = childNode;\n              return target;\n            } else {\n              return !util_1.isEmpty(target) ? target : null;\n            }\n          }\n        } else {\n          assert(!isLast, \"Can't merge current value into a nested object\");\n          target[key].mapValue.fields = merge(target[key].mapValue.fields, value, path, pos + 1);\n          return target;\n        }\n      }\n\n      var res = {};\n\n      var _iterator = _createForOfIteratorHelper(data),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              key = _step$value[0],\n              value = _step$value[1];\n\n          var path = key.toArray();\n          merge(res, value, path, 0);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return new DocumentSnapshot(ref, res);\n    }\n  }]);\n\n  return DocumentSnapshot;\n}();\n\nexports.DocumentSnapshot = DocumentSnapshot;\n/**\n * A QueryDocumentSnapshot contains data read from a document in your\n * Firestore database as part of a query. The document is guaranteed to exist\n * and its data can be extracted with [data()]{@link QueryDocumentSnapshot#data}\n * or [get()]{@link DocumentSnapshot#get} to get a specific field.\n *\n * A QueryDocumentSnapshot offers the same API surface as a\n * {@link DocumentSnapshot}. Since query results contain only existing\n * documents, the [exists]{@link DocumentSnapshot#exists} property will\n * always be true and [data()]{@link QueryDocumentSnapshot#data} will never\n * return 'undefined'.\n *\n * @class QueryDocumentSnapshot\n * @extends DocumentSnapshot\n */\n\nvar QueryDocumentSnapshot = /*#__PURE__*/function (_DocumentSnapshot) {\n  _inherits(QueryDocumentSnapshot, _DocumentSnapshot);\n\n  function QueryDocumentSnapshot() {\n    _classCallCheck(this, QueryDocumentSnapshot);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(QueryDocumentSnapshot).apply(this, arguments));\n  }\n\n  _createClass(QueryDocumentSnapshot, [{\n    key: \"data\",\n\n    /**\n     * Retrieves all fields in the document as an object.\n     *\n     * @override\n     *\n     * @returns {T} An object containing all fields in the document.\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.get().forEach(documentSnapshot => {\n     *   let data = documentSnapshot.data();\n     *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\n     * });\n     */\n    value: function data() {\n      var data = _get(_getPrototypeOf(QueryDocumentSnapshot.prototype), \"data\", this).call(this);\n\n      if (!data) {\n        throw new Error('The data in a QueryDocumentSnapshot should always exist.');\n      }\n\n      return data;\n    }\n  }, {\n    key: \"createTime\",\n\n    /**\n     * The time the document was created.\n     *\n     * @type {Timestamp}\n     * @name QueryDocumentSnapshot#createTime\n     * @readonly\n     * @override\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.get().forEach(snapshot => {\n     *   console.log(`Document created at '${snapshot.createTime.toDate()}'`);\n     * });\n     */\n    get: function get() {\n      return _get(_getPrototypeOf(QueryDocumentSnapshot.prototype), \"createTime\", this);\n    }\n    /**\n     * The time the document was last updated (at the time the snapshot was\n     * generated).\n     *\n     * @type {Timestamp}\n     * @name QueryDocumentSnapshot#updateTime\n     * @readonly\n     * @override\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.get().forEach(snapshot => {\n     *   console.log(`Document updated at '${snapshot.updateTime.toDate()}'`);\n     * });\n     */\n\n  }, {\n    key: \"updateTime\",\n    get: function get() {\n      return _get(_getPrototypeOf(QueryDocumentSnapshot.prototype), \"updateTime\", this);\n    }\n  }]);\n\n  return QueryDocumentSnapshot;\n}(DocumentSnapshot);\n\nexports.QueryDocumentSnapshot = QueryDocumentSnapshot;\n/**\n * A Firestore Document Mask contains the field paths affected by an update.\n *\n * @class\n * @private\n * @internal\n */\n\nvar DocumentMask = /*#__PURE__*/function () {\n  /**\n   * @private\n   * @internal\n   * @hideconstructor\n   *\n   * @param fieldPaths The field paths in this mask.\n   */\n  function DocumentMask(fieldPaths) {\n    _classCallCheck(this, DocumentMask);\n\n    this._sortedPaths = fieldPaths;\n\n    this._sortedPaths.sort(function (a, b) {\n      return a.compareTo(b);\n    });\n  }\n  /**\n   * Creates a document mask with the field paths of a document.\n   *\n   * @private\n   * @internal\n   * @param data A map with fields to modify. Only the keys are used to extract\n   * the document mask.\n   */\n\n\n  _createClass(DocumentMask, [{\n    key: \"removeFields\",\n\n    /**\n     * Removes the field path specified in 'fieldPaths' from this document mask.\n     *\n     * @private\n     * @internal\n     * @param fieldPaths An array of FieldPaths.\n     */\n    value: function removeFields(fieldPaths) {\n      DocumentMask.removeFromSortedArray(this._sortedPaths, fieldPaths);\n    }\n    /**\n     * Returns whether this document mask contains 'fieldPath'.\n     *\n     * @private\n     * @internal\n     * @param fieldPath The field path to test.\n     * @return Whether this document mask contains 'fieldPath'.\n     */\n\n  }, {\n    key: \"contains\",\n    value: function contains(fieldPath) {\n      var _iterator2 = _createForOfIteratorHelper(this._sortedPaths),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var sortedPath = _step2.value;\n          var cmp = sortedPath.compareTo(fieldPath);\n\n          if (cmp === 0) {\n            return true;\n          } else if (cmp > 0) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return false;\n    }\n    /**\n     * Removes all properties from 'data' that are not contained in this document\n     * mask.\n     *\n     * @private\n     * @internal\n     * @param data An object to filter.\n     * @return A shallow copy of the object filtered by this document mask.\n     */\n\n  }, {\n    key: \"applyTo\",\n    value: function applyTo(data) {\n      var _this = this;\n\n      /*!\n       * Applies this DocumentMask to 'data' and computes the list of field paths\n       * that were specified in the mask but are not present in 'data'.\n       */\n      var applyDocumentMask = function applyDocumentMask(data) {\n        var remainingPaths = _this._sortedPaths.slice(0);\n\n        var processObject = function processObject(currentData, currentPath) {\n          var result = null;\n          Object.keys(currentData).forEach(function (key) {\n            var childPath = currentPath ? currentPath.append(key) : new path_1.FieldPath(key);\n\n            if (_this.contains(childPath)) {\n              DocumentMask.removeFromSortedArray(remainingPaths, [childPath]);\n              result = result || {};\n              result[key] = currentData[key];\n            } else if (util_1.isObject(currentData[key])) {\n              var childObject = processObject(currentData[key], childPath);\n\n              if (childObject) {\n                result = result || {};\n                result[key] = childObject;\n              }\n            }\n          });\n          return result;\n        }; // processObject() returns 'null' if the DocumentMask is empty.\n\n\n        var filteredData = processObject(data) || {};\n        return {\n          filteredData: filteredData,\n          remainingPaths: remainingPaths\n        };\n      };\n\n      var result = applyDocumentMask(data);\n\n      if (result.remainingPaths.length !== 0) {\n        throw new Error(\"Input data is missing for field \\\"\".concat(result.remainingPaths[0], \"\\\".\"));\n      }\n\n      return result.filteredData;\n    }\n    /**\n     * Converts a document mask to the Firestore 'DocumentMask' Proto.\n     *\n     * @private\n     * @internal\n     * @returns A Firestore 'DocumentMask' Proto.\n     */\n\n  }, {\n    key: \"toProto\",\n    value: function toProto() {\n      if (this.isEmpty) {\n        return {};\n      }\n\n      var encodedPaths = [];\n\n      var _iterator3 = _createForOfIteratorHelper(this._sortedPaths),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var fieldPath = _step3.value;\n          encodedPaths.push(fieldPath.formattedName);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return {\n        fieldPaths: encodedPaths\n      };\n    }\n  }, {\n    key: \"isEmpty\",\n\n    /**\n     * Returns true if this document mask contains no fields.\n     *\n     * @private\n     * @internal\n     * @return {boolean} Whether this document mask is empty.\n     */\n    get: function get() {\n      return this._sortedPaths.length === 0;\n    }\n    /**\n     * Removes the specified values from a sorted field path array.\n     *\n     * @private\n     * @internal\n     * @param input A sorted array of FieldPaths.\n     * @param values An array of FieldPaths to remove.\n     */\n\n  }], [{\n    key: \"fromUpdateMap\",\n    value: function fromUpdateMap(data) {\n      var fieldPaths = [];\n      data.forEach(function (value, key) {\n        if (!(value instanceof field_value_1.FieldTransform) || value.includeInDocumentMask) {\n          fieldPaths.push(path_1.FieldPath.fromArgument(key));\n        }\n      });\n      return new DocumentMask(fieldPaths);\n    }\n    /**\n     * Creates a document mask from an array of field paths.\n     *\n     * @private\n     * @internal\n     * @param fieldMask A list of field paths.\n     */\n\n  }, {\n    key: \"fromFieldMask\",\n    value: function fromFieldMask(fieldMask) {\n      var fieldPaths = [];\n\n      var _iterator4 = _createForOfIteratorHelper(fieldMask),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var fieldPath = _step4.value;\n          fieldPaths.push(path_1.FieldPath.fromArgument(fieldPath));\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return new DocumentMask(fieldPaths);\n    }\n    /**\n     * Creates a document mask with the field names of a document.\n     *\n     * @private\n     * @internal\n     * @param data An object with fields to modify. Only the keys are used to\n     * extract the document mask.\n     */\n\n  }, {\n    key: \"fromObject\",\n    value: function fromObject(data) {\n      var fieldPaths = [];\n\n      function extractFieldPaths(currentData, currentPath) {\n        var isEmpty = true;\n\n        for (var _i2 = 0, _Object$keys2 = Object.keys(currentData); _i2 < _Object$keys2.length; _i2++) {\n          var key = _Object$keys2[_i2];\n          isEmpty = false; // We don't split on dots since fromObject is called with\n          // DocumentData.\n\n          var childSegment = new path_1.FieldPath(key);\n          var childPath = currentPath ? currentPath.append(childSegment) : childSegment;\n          var value = currentData[key];\n\n          if (value instanceof field_value_1.FieldTransform) {\n            if (value.includeInDocumentMask) {\n              fieldPaths.push(childPath);\n            }\n          } else if (util_1.isPlainObject(value)) {\n            extractFieldPaths(value, childPath);\n          } else if (value !== undefined) {\n            // If the value is undefined it can never participate in the document\n            // mask. With `ignoreUndefinedProperties` set to false,\n            // `validateDocumentData` will reject an undefined value before even\n            // computing the document mask.\n            fieldPaths.push(childPath);\n          }\n        } // Add a field path for an explicitly updated empty map.\n\n\n        if (currentPath && isEmpty) {\n          fieldPaths.push(currentPath);\n        }\n      }\n\n      extractFieldPaths(data);\n      return new DocumentMask(fieldPaths);\n    }\n  }, {\n    key: \"removeFromSortedArray\",\n    value: function removeFromSortedArray(input, values) {\n      for (var i = 0; i < input.length;) {\n        var removed = false;\n\n        var _iterator5 = _createForOfIteratorHelper(values),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var fieldPath = _step5.value;\n\n            if (input[i].isEqual(fieldPath)) {\n              input.splice(i, 1);\n              removed = true;\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n\n        if (!removed) {\n          ++i;\n        }\n      }\n    }\n  }]);\n\n  return DocumentMask;\n}();\n\nexports.DocumentMask = DocumentMask;\n/**\n * A Firestore Document Transform.\n *\n * A DocumentTransform contains pending server-side transforms and their\n * corresponding field paths.\n *\n * @private\n * @internal\n * @class\n */\n\nvar DocumentTransform = /*#__PURE__*/function () {\n  /**\n   * @private\n   * @internal\n   * @hideconstructor\n   *\n   * @param ref The DocumentReference for this transform.\n   * @param transforms A Map of FieldPaths to FieldTransforms.\n   */\n  function DocumentTransform(ref, transforms) {\n    _classCallCheck(this, DocumentTransform);\n\n    this.ref = ref;\n    this.transforms = transforms;\n  }\n  /**\n   * Generates a DocumentTransform from a JavaScript object.\n   *\n   * @private\n   * @internal\n   * @param ref The `DocumentReference` to use for the DocumentTransform.\n   * @param obj The object to extract the transformations from.\n   * @returns The Document Transform.\n   */\n\n\n  _createClass(DocumentTransform, [{\n    key: \"validate\",\n\n    /**\n     * Validates the user provided field values in this document transform.\n     * @private\n     * @internal\n     */\n    value: function validate() {\n      var allowUndefined = !!this.ref.firestore._settings.ignoreUndefinedProperties;\n      this.transforms.forEach(function (transform) {\n        return transform.validate(allowUndefined);\n      });\n    }\n    /**\n     * Converts a document transform to the Firestore 'FieldTransform' Proto.\n     *\n     * @private\n     * @internal\n     * @param serializer The Firestore serializer\n     * @returns A list of Firestore 'FieldTransform' Protos\n     */\n\n  }, {\n    key: \"toProto\",\n    value: function toProto(serializer) {\n      return Array.from(this.transforms, function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            path = _ref2[0],\n            transform = _ref2[1];\n\n        return transform.toProto(serializer, path);\n      });\n    }\n  }, {\n    key: \"isEmpty\",\n\n    /**\n     * Whether this DocumentTransform contains any actionable transformations.\n     *\n     * @private\n     * @internal\n     */\n    get: function get() {\n      return this.transforms.size === 0;\n    }\n    /**\n     * Returns the array of fields in this DocumentTransform.\n     *\n     * @private\n     * @internal\n     */\n\n  }, {\n    key: \"fields\",\n    get: function get() {\n      return Array.from(this.transforms.keys());\n    }\n  }], [{\n    key: \"fromObject\",\n    value: function fromObject(ref, obj) {\n      var updateMap = new Map();\n\n      for (var _i3 = 0, _Object$keys3 = Object.keys(obj); _i3 < _Object$keys3.length; _i3++) {\n        var prop = _Object$keys3[_i3];\n        updateMap.set(new path_1.FieldPath(prop), obj[prop]);\n      }\n\n      return DocumentTransform.fromUpdateMap(ref, updateMap);\n    }\n    /**\n     * Generates a DocumentTransform from an Update Map.\n     *\n     * @private\n     * @internal\n     * @param ref The `DocumentReference` to use for the DocumentTransform.\n     * @param data The update data to extract the transformations from.\n     * @returns The Document Transform.\n     */\n\n  }, {\n    key: \"fromUpdateMap\",\n    value: function fromUpdateMap(ref, data) {\n      var transforms = new Map();\n\n      function encode_(val, path, allowTransforms) {\n        if (val instanceof field_value_1.FieldTransform && val.includeInDocumentTransform) {\n          if (allowTransforms) {\n            transforms.set(path, val);\n          } else {\n            throw new Error(\"\".concat(val.methodName, \"() is not supported inside of array values.\"));\n          }\n        } else if (Array.isArray(val)) {\n          for (var i = 0; i < val.length; ++i) {\n            // We need to verify that no array value contains a document transform\n            encode_(val[i], path.append(String(i)), false);\n          }\n        } else if (util_1.isPlainObject(val)) {\n          for (var _i4 = 0, _Object$keys4 = Object.keys(val); _i4 < _Object$keys4.length; _i4++) {\n            var prop = _Object$keys4[_i4];\n            encode_(val[prop], path.append(new path_1.FieldPath(prop)), allowTransforms);\n          }\n        }\n      }\n\n      data.forEach(function (value, key) {\n        encode_(value, path_1.FieldPath.fromArgument(key), true);\n      });\n      return new DocumentTransform(ref, transforms);\n    }\n  }]);\n\n  return DocumentTransform;\n}();\n\nexports.DocumentTransform = DocumentTransform;\n/**\n * A Firestore Precondition encapsulates options for database writes.\n *\n * @private\n * @internal\n * @class\n */\n\nvar Precondition = /*#__PURE__*/function () {\n  /**\n   * @private\n   * @internal\n   * @hideconstructor\n   *\n   * @param options.exists - Whether the referenced document should exist in\n   * Firestore,\n   * @param options.lastUpdateTime - The last update time of the referenced\n   * document in Firestore.\n   * @param options\n   */\n  function Precondition(options) {\n    _classCallCheck(this, Precondition);\n\n    if (options !== undefined) {\n      this._exists = options.exists;\n      this._lastUpdateTime = options.lastUpdateTime;\n    }\n  }\n  /**\n   * Generates the Protobuf `Preconditon` object for this precondition.\n   *\n   * @private\n   * @internal\n   * @returns The `Preconditon` Protobuf object or 'null' if there are no\n   * preconditions.\n   */\n\n\n  _createClass(Precondition, [{\n    key: \"toProto\",\n    value: function toProto() {\n      if (this.isEmpty) {\n        return null;\n      }\n\n      var proto = {};\n\n      if (this._lastUpdateTime !== undefined) {\n        proto.updateTime = this._lastUpdateTime.toProto().timestampValue;\n      } else {\n        proto.exists = this._exists;\n      }\n\n      return proto;\n    }\n    /**\n     * Whether this DocumentTransform contains any enforcement.\n     *\n     * @private\n     * @internal\n     */\n\n  }, {\n    key: \"isEmpty\",\n    get: function get() {\n      return this._exists === undefined && !this._lastUpdateTime;\n    }\n  }]);\n\n  return Precondition;\n}();\n\nexports.Precondition = Precondition;","map":null,"metadata":{},"sourceType":"script"}