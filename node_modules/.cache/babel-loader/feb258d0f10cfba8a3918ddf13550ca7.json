{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _toConsumableArray = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar document_1 = require(\"./document\");\n\nvar logger_1 = require(\"./logger\");\n\nvar path_1 = require(\"./path\");\n\nvar reference_1 = require(\"./reference\");\n\nvar serializer_1 = require(\"./serializer\");\n\nvar timestamp_1 = require(\"./timestamp\");\n\nvar util_1 = require(\"./util\");\n\nvar validate_1 = require(\"./validate\");\n/**\n * A WriteResult wraps the write time set by the Firestore servers on sets(),\n * updates(), and creates().\n *\n * @class WriteResult\n */\n\n\nvar WriteResult = /*#__PURE__*/function () {\n  /**\n   * @hideconstructor\n   *\n   * @param _writeTime The time of the corresponding document write.\n   */\n  function WriteResult(_writeTime) {\n    _classCallCheck(this, WriteResult);\n\n    this._writeTime = _writeTime;\n  }\n  /**\n   * The write time as set by the Firestore servers.\n   *\n   * @type {Timestamp}\n   * @name WriteResult#writeTime\n   * @readonly\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.set({foo: 'bar'}).then(writeResult => {\n   *   console.log(`Document written at: ${writeResult.writeTime.toDate()}`);\n   * });\n   */\n\n\n  _createClass(WriteResult, [{\n    key: \"isEqual\",\n\n    /**\n     * Returns true if this `WriteResult` is equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return true if this `WriteResult` is equal to the provided value.\n     */\n    value: function isEqual(other) {\n      return this === other || other instanceof WriteResult && this._writeTime.isEqual(other._writeTime);\n    }\n  }, {\n    key: \"writeTime\",\n    get: function get() {\n      return this._writeTime;\n    }\n  }]);\n\n  return WriteResult;\n}();\n\nexports.WriteResult = WriteResult;\n/**\n * A Firestore WriteBatch that can be used to atomically commit multiple write\n * operations at once.\n *\n * @class WriteBatch\n */\n\nvar WriteBatch = /*#__PURE__*/function () {\n  /**\n   * @hideconstructor\n   */\n  function WriteBatch(firestore) {\n    _classCallCheck(this, WriteBatch);\n\n    /**\n     * An array of document paths and the corresponding write operations that are\n     * executed as part of the commit. The resulting `api.IWrite` will be sent to\n     * the backend.\n     *\n     * @private\n     * @internal\n     */\n    this._ops = [];\n    this._committed = false;\n    this._firestore = firestore;\n    this._serializer = new serializer_1.Serializer(firestore);\n    this._allowUndefined = !!firestore._settings.ignoreUndefinedProperties;\n  }\n  /**\n   * The number of writes in this batch.\n   */\n\n\n  _createClass(WriteBatch, [{\n    key: \"verifyNotCommitted\",\n\n    /**\n     * Throws an error if this batch has already been committed.\n     *\n     * @private\n     * @internal\n     */\n    value: function verifyNotCommitted() {\n      if (this._committed) {\n        throw new Error('Cannot modify a WriteBatch that has been committed.');\n      }\n    }\n    /**\n     * Create a document with the provided object values. This will fail the batch\n     * if a document exists at its location.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * created.\n     * @param {T} data The object to serialize as the document.\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n     * method calls.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * writeBatch.create(documentRef, {foo: 'bar'});\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n\n  }, {\n    key: \"create\",\n    value: function create(documentRef, data) {\n      var _this = this;\n\n      var ref = reference_1.validateDocumentReference('documentRef', documentRef);\n\n      var firestoreData = ref._converter.toFirestore(data);\n\n      validateDocumentData('data', firestoreData,\n      /* allowDeletes= */\n      false, this._allowUndefined);\n      this.verifyNotCommitted();\n      var transform = document_1.DocumentTransform.fromObject(ref, firestoreData);\n      transform.validate();\n      var precondition = new document_1.Precondition({\n        exists: false\n      });\n\n      var op = function op() {\n        var document = document_1.DocumentSnapshot.fromObject(ref, firestoreData);\n        var write = document.toWriteProto();\n\n        if (!transform.isEmpty) {\n          write.updateTransforms = transform.toProto(_this._serializer);\n        }\n\n        write.currentDocument = precondition.toProto();\n        return write;\n      };\n\n      this._ops.push({\n        docPath: documentRef.path,\n        op: op\n      });\n\n      return this;\n    }\n    /**\n     * Deletes a document from the database.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * deleted.\n     * @param {Precondition=} precondition A precondition to enforce for this\n     * delete.\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n     * document was last updated at lastUpdateTime. Fails the batch if the\n     * document doesn't exist or was last updated at a different time.\n     * @param {boolean= } precondition.exists If set to true, enforces that the target\n     * document must or must not exist.\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n     * method calls.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * writeBatch.delete(documentRef);\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(documentRef, precondition) {\n      var ref = reference_1.validateDocumentReference('documentRef', documentRef);\n      validateDeletePrecondition('precondition', precondition, {\n        optional: true\n      });\n      this.verifyNotCommitted();\n      var conditions = new document_1.Precondition(precondition);\n\n      var op = function op() {\n        var write = {\n          delete: ref.formattedName\n        };\n\n        if (!conditions.isEmpty) {\n          write.currentDocument = conditions.toProto();\n        }\n\n        return write;\n      };\n\n      this._ops.push({\n        docPath: documentRef.path,\n        op: op\n      });\n\n      return this;\n    }\n    /**\n     * Write to the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document does not\n     * exist yet, it will be created. If you pass [SetOptions]{@link SetOptions},\n     * the provided data can be merged into the existing document.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * set.\n     * @param {T|Partial<T>} data The object to serialize as the document.\n     * @param {SetOptions=} options An object to configure the set behavior.\n     * @param {boolean=} options.merge - If true, set() merges the values\n     * specified in its data argument. Fields omitted from this set() call\n     * remain untouched.\n     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided,\n     * set() only replaces the specified field paths. Any field path that is not\n     * specified is ignored and remains untouched.\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n     * method calls.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * writeBatch.set(documentRef, {foo: 'bar'});\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(documentRef, data, options) {\n      var _this2 = this;\n\n      validateSetOptions('options', options, {\n        optional: true\n      });\n      var mergeLeaves = options && options.merge === true;\n      var mergePaths = options && options.mergeFields;\n      var ref = reference_1.validateDocumentReference('documentRef', documentRef);\n      var firestoreData;\n\n      if (mergeLeaves || mergePaths) {\n        // Cast to any in order to satisfy the union type constraint on\n        // toFirestore().\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        firestoreData = ref._converter.toFirestore(data, options);\n      } else {\n        firestoreData = ref._converter.toFirestore(data);\n      }\n\n      validateDocumentData('data', firestoreData,\n      /* allowDeletes= */\n      !!(mergePaths || mergeLeaves), this._allowUndefined);\n      this.verifyNotCommitted();\n      var documentMask;\n\n      if (mergePaths) {\n        documentMask = document_1.DocumentMask.fromFieldMask(options.mergeFields);\n        firestoreData = documentMask.applyTo(firestoreData);\n      }\n\n      var transform = document_1.DocumentTransform.fromObject(documentRef, firestoreData);\n      transform.validate();\n\n      var op = function op() {\n        var document = document_1.DocumentSnapshot.fromObject(documentRef, firestoreData);\n\n        if (mergePaths) {\n          documentMask.removeFields(transform.fields);\n        } else if (mergeLeaves) {\n          documentMask = document_1.DocumentMask.fromObject(firestoreData);\n        }\n\n        var write = document.toWriteProto();\n\n        if (!transform.isEmpty) {\n          write.updateTransforms = transform.toProto(_this2._serializer);\n        }\n\n        if (mergePaths || mergeLeaves) {\n          write.updateMask = documentMask.toProto();\n        }\n\n        return write;\n      };\n\n      this._ops.push({\n        docPath: documentRef.path,\n        op: op\n      });\n\n      return this;\n    }\n    /**\n     * Update fields of the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document\n     * doesn't yet exist, the update fails and the entire batch will be rejected.\n     *\n     * The update() method accepts either an object with field paths encoded as\n     * keys and field values encoded as values, or a variable number of arguments\n     * that alternate between field paths and field values. Nested fields can be\n     * updated by providing dot-separated field path strings or by providing\n     * FieldPath objects.\n     *\n     * A Precondition restricting this update can be specified as the last\n     * argument.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * updated.\n     * @param {UpdateData|string|FieldPath} dataOrField An object\n     * containing the fields and values with which to update the document\n     * or the path of the first field to update.\n     * @param {\n     * ...(Precondition|*|string|FieldPath)} preconditionOrValues -\n     * An alternating list of field paths and values to update or a Precondition\n     * to restrict this update.\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n     * method calls.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * writeBatch.update(documentRef, {foo: 'bar'});\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(documentRef, dataOrField) {\n      var _this3 = this;\n\n      for (var _len = arguments.length, preconditionOrValues = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        preconditionOrValues[_key - 2] = arguments[_key];\n      }\n\n      // eslint-disable-next-line prefer-rest-params\n      validate_1.validateMinNumberOfArguments('WriteBatch.update', arguments, 2);\n      reference_1.validateDocumentReference('documentRef', documentRef);\n      this.verifyNotCommitted();\n      var updateMap = new Map();\n      var precondition = new document_1.Precondition({\n        exists: true\n      });\n      var argumentError = 'Update() requires either a single JavaScript ' + 'object or an alternating list of field/value pairs that can be ' + 'followed by an optional precondition.';\n      var usesVarargs = typeof dataOrField === 'string' || dataOrField instanceof path_1.FieldPath;\n\n      if (usesVarargs) {\n        var argumentOffset = 1; // Respect 'documentRef' in the error message\n\n        var fieldOrValues = [dataOrField].concat(preconditionOrValues);\n\n        try {\n          for (var i = 0; i < fieldOrValues.length; i += 2) {\n            if (i === fieldOrValues.length - 1) {\n              var maybePrecondition = fieldOrValues[i];\n              validateUpdatePrecondition(i + argumentOffset, maybePrecondition);\n              precondition = new document_1.Precondition(maybePrecondition);\n            } else {\n              var maybeFieldPath = fieldOrValues[i];\n              path_1.validateFieldPath(i + argumentOffset, maybeFieldPath); // Unlike the `validateMinNumberOfArguments` invocation above, this\n              // validation can be triggered both from `WriteBatch.update()` and\n              // `DocumentReference.update()`. Hence, we don't use the fully\n              // qualified API name in the error message.\n\n              validate_1.validateMinNumberOfArguments('update', fieldOrValues, i + 1);\n              var fieldPath = path_1.FieldPath.fromArgument(maybeFieldPath);\n              validateFieldValue(i + argumentOffset, fieldOrValues[i + 1], this._allowUndefined, fieldPath);\n              updateMap.set(fieldPath, fieldOrValues[i + 1]);\n            }\n          }\n        } catch (err) {\n          logger_1.logger('WriteBatch.update', null, 'Varargs validation failed:', err); // We catch the validation error here and re-throw to provide a better\n          // error message.\n\n          throw new Error(\"\".concat(argumentError, \" \").concat(err.message));\n        }\n      } else {\n        try {\n          validateUpdateMap('dataOrField', dataOrField, this._allowUndefined); // eslint-disable-next-line prefer-rest-params\n\n          validate_1.validateMaxNumberOfArguments('update', arguments, 3);\n          var data = dataOrField;\n          Object.entries(data).forEach(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n                key = _ref2[0],\n                value = _ref2[1];\n\n            // Skip `undefined` values (can be hit if `ignoreUndefinedProperties`\n            // is set)\n            if (value !== undefined) {\n              path_1.validateFieldPath(key, key);\n              updateMap.set(path_1.FieldPath.fromArgument(key), value);\n            }\n          });\n\n          if (preconditionOrValues.length > 0) {\n            validateUpdatePrecondition('preconditionOrValues', preconditionOrValues[0]);\n            precondition = new document_1.Precondition(preconditionOrValues[0]);\n          }\n        } catch (err) {\n          logger_1.logger('WriteBatch.update', null, 'Non-varargs validation failed:', err); // We catch the validation error here and prefix the error with a custom\n          // message to describe the usage of update() better.\n\n          throw new Error(\"\".concat(argumentError, \" \").concat(err.message));\n        }\n      }\n\n      validateNoConflictingFields('dataOrField', updateMap);\n      var transform = document_1.DocumentTransform.fromUpdateMap(documentRef, updateMap);\n      transform.validate();\n      var documentMask = document_1.DocumentMask.fromUpdateMap(updateMap);\n\n      var op = function op() {\n        var document = document_1.DocumentSnapshot.fromUpdateMap(documentRef, updateMap);\n        var write = document.toWriteProto();\n        write.updateMask = documentMask.toProto();\n\n        if (!transform.isEmpty) {\n          write.updateTransforms = transform.toProto(_this3._serializer);\n        }\n\n        write.currentDocument = precondition.toProto();\n        return write;\n      };\n\n      this._ops.push({\n        docPath: documentRef.path,\n        op: op\n      });\n\n      return this;\n    }\n    /**\n     * Atomically commits all pending operations to the database and verifies all\n     * preconditions. Fails the entire write if any precondition is not met.\n     *\n     * @returns {Promise.<Array.<WriteResult>>} A Promise that resolves\n     * when this batch completes.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * writeBatch.set(documentRef, {foo: 'bar'});\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      // Capture the error stack to preserve stack tracing across async calls.\n      var stack = Error().stack; // Commits should also be retried when they fail with status code ABORTED.\n\n      var retryCodes = [10\n      /* ABORTED */\n      ].concat(_toConsumableArray(util_1.getRetryCodes('commit')));\n      return this._commit({\n        retryCodes: retryCodes\n      }).then(function (response) {\n        return (response.writeResults || []).map(function (writeResult) {\n          return new WriteResult(timestamp_1.Timestamp.fromProto(writeResult.updateTime || response.commitTime));\n        });\n      }).catch(function (err) {\n        throw util_1.wrapError(err, stack);\n      });\n    }\n    /**\n     * Commit method that takes an optional transaction ID.\n     *\n     * @private\n     * @internal\n     * @param commitOptions Options to use for this commit.\n     * @param commitOptions.transactionId The transaction ID of this commit.\n     * @param commitOptions.requestTag A unique client-assigned identifier for\n     * this request.\n     * @returns  A Promise that resolves when this batch completes.\n     */\n\n  }, {\n    key: \"_commit\",\n    value: function () {\n      var _commit2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(commitOptions) {\n        var _a, tag, request;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // Note: We don't call `verifyNotCommitted()` to allow for retries.\n                this._committed = true;\n                tag = (_a = commitOptions === null || commitOptions === void 0 ? void 0 : commitOptions.requestTag) !== null && _a !== void 0 ? _a : util_1.requestTag();\n                _context.next = 4;\n                return this._firestore.initializeIfNeeded(tag);\n\n              case 4:\n                // Note that the request may not always be of type ICommitRequest. This is\n                // just here to ensure type safety.\n                request = {\n                  database: this._firestore.formattedName,\n                  writes: this._ops.map(function (op) {\n                    return op.op();\n                  })\n                };\n\n                if (commitOptions === null || commitOptions === void 0 ? void 0 : commitOptions.transactionId) {\n                  request.transaction = commitOptions.transactionId;\n                }\n\n                logger_1.logger('WriteBatch.commit', tag, 'Sending %d writes', request.writes.length);\n                return _context.abrupt(\"return\", this._firestore.request((commitOptions === null || commitOptions === void 0 ? void 0 : commitOptions.methodName) || 'commit', request, tag, commitOptions === null || commitOptions === void 0 ? void 0 : commitOptions.retryCodes));\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _commit(_x) {\n        return _commit2.apply(this, arguments);\n      }\n\n      return _commit;\n    }()\n    /**\n     * Resets the WriteBatch and dequeues all pending operations.\n     * @private\n     * @internal\n     */\n\n  }, {\n    key: \"_reset\",\n    value: function _reset() {\n      this._ops.splice(0);\n\n      this._committed = false;\n    }\n  }, {\n    key: \"_opCount\",\n    get: function get() {\n      return this._ops.length;\n    }\n    /**\n     * Checks if this write batch has any pending operations.\n     *\n     * @private\n     * @internal\n     */\n\n  }, {\n    key: \"isEmpty\",\n    get: function get() {\n      return this._ops.length === 0;\n    }\n  }]);\n\n  return WriteBatch;\n}();\n\nexports.WriteBatch = WriteBatch;\n/**\n * Validates the use of 'value' as a Precondition and enforces that 'exists'\n * and 'lastUpdateTime' use valid types.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate\n * @param allowExists Whether to allow the 'exists' preconditions.\n */\n\nfunction validatePrecondition(arg, value, allowExists) {\n  if (typeof value !== 'object' || value === null) {\n    throw new Error('Input is not an object.');\n  }\n\n  var precondition = value;\n  var conditions = 0;\n\n  if (precondition.exists !== undefined) {\n    ++conditions;\n\n    if (!allowExists) {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'precondition'), \" \\\"exists\\\" is not an allowed precondition.\"));\n    }\n\n    if (typeof precondition.exists !== 'boolean') {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'precondition'), \" \\\"exists\\\" is not a boolean.'\"));\n    }\n  }\n\n  if (precondition.lastUpdateTime !== undefined) {\n    ++conditions;\n\n    if (!(precondition.lastUpdateTime instanceof timestamp_1.Timestamp)) {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'precondition'), \" \\\"lastUpdateTime\\\" is not a Firestore Timestamp.\"));\n    }\n  }\n\n  if (conditions > 1) {\n    throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'precondition'), \" Input specifies more than one precondition.\"));\n  }\n}\n/**\n * Validates the use of 'value' as an update Precondition.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate.\n * @param options Optional validation options specifying whether the value can\n * be omitted.\n */\n\n\nfunction validateUpdatePrecondition(arg, value, options) {\n  if (!validate_1.validateOptional(value, options)) {\n    validatePrecondition(arg, value,\n    /* allowExists= */\n    false);\n  }\n}\n/**\n * Validates the use of 'value' as a delete Precondition.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate.\n * @param options Optional validation options specifying whether the value can\n * be omitted.\n */\n\n\nfunction validateDeletePrecondition(arg, value, options) {\n  if (!validate_1.validateOptional(value, options)) {\n    validatePrecondition(arg, value,\n    /* allowExists= */\n    true);\n  }\n}\n/**\n * Validates the use of 'value' as SetOptions and enforces that 'merge' is a\n * boolean.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate.\n * @param options Optional validation options specifying whether the value can\n * be omitted.\n * @throws if the input is not a valid SetOptions object.\n */\n\n\nfunction validateSetOptions(arg, value, options) {\n  if (!validate_1.validateOptional(value, options)) {\n    if (!util_1.isObject(value)) {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'set() options argument'), \" Input is not an object.\"));\n    }\n\n    var setOptions = value;\n\n    if ('merge' in setOptions && typeof setOptions.merge !== 'boolean') {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'set() options argument'), \" \\\"merge\\\" is not a boolean.\"));\n    }\n\n    if ('mergeFields' in setOptions) {\n      if (!Array.isArray(setOptions.mergeFields)) {\n        throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'set() options argument'), \" \\\"mergeFields\\\" is not an array.\"));\n      }\n\n      for (var i = 0; i < setOptions.mergeFields.length; ++i) {\n        try {\n          path_1.validateFieldPath(i, setOptions.mergeFields[i]);\n        } catch (err) {\n          throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'set() options argument'), \" \\\"mergeFields\\\" is not valid: \").concat(err.message));\n        }\n      }\n    }\n\n    if ('merge' in setOptions && 'mergeFields' in setOptions) {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'set() options argument'), \" You cannot specify both \\\"merge\\\" and \\\"mergeFields\\\".\"));\n    }\n  }\n}\n\nexports.validateSetOptions = validateSetOptions;\n/**\n * Validates a JavaScript object for usage as a Firestore document.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param obj JavaScript object to validate.\n * @param allowDeletes Whether to allow FieldValue.delete() sentinels.\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\n * @throws when the object is invalid.\n */\n\nfunction validateDocumentData(arg, obj, allowDeletes, allowUndefined) {\n  if (!util_1.isPlainObject(obj)) {\n    throw new Error(validate_1.customObjectMessage(arg, obj));\n  }\n\n  serializer_1.validateUserInput(arg, obj, 'Firestore document', {\n    allowDeletes: allowDeletes ? 'all' : 'none',\n    allowTransforms: true,\n    allowUndefined: allowUndefined\n  });\n}\n\nexports.validateDocumentData = validateDocumentData;\n/**\n * Validates that a value can be used as field value during an update.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param val The value to verify.\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\n * @param path The path to show in the error message.\n */\n\nfunction validateFieldValue(arg, val, allowUndefined, path) {\n  serializer_1.validateUserInput(arg, val, 'Firestore value', {\n    allowDeletes: 'root',\n    allowTransforms: true,\n    allowUndefined: allowUndefined\n  }, path);\n}\n\nexports.validateFieldValue = validateFieldValue;\n/**\n * Validates that the update data does not contain any ambiguous field\n * definitions (such as 'a.b' and 'a').\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param data An update map with field/value pairs.\n */\n\nfunction validateNoConflictingFields(arg, data) {\n  var fields = [];\n  data.forEach(function (value, key) {\n    fields.push(key);\n  });\n  fields.sort(function (left, right) {\n    return left.compareTo(right);\n  });\n\n  for (var i = 1; i < fields.length; ++i) {\n    if (fields[i - 1].isPrefixOf(fields[i])) {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'update map'), \" Field \\\"\").concat(fields[i - 1], \"\\\" was specified multiple times.\"));\n    }\n  }\n}\n/**\n * Validates that a JavaScript object is a map of field paths to field values.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param obj JavaScript object to validate.\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\n * @throws when the object is invalid.\n */\n\n\nfunction validateUpdateMap(arg, obj, allowUndefined) {\n  if (!util_1.isPlainObject(obj)) {\n    throw new Error(validate_1.customObjectMessage(arg, obj));\n  }\n\n  if (Object.keys(obj).length === 0) {\n    throw new Error('At least one field must be updated.');\n  }\n\n  validateFieldValue(arg, obj, allowUndefined);\n}","map":null,"metadata":{},"sourceType":"script"}