{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.retryable = void 0;\n\nvar status_1 = require(\"../status\");\n\nvar googleError_1 = require(\"../googleError\");\n\nvar timeout_1 = require(\"./timeout\");\n/**\n * Creates a function equivalent to func, but that retries on certain\n * exceptions.\n *\n * @private\n *\n * @param {GRPCCall} func - A function.\n * @param {RetryOptions} retry - Configures the exceptions upon which the\n *   function eshould retry, and the parameters to the exponential backoff retry\n *   algorithm.\n * @param {GRPCCallOtherArgs} otherArgs - the additional arguments to be passed to func.\n * @return {SimpleCallbackFunction} A function that will retry.\n */\n\n\nfunction retryable(func, retry, otherArgs, apiName) {\n  var delayMult = retry.backoffSettings.retryDelayMultiplier;\n  var maxDelay = retry.backoffSettings.maxRetryDelayMillis;\n  var timeoutMult = retry.backoffSettings.rpcTimeoutMultiplier;\n  var maxTimeout = retry.backoffSettings.maxRpcTimeoutMillis;\n  var delay = retry.backoffSettings.initialRetryDelayMillis;\n  var timeout = retry.backoffSettings.initialRpcTimeoutMillis;\n  /**\n   * Equivalent to ``func``, but retries upon transient failure.\n   *\n   * Retrying is done through an exponential backoff algorithm configured\n   * by the options in ``retry``.\n   * @param {RequestType} argument The request object.\n   * @param {APICallback} callback The callback.\n   * @return {GRPCCall}\n   */\n\n  return function (argument, callback) {\n    var canceller;\n    var timeoutId;\n    var now = new Date();\n    var deadline;\n\n    if (retry.backoffSettings.totalTimeoutMillis) {\n      deadline = now.getTime() + retry.backoffSettings.totalTimeoutMillis;\n    }\n\n    var retries = 0;\n    var maxRetries = retry.backoffSettings.maxRetries; // TODO: define A/B testing values for retry behaviors.\n\n    /** Repeat the API call as long as necessary. */\n\n    function repeat() {\n      timeoutId = null;\n\n      if (deadline && now.getTime() >= deadline) {\n        var error = new googleError_1.GoogleError(\"Total timeout of API \".concat(apiName, \" exceeded \").concat(retry.backoffSettings.totalTimeoutMillis, \" milliseconds before any response was received.\"));\n        error.code = status_1.Status.DEADLINE_EXCEEDED;\n        callback(error);\n        return;\n      }\n\n      if (retries && retries >= maxRetries) {\n        var _error = new googleError_1.GoogleError('Exceeded maximum number of retries before any ' + 'response was received');\n\n        _error.code = status_1.Status.DEADLINE_EXCEEDED;\n        callback(_error);\n        return;\n      }\n\n      retries++;\n      var toCall = timeout_1.addTimeoutArg(func, timeout, otherArgs);\n      canceller = toCall(argument, function (err, response, next, rawResponse) {\n        if (!err) {\n          callback(null, response, next, rawResponse);\n          return;\n        }\n\n        canceller = null;\n\n        if (retry.retryCodes.indexOf(err.code) < 0) {\n          err.note = 'Exception occurred in retry method that was ' + 'not classified as transient';\n          callback(err);\n        } else {\n          var toSleep = Math.random() * delay;\n          timeoutId = setTimeout(function () {\n            now = new Date();\n            delay = Math.min(delay * delayMult, maxDelay);\n            var timeoutCal = timeout && timeoutMult ? timeout * timeoutMult : 0;\n            var rpcTimeout = maxTimeout ? maxTimeout : 0;\n            var newDeadline = deadline ? deadline - now.getTime() : 0;\n            timeout = Math.min(timeoutCal, rpcTimeout, newDeadline);\n            repeat();\n          }, toSleep);\n        }\n      });\n    }\n\n    if (maxRetries && deadline) {\n      var error = new googleError_1.GoogleError('Cannot set both totalTimeoutMillis and maxRetries ' + 'in backoffSettings.');\n      error.code = status_1.Status.INVALID_ARGUMENT;\n      callback(error);\n    } else {\n      repeat();\n    }\n\n    return {\n      cancel: function cancel() {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n\n        if (canceller) {\n          canceller.cancel();\n        } else {\n          var _error2 = new googleError_1.GoogleError('cancelled');\n\n          _error2.code = status_1.Status.CANCELLED;\n          callback(_error2);\n        }\n      }\n    };\n  };\n}\n\nexports.retryable = retryable;","map":null,"metadata":{},"sourceType":"script"}