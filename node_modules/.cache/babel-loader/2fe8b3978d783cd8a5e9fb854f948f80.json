{"ast":null,"code":"\"use strict\";\n\nmodule.exports = createRBTree;\nvar RED = 0;\nvar BLACK = 1;\n\nfunction RBNode(color, key, value, left, right, count) {\n  this._color = color;\n  this.key = key;\n  this.value = value;\n  this.left = left;\n  this.right = right;\n  this._count = count;\n}\n\nfunction cloneNode(node) {\n  return new RBNode(node._color, node.key, node.value, node.left, node.right, node._count);\n}\n\nfunction repaint(color, node) {\n  return new RBNode(color, node.key, node.value, node.left, node.right, node._count);\n}\n\nfunction recount(node) {\n  node._count = 1 + (node.left ? node.left._count : 0) + (node.right ? node.right._count : 0);\n}\n\nfunction RedBlackTree(compare, root) {\n  this._compare = compare;\n  this.root = root;\n}\n\nvar proto = RedBlackTree.prototype;\nObject.defineProperty(proto, \"keys\", {\n  get: function get() {\n    var result = [];\n    this.forEach(function (k, v) {\n      result.push(k);\n    });\n    return result;\n  }\n});\nObject.defineProperty(proto, \"values\", {\n  get: function get() {\n    var result = [];\n    this.forEach(function (k, v) {\n      result.push(v);\n    });\n    return result;\n  }\n}); //Returns the number of nodes in the tree\n\nObject.defineProperty(proto, \"length\", {\n  get: function get() {\n    if (this.root) {\n      return this.root._count;\n    }\n\n    return 0;\n  }\n}); //Insert a new item into the tree\n\nproto.insert = function (key, value) {\n  var cmp = this._compare; //Find point to insert new node at\n\n  var n = this.root;\n  var n_stack = [];\n  var d_stack = [];\n\n  while (n) {\n    var d = cmp(key, n.key);\n    n_stack.push(n);\n    d_stack.push(d);\n\n    if (d <= 0) {\n      n = n.left;\n    } else {\n      n = n.right;\n    }\n  } //Rebuild path to leaf node\n\n\n  n_stack.push(new RBNode(RED, key, value, null, null, 1));\n\n  for (var s = n_stack.length - 2; s >= 0; --s) {\n    var n = n_stack[s];\n\n    if (d_stack[s] <= 0) {\n      n_stack[s] = new RBNode(n._color, n.key, n.value, n_stack[s + 1], n.right, n._count + 1);\n    } else {\n      n_stack[s] = new RBNode(n._color, n.key, n.value, n.left, n_stack[s + 1], n._count + 1);\n    }\n  } //Rebalance tree using rotations\n  //console.log(\"start insert\", key, d_stack)\n\n\n  for (var s = n_stack.length - 1; s > 1; --s) {\n    var p = n_stack[s - 1];\n    var n = n_stack[s];\n\n    if (p._color === BLACK || n._color === BLACK) {\n      break;\n    }\n\n    var pp = n_stack[s - 2];\n\n    if (pp.left === p) {\n      if (p.left === n) {\n        var y = pp.right;\n\n        if (y && y._color === RED) {\n          //console.log(\"LLr\")\n          p._color = BLACK;\n          pp.right = repaint(BLACK, y);\n          pp._color = RED;\n          s -= 1;\n        } else {\n          //console.log(\"LLb\")\n          pp._color = RED;\n          pp.left = p.right;\n          p._color = BLACK;\n          p.right = pp;\n          n_stack[s - 2] = p;\n          n_stack[s - 1] = n;\n          recount(pp);\n          recount(p);\n\n          if (s >= 3) {\n            var ppp = n_stack[s - 3];\n\n            if (ppp.left === pp) {\n              ppp.left = p;\n            } else {\n              ppp.right = p;\n            }\n          }\n\n          break;\n        }\n      } else {\n        var y = pp.right;\n\n        if (y && y._color === RED) {\n          //console.log(\"LRr\")\n          p._color = BLACK;\n          pp.right = repaint(BLACK, y);\n          pp._color = RED;\n          s -= 1;\n        } else {\n          //console.log(\"LRb\")\n          p.right = n.left;\n          pp._color = RED;\n          pp.left = n.right;\n          n._color = BLACK;\n          n.left = p;\n          n.right = pp;\n          n_stack[s - 2] = n;\n          n_stack[s - 1] = p;\n          recount(pp);\n          recount(p);\n          recount(n);\n\n          if (s >= 3) {\n            var ppp = n_stack[s - 3];\n\n            if (ppp.left === pp) {\n              ppp.left = n;\n            } else {\n              ppp.right = n;\n            }\n          }\n\n          break;\n        }\n      }\n    } else {\n      if (p.right === n) {\n        var y = pp.left;\n\n        if (y && y._color === RED) {\n          //console.log(\"RRr\", y.key)\n          p._color = BLACK;\n          pp.left = repaint(BLACK, y);\n          pp._color = RED;\n          s -= 1;\n        } else {\n          //console.log(\"RRb\")\n          pp._color = RED;\n          pp.right = p.left;\n          p._color = BLACK;\n          p.left = pp;\n          n_stack[s - 2] = p;\n          n_stack[s - 1] = n;\n          recount(pp);\n          recount(p);\n\n          if (s >= 3) {\n            var ppp = n_stack[s - 3];\n\n            if (ppp.right === pp) {\n              ppp.right = p;\n            } else {\n              ppp.left = p;\n            }\n          }\n\n          break;\n        }\n      } else {\n        var y = pp.left;\n\n        if (y && y._color === RED) {\n          //console.log(\"RLr\")\n          p._color = BLACK;\n          pp.left = repaint(BLACK, y);\n          pp._color = RED;\n          s -= 1;\n        } else {\n          //console.log(\"RLb\")\n          p.left = n.right;\n          pp._color = RED;\n          pp.right = n.left;\n          n._color = BLACK;\n          n.right = p;\n          n.left = pp;\n          n_stack[s - 2] = n;\n          n_stack[s - 1] = p;\n          recount(pp);\n          recount(p);\n          recount(n);\n\n          if (s >= 3) {\n            var ppp = n_stack[s - 3];\n\n            if (ppp.right === pp) {\n              ppp.right = n;\n            } else {\n              ppp.left = n;\n            }\n          }\n\n          break;\n        }\n      }\n    }\n  } //Return new tree\n\n\n  n_stack[0]._color = BLACK;\n  return new RedBlackTree(cmp, n_stack[0]);\n}; //Visit all nodes inorder\n\n\nfunction doVisitFull(visit, node) {\n  if (node.left) {\n    var v = doVisitFull(visit, node.left);\n\n    if (v) {\n      return v;\n    }\n  }\n\n  var v = visit(node.key, node.value);\n\n  if (v) {\n    return v;\n  }\n\n  if (node.right) {\n    return doVisitFull(visit, node.right);\n  }\n} //Visit half nodes in order\n\n\nfunction doVisitHalf(lo, compare, visit, node) {\n  var l = compare(lo, node.key);\n\n  if (l <= 0) {\n    if (node.left) {\n      var v = doVisitHalf(lo, compare, visit, node.left);\n\n      if (v) {\n        return v;\n      }\n    }\n\n    var v = visit(node.key, node.value);\n\n    if (v) {\n      return v;\n    }\n  }\n\n  if (node.right) {\n    return doVisitHalf(lo, compare, visit, node.right);\n  }\n} //Visit all nodes within a range\n\n\nfunction doVisit(lo, hi, compare, visit, node) {\n  var l = compare(lo, node.key);\n  var h = compare(hi, node.key);\n  var v;\n\n  if (l <= 0) {\n    if (node.left) {\n      v = doVisit(lo, hi, compare, visit, node.left);\n\n      if (v) {\n        return v;\n      }\n    }\n\n    if (h > 0) {\n      v = visit(node.key, node.value);\n\n      if (v) {\n        return v;\n      }\n    }\n  }\n\n  if (h > 0 && node.right) {\n    return doVisit(lo, hi, compare, visit, node.right);\n  }\n}\n\nproto.forEach = function rbTreeForEach(visit, lo, hi) {\n  if (!this.root) {\n    return;\n  }\n\n  switch (arguments.length) {\n    case 1:\n      return doVisitFull(visit, this.root);\n      break;\n\n    case 2:\n      return doVisitHalf(lo, this._compare, visit, this.root);\n      break;\n\n    case 3:\n      if (this._compare(lo, hi) >= 0) {\n        return;\n      }\n\n      return doVisit(lo, hi, this._compare, visit, this.root);\n      break;\n  }\n}; //First item in list\n\n\nObject.defineProperty(proto, \"begin\", {\n  get: function get() {\n    var stack = [];\n    var n = this.root;\n\n    while (n) {\n      stack.push(n);\n      n = n.left;\n    }\n\n    return new RedBlackTreeIterator(this, stack);\n  }\n}); //Last item in list\n\nObject.defineProperty(proto, \"end\", {\n  get: function get() {\n    var stack = [];\n    var n = this.root;\n\n    while (n) {\n      stack.push(n);\n      n = n.right;\n    }\n\n    return new RedBlackTreeIterator(this, stack);\n  }\n}); //Find the ith item in the tree\n\nproto.at = function (idx) {\n  if (idx < 0) {\n    return new RedBlackTreeIterator(this, []);\n  }\n\n  var n = this.root;\n  var stack = [];\n\n  while (true) {\n    stack.push(n);\n\n    if (n.left) {\n      if (idx < n.left._count) {\n        n = n.left;\n        continue;\n      }\n\n      idx -= n.left._count;\n    }\n\n    if (!idx) {\n      return new RedBlackTreeIterator(this, stack);\n    }\n\n    idx -= 1;\n\n    if (n.right) {\n      if (idx >= n.right._count) {\n        break;\n      }\n\n      n = n.right;\n    } else {\n      break;\n    }\n  }\n\n  return new RedBlackTreeIterator(this, []);\n};\n\nproto.ge = function (key) {\n  var cmp = this._compare;\n  var n = this.root;\n  var stack = [];\n  var last_ptr = 0;\n\n  while (n) {\n    var d = cmp(key, n.key);\n    stack.push(n);\n\n    if (d <= 0) {\n      last_ptr = stack.length;\n    }\n\n    if (d <= 0) {\n      n = n.left;\n    } else {\n      n = n.right;\n    }\n  }\n\n  stack.length = last_ptr;\n  return new RedBlackTreeIterator(this, stack);\n};\n\nproto.gt = function (key) {\n  var cmp = this._compare;\n  var n = this.root;\n  var stack = [];\n  var last_ptr = 0;\n\n  while (n) {\n    var d = cmp(key, n.key);\n    stack.push(n);\n\n    if (d < 0) {\n      last_ptr = stack.length;\n    }\n\n    if (d < 0) {\n      n = n.left;\n    } else {\n      n = n.right;\n    }\n  }\n\n  stack.length = last_ptr;\n  return new RedBlackTreeIterator(this, stack);\n};\n\nproto.lt = function (key) {\n  var cmp = this._compare;\n  var n = this.root;\n  var stack = [];\n  var last_ptr = 0;\n\n  while (n) {\n    var d = cmp(key, n.key);\n    stack.push(n);\n\n    if (d > 0) {\n      last_ptr = stack.length;\n    }\n\n    if (d <= 0) {\n      n = n.left;\n    } else {\n      n = n.right;\n    }\n  }\n\n  stack.length = last_ptr;\n  return new RedBlackTreeIterator(this, stack);\n};\n\nproto.le = function (key) {\n  var cmp = this._compare;\n  var n = this.root;\n  var stack = [];\n  var last_ptr = 0;\n\n  while (n) {\n    var d = cmp(key, n.key);\n    stack.push(n);\n\n    if (d >= 0) {\n      last_ptr = stack.length;\n    }\n\n    if (d < 0) {\n      n = n.left;\n    } else {\n      n = n.right;\n    }\n  }\n\n  stack.length = last_ptr;\n  return new RedBlackTreeIterator(this, stack);\n}; //Finds the item with key if it exists\n\n\nproto.find = function (key) {\n  var cmp = this._compare;\n  var n = this.root;\n  var stack = [];\n\n  while (n) {\n    var d = cmp(key, n.key);\n    stack.push(n);\n\n    if (d === 0) {\n      return new RedBlackTreeIterator(this, stack);\n    }\n\n    if (d <= 0) {\n      n = n.left;\n    } else {\n      n = n.right;\n    }\n  }\n\n  return new RedBlackTreeIterator(this, []);\n}; //Removes item with key from tree\n\n\nproto.remove = function (key) {\n  var iter = this.find(key);\n\n  if (iter) {\n    return iter.remove();\n  }\n\n  return this;\n}; //Returns the item at `key`\n\n\nproto.get = function (key) {\n  var cmp = this._compare;\n  var n = this.root;\n\n  while (n) {\n    var d = cmp(key, n.key);\n\n    if (d === 0) {\n      return n.value;\n    }\n\n    if (d <= 0) {\n      n = n.left;\n    } else {\n      n = n.right;\n    }\n  }\n\n  return;\n}; //Iterator for red black tree\n\n\nfunction RedBlackTreeIterator(tree, stack) {\n  this.tree = tree;\n  this._stack = stack;\n}\n\nvar iproto = RedBlackTreeIterator.prototype; //Test if iterator is valid\n\nObject.defineProperty(iproto, \"valid\", {\n  get: function get() {\n    return this._stack.length > 0;\n  }\n}); //Node of the iterator\n\nObject.defineProperty(iproto, \"node\", {\n  get: function get() {\n    if (this._stack.length > 0) {\n      return this._stack[this._stack.length - 1];\n    }\n\n    return null;\n  },\n  enumerable: true\n}); //Makes a copy of an iterator\n\niproto.clone = function () {\n  return new RedBlackTreeIterator(this.tree, this._stack.slice());\n}; //Swaps two nodes\n\n\nfunction swapNode(n, v) {\n  n.key = v.key;\n  n.value = v.value;\n  n.left = v.left;\n  n.right = v.right;\n  n._color = v._color;\n  n._count = v._count;\n} //Fix up a double black node in a tree\n\n\nfunction fixDoubleBlack(stack) {\n  var n, p, s, z;\n\n  for (var i = stack.length - 1; i >= 0; --i) {\n    n = stack[i];\n\n    if (i === 0) {\n      n._color = BLACK;\n      return;\n    } //console.log(\"visit node:\", n.key, i, stack[i].key, stack[i-1].key)\n\n\n    p = stack[i - 1];\n\n    if (p.left === n) {\n      //console.log(\"left child\")\n      s = p.right;\n\n      if (s.right && s.right._color === RED) {\n        //console.log(\"case 1: right sibling child red\")\n        s = p.right = cloneNode(s);\n        z = s.right = cloneNode(s.right);\n        p.right = s.left;\n        s.left = p;\n        s.right = z;\n        s._color = p._color;\n        n._color = BLACK;\n        p._color = BLACK;\n        z._color = BLACK;\n        recount(p);\n        recount(s);\n\n        if (i > 1) {\n          var pp = stack[i - 2];\n\n          if (pp.left === p) {\n            pp.left = s;\n          } else {\n            pp.right = s;\n          }\n        }\n\n        stack[i - 1] = s;\n        return;\n      } else if (s.left && s.left._color === RED) {\n        //console.log(\"case 1: left sibling child red\")\n        s = p.right = cloneNode(s);\n        z = s.left = cloneNode(s.left);\n        p.right = z.left;\n        s.left = z.right;\n        z.left = p;\n        z.right = s;\n        z._color = p._color;\n        p._color = BLACK;\n        s._color = BLACK;\n        n._color = BLACK;\n        recount(p);\n        recount(s);\n        recount(z);\n\n        if (i > 1) {\n          var pp = stack[i - 2];\n\n          if (pp.left === p) {\n            pp.left = z;\n          } else {\n            pp.right = z;\n          }\n        }\n\n        stack[i - 1] = z;\n        return;\n      }\n\n      if (s._color === BLACK) {\n        if (p._color === RED) {\n          //console.log(\"case 2: black sibling, red parent\", p.right.value)\n          p._color = BLACK;\n          p.right = repaint(RED, s);\n          return;\n        } else {\n          //console.log(\"case 2: black sibling, black parent\", p.right.value)\n          p.right = repaint(RED, s);\n          continue;\n        }\n      } else {\n        //console.log(\"case 3: red sibling\")\n        s = cloneNode(s);\n        p.right = s.left;\n        s.left = p;\n        s._color = p._color;\n        p._color = RED;\n        recount(p);\n        recount(s);\n\n        if (i > 1) {\n          var pp = stack[i - 2];\n\n          if (pp.left === p) {\n            pp.left = s;\n          } else {\n            pp.right = s;\n          }\n        }\n\n        stack[i - 1] = s;\n        stack[i] = p;\n\n        if (i + 1 < stack.length) {\n          stack[i + 1] = n;\n        } else {\n          stack.push(n);\n        }\n\n        i = i + 2;\n      }\n    } else {\n      //console.log(\"right child\")\n      s = p.left;\n\n      if (s.left && s.left._color === RED) {\n        //console.log(\"case 1: left sibling child red\", p.value, p._color)\n        s = p.left = cloneNode(s);\n        z = s.left = cloneNode(s.left);\n        p.left = s.right;\n        s.right = p;\n        s.left = z;\n        s._color = p._color;\n        n._color = BLACK;\n        p._color = BLACK;\n        z._color = BLACK;\n        recount(p);\n        recount(s);\n\n        if (i > 1) {\n          var pp = stack[i - 2];\n\n          if (pp.right === p) {\n            pp.right = s;\n          } else {\n            pp.left = s;\n          }\n        }\n\n        stack[i - 1] = s;\n        return;\n      } else if (s.right && s.right._color === RED) {\n        //console.log(\"case 1: right sibling child red\")\n        s = p.left = cloneNode(s);\n        z = s.right = cloneNode(s.right);\n        p.left = z.right;\n        s.right = z.left;\n        z.right = p;\n        z.left = s;\n        z._color = p._color;\n        p._color = BLACK;\n        s._color = BLACK;\n        n._color = BLACK;\n        recount(p);\n        recount(s);\n        recount(z);\n\n        if (i > 1) {\n          var pp = stack[i - 2];\n\n          if (pp.right === p) {\n            pp.right = z;\n          } else {\n            pp.left = z;\n          }\n        }\n\n        stack[i - 1] = z;\n        return;\n      }\n\n      if (s._color === BLACK) {\n        if (p._color === RED) {\n          //console.log(\"case 2: black sibling, red parent\")\n          p._color = BLACK;\n          p.left = repaint(RED, s);\n          return;\n        } else {\n          //console.log(\"case 2: black sibling, black parent\")\n          p.left = repaint(RED, s);\n          continue;\n        }\n      } else {\n        //console.log(\"case 3: red sibling\")\n        s = cloneNode(s);\n        p.left = s.right;\n        s.right = p;\n        s._color = p._color;\n        p._color = RED;\n        recount(p);\n        recount(s);\n\n        if (i > 1) {\n          var pp = stack[i - 2];\n\n          if (pp.right === p) {\n            pp.right = s;\n          } else {\n            pp.left = s;\n          }\n        }\n\n        stack[i - 1] = s;\n        stack[i] = p;\n\n        if (i + 1 < stack.length) {\n          stack[i + 1] = n;\n        } else {\n          stack.push(n);\n        }\n\n        i = i + 2;\n      }\n    }\n  }\n} //Removes item at iterator from tree\n\n\niproto.remove = function () {\n  var stack = this._stack;\n\n  if (stack.length === 0) {\n    return this.tree;\n  } //First copy path to node\n\n\n  var cstack = new Array(stack.length);\n  var n = stack[stack.length - 1];\n  cstack[cstack.length - 1] = new RBNode(n._color, n.key, n.value, n.left, n.right, n._count);\n\n  for (var i = stack.length - 2; i >= 0; --i) {\n    var n = stack[i];\n\n    if (n.left === stack[i + 1]) {\n      cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i + 1], n.right, n._count);\n    } else {\n      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);\n    }\n  } //Get node\n\n\n  n = cstack[cstack.length - 1]; //console.log(\"start remove: \", n.value)\n  //If not leaf, then swap with previous node\n\n  if (n.left && n.right) {\n    //console.log(\"moving to leaf\")\n    //First walk to previous leaf\n    var split = cstack.length;\n    n = n.left;\n\n    while (n.right) {\n      cstack.push(n);\n      n = n.right;\n    } //Copy path to leaf\n\n\n    var v = cstack[split - 1];\n    cstack.push(new RBNode(n._color, v.key, v.value, n.left, n.right, n._count));\n    cstack[split - 1].key = n.key;\n    cstack[split - 1].value = n.value; //Fix up stack\n\n    for (var i = cstack.length - 2; i >= split; --i) {\n      n = cstack[i];\n      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);\n    }\n\n    cstack[split - 1].left = cstack[split];\n  } //console.log(\"stack=\", cstack.map(function(v) { return v.value }))\n  //Remove leaf node\n\n\n  n = cstack[cstack.length - 1];\n\n  if (n._color === RED) {\n    //Easy case: removing red leaf\n    //console.log(\"RED leaf\")\n    var p = cstack[cstack.length - 2];\n\n    if (p.left === n) {\n      p.left = null;\n    } else if (p.right === n) {\n      p.right = null;\n    }\n\n    cstack.pop();\n\n    for (var i = 0; i < cstack.length; ++i) {\n      cstack[i]._count--;\n    }\n\n    return new RedBlackTree(this.tree._compare, cstack[0]);\n  } else {\n    if (n.left || n.right) {\n      //Second easy case:  Single child black parent\n      //console.log(\"BLACK single child\")\n      if (n.left) {\n        swapNode(n, n.left);\n      } else if (n.right) {\n        swapNode(n, n.right);\n      } //Child must be red, so repaint it black to balance color\n\n\n      n._color = BLACK;\n\n      for (var i = 0; i < cstack.length - 1; ++i) {\n        cstack[i]._count--;\n      }\n\n      return new RedBlackTree(this.tree._compare, cstack[0]);\n    } else if (cstack.length === 1) {\n      //Third easy case: root\n      //console.log(\"ROOT\")\n      return new RedBlackTree(this.tree._compare, null);\n    } else {\n      //Hard case: Repaint n, and then do some nasty stuff\n      //console.log(\"BLACK leaf no children\")\n      for (var i = 0; i < cstack.length; ++i) {\n        cstack[i]._count--;\n      }\n\n      var parent = cstack[cstack.length - 2];\n      fixDoubleBlack(cstack); //Fix up links\n\n      if (parent.left === n) {\n        parent.left = null;\n      } else {\n        parent.right = null;\n      }\n    }\n  }\n\n  return new RedBlackTree(this.tree._compare, cstack[0]);\n}; //Returns key\n\n\nObject.defineProperty(iproto, \"key\", {\n  get: function get() {\n    if (this._stack.length > 0) {\n      return this._stack[this._stack.length - 1].key;\n    }\n\n    return;\n  },\n  enumerable: true\n}); //Returns value\n\nObject.defineProperty(iproto, \"value\", {\n  get: function get() {\n    if (this._stack.length > 0) {\n      return this._stack[this._stack.length - 1].value;\n    }\n\n    return;\n  },\n  enumerable: true\n}); //Returns the position of this iterator in the sorted list\n\nObject.defineProperty(iproto, \"index\", {\n  get: function get() {\n    var idx = 0;\n    var stack = this._stack;\n\n    if (stack.length === 0) {\n      var r = this.tree.root;\n\n      if (r) {\n        return r._count;\n      }\n\n      return 0;\n    } else if (stack[stack.length - 1].left) {\n      idx = stack[stack.length - 1].left._count;\n    }\n\n    for (var s = stack.length - 2; s >= 0; --s) {\n      if (stack[s + 1] === stack[s].right) {\n        ++idx;\n\n        if (stack[s].left) {\n          idx += stack[s].left._count;\n        }\n      }\n    }\n\n    return idx;\n  },\n  enumerable: true\n}); //Advances iterator to next element in list\n\niproto.next = function () {\n  var stack = this._stack;\n\n  if (stack.length === 0) {\n    return;\n  }\n\n  var n = stack[stack.length - 1];\n\n  if (n.right) {\n    n = n.right;\n\n    while (n) {\n      stack.push(n);\n      n = n.left;\n    }\n  } else {\n    stack.pop();\n\n    while (stack.length > 0 && stack[stack.length - 1].right === n) {\n      n = stack[stack.length - 1];\n      stack.pop();\n    }\n  }\n}; //Checks if iterator is at end of tree\n\n\nObject.defineProperty(iproto, \"hasNext\", {\n  get: function get() {\n    var stack = this._stack;\n\n    if (stack.length === 0) {\n      return false;\n    }\n\n    if (stack[stack.length - 1].right) {\n      return true;\n    }\n\n    for (var s = stack.length - 1; s > 0; --s) {\n      if (stack[s - 1].left === stack[s]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n}); //Update value\n\niproto.update = function (value) {\n  var stack = this._stack;\n\n  if (stack.length === 0) {\n    throw new Error(\"Can't update empty node!\");\n  }\n\n  var cstack = new Array(stack.length);\n  var n = stack[stack.length - 1];\n  cstack[cstack.length - 1] = new RBNode(n._color, n.key, value, n.left, n.right, n._count);\n\n  for (var i = stack.length - 2; i >= 0; --i) {\n    n = stack[i];\n\n    if (n.left === stack[i + 1]) {\n      cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i + 1], n.right, n._count);\n    } else {\n      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);\n    }\n  }\n\n  return new RedBlackTree(this.tree._compare, cstack[0]);\n}; //Moves iterator backward one element\n\n\niproto.prev = function () {\n  var stack = this._stack;\n\n  if (stack.length === 0) {\n    return;\n  }\n\n  var n = stack[stack.length - 1];\n\n  if (n.left) {\n    n = n.left;\n\n    while (n) {\n      stack.push(n);\n      n = n.right;\n    }\n  } else {\n    stack.pop();\n\n    while (stack.length > 0 && stack[stack.length - 1].left === n) {\n      n = stack[stack.length - 1];\n      stack.pop();\n    }\n  }\n}; //Checks if iterator is at start of tree\n\n\nObject.defineProperty(iproto, \"hasPrev\", {\n  get: function get() {\n    var stack = this._stack;\n\n    if (stack.length === 0) {\n      return false;\n    }\n\n    if (stack[stack.length - 1].left) {\n      return true;\n    }\n\n    for (var s = stack.length - 1; s > 0; --s) {\n      if (stack[s - 1].right === stack[s]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n}); //Default comparison function\n\nfunction defaultCompare(a, b) {\n  if (a < b) {\n    return -1;\n  }\n\n  if (a > b) {\n    return 1;\n  }\n\n  return 0;\n} //Build a tree\n\n\nfunction createRBTree(compare) {\n  return new RedBlackTree(compare || defaultCompare, null);\n}","map":null,"metadata":{},"sourceType":"script"}