{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BundleExecutor = void 0;\n\nvar status_1 = require(\"../status\");\n\nvar googleError_1 = require(\"../googleError\");\n\nvar warnings_1 = require(\"../warnings\");\n\nvar bundlingUtils_1 = require(\"./bundlingUtils\");\n\nvar task_1 = require(\"./task\");\n\nfunction noop() {}\n/**\n * BundleExecutor stores several timers for each bundle (calls are bundled based\n * on the options passed, each bundle has unique ID that is calculated based on\n * field values). Each timer fires and sends a call after certain amount of\n * time, and if a new request comes to the same bundle, the timer can be\n * restarted.\n */\n\n\nvar BundleExecutor = /*#__PURE__*/function () {\n  /**\n   * Organizes requests for an api service that requires to bundle them.\n   *\n   * @param {BundleOptions} bundleOptions - configures strategy this instance\n   *   uses when executing bundled functions.\n   * @param {BundleDescriptor} bundleDescriptor - the description of the bundling.\n   * @constructor\n   */\n  function BundleExecutor(bundleOptions, bundleDescriptor) {\n    _classCallCheck(this, BundleExecutor);\n\n    this._options = bundleOptions;\n    this._descriptor = bundleDescriptor;\n    this._tasks = {};\n    this._timers = {};\n    this._invocations = {};\n    this._invocationId = 0;\n  }\n  /**\n   * Schedule a method call.\n   *\n   * @param {function} apiCall - the function for an API call.\n   * @param {Object} request - the request object to be bundled with others.\n   * @param {APICallback} callback - the callback to be called when the method finished.\n   * @return {function()} - the function to cancel the scheduled invocation.\n   */\n\n\n  _createClass(BundleExecutor, [{\n    key: \"schedule\",\n    value: function schedule(apiCall, request, callback) {\n      var _this = this;\n\n      var bundleId = bundlingUtils_1.computeBundleId(request, this._descriptor.requestDiscriminatorFields);\n      callback = callback || noop;\n\n      if (bundleId === undefined) {\n        warnings_1.warn('bundling_schedule_bundleid_undefined', 'The request does not have enough information for request bundling. ' + \"Invoking immediately. Request: \".concat(JSON.stringify(request), \" \") + \"discriminator fields: \".concat(this._descriptor.requestDiscriminatorFields));\n        return apiCall(request, callback);\n      }\n\n      if (request[this._descriptor.bundledField] === undefined) {\n        warnings_1.warn('bundling_no_bundled_field', \"Request does not contain field \".concat(this._descriptor.bundledField, \" that must present for bundling. \") + \"Invoking immediately. Request: \".concat(JSON.stringify(request)));\n        return apiCall(request, callback);\n      }\n\n      if (!(bundleId in this._tasks)) {\n        this._tasks[bundleId] = new task_1.Task(apiCall, request, this._descriptor.bundledField, this._descriptor.subresponseField);\n      }\n\n      var task = this._tasks[bundleId];\n      callback.id = String(this._invocationId++);\n      this._invocations[callback.id] = bundleId;\n      var bundledField = request[this._descriptor.bundledField];\n      var elementCount = bundledField.length;\n      var requestBytes = 0; // eslint-disable-next-line @typescript-eslint/no-this-alias\n\n      var self = this;\n      bundledField.forEach(function (obj) {\n        requestBytes += _this._descriptor.byteLengthFunction(obj);\n      });\n      var countLimit = this._options.elementCountLimit || 0;\n      var byteLimit = this._options.requestByteLimit || 0;\n\n      if (countLimit > 0 && elementCount > countLimit || byteLimit > 0 && requestBytes >= byteLimit) {\n        var message;\n\n        if (countLimit > 0 && elementCount > countLimit) {\n          message = 'The number of elements ' + elementCount + ' exceeds the limit ' + this._options.elementCountLimit;\n        } else {\n          message = 'The required bytes ' + requestBytes + ' exceeds the limit ' + this._options.requestByteLimit;\n        }\n\n        var error = new googleError_1.GoogleError(message);\n        error.code = status_1.Status.INVALID_ARGUMENT;\n        callback(error);\n        return {\n          cancel: noop\n        };\n      }\n\n      var existingCount = task.getElementCount();\n      var existingBytes = task.getRequestByteSize();\n\n      if (countLimit > 0 && elementCount + existingCount >= countLimit || byteLimit > 0 && requestBytes + existingBytes >= byteLimit) {\n        this._runNow(bundleId);\n\n        this._tasks[bundleId] = new task_1.Task(apiCall, request, this._descriptor.bundledField, this._descriptor.subresponseField);\n        task = this._tasks[bundleId];\n      }\n\n      task.extend(bundledField, requestBytes, callback);\n      var ret = {\n        cancel: function cancel() {\n          self._cancel(callback.id);\n        }\n      };\n      var countThreshold = this._options.elementCountThreshold || 0;\n      var sizeThreshold = this._options.requestByteThreshold || 0;\n\n      if (countThreshold > 0 && task.getElementCount() >= countThreshold || sizeThreshold > 0 && task.getRequestByteSize() >= sizeThreshold) {\n        this._runNow(bundleId);\n\n        return ret;\n      }\n\n      if (!(bundleId in this._timers) && this._options.delayThreshold > 0) {\n        this._timers[bundleId] = setTimeout(function () {\n          delete _this._timers[bundleId];\n\n          _this._runNow(bundleId);\n        }, this._options.delayThreshold);\n      }\n\n      return ret;\n    }\n    /**\n     * Clears scheduled timeout if it exists.\n     *\n     * @param {String} bundleId - the id for the task whose timeout needs to be\n     *   cleared.\n     * @private\n     */\n\n  }, {\n    key: \"_maybeClearTimeout\",\n    value: function _maybeClearTimeout(bundleId) {\n      if (bundleId in this._timers) {\n        var timerId = this._timers[bundleId];\n        delete this._timers[bundleId];\n        clearTimeout(timerId);\n      }\n    }\n    /**\n     * Cancels an event.\n     *\n     * @param {String} id - The id for the event in the task.\n     * @private\n     */\n\n  }, {\n    key: \"_cancel\",\n    value: function _cancel(id) {\n      if (!(id in this._invocations)) {\n        return;\n      }\n\n      var bundleId = this._invocations[id];\n\n      if (!(bundleId in this._tasks)) {\n        return;\n      }\n\n      var task = this._tasks[bundleId];\n      delete this._invocations[id];\n\n      if (task.cancel(id)) {\n        this._maybeClearTimeout(bundleId);\n\n        delete this._tasks[bundleId];\n      }\n    }\n    /**\n     * Invokes a task.\n     *\n     * @param {String} bundleId - The id for the task.\n     * @private\n     */\n\n  }, {\n    key: \"_runNow\",\n    value: function _runNow(bundleId) {\n      var _this2 = this;\n\n      if (!(bundleId in this._tasks)) {\n        warnings_1.warn('bundle_runnow_bundleid_unknown', \"No such bundleid: \".concat(bundleId));\n        return;\n      }\n\n      this._maybeClearTimeout(bundleId);\n\n      var task = this._tasks[bundleId];\n      delete this._tasks[bundleId];\n      task.run().forEach(function (id) {\n        delete _this2._invocations[id];\n      });\n    }\n  }]);\n\n  return BundleExecutor;\n}();\n\nexports.BundleExecutor = BundleExecutor;","map":null,"metadata":{},"sourceType":"script"}