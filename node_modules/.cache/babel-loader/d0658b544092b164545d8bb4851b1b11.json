{"ast":null,"code":"/**\r\n * A hierarchical token bucket for rate limiting. See\r\n * http://en.wikipedia.org/wiki/Token_bucket for more information.\r\n * @author John Hurliman <jhurliman@cull.tv>\r\n *\r\n * @param {Number} bucketSize Maximum number of tokens to hold in the bucket.\r\n *  Also known as the burst rate.\r\n * @param {Number} tokensPerInterval Number of tokens to drip into the bucket\r\n *  over the course of one interval.\r\n * @param {String|Number} interval The interval length in milliseconds, or as\r\n *  one of the following strings: 'second', 'minute', 'hour', day'.\r\n * @param {TokenBucket} parentBucket Optional. A token bucket that will act as\r\n *  the parent of this bucket.\r\n */\nvar TokenBucket = function TokenBucket(bucketSize, tokensPerInterval, interval, parentBucket) {\n  this.bucketSize = bucketSize;\n  this.tokensPerInterval = tokensPerInterval;\n\n  if (typeof interval === 'string') {\n    switch (interval) {\n      case 'sec':\n      case 'second':\n        this.interval = 1000;\n        break;\n\n      case 'min':\n      case 'minute':\n        this.interval = 1000 * 60;\n        break;\n\n      case 'hr':\n      case 'hour':\n        this.interval = 1000 * 60 * 60;\n        break;\n\n      case 'day':\n        this.interval = 1000 * 60 * 60 * 24;\n        break;\n\n      default:\n        throw new Error('Invaid interval ' + interval);\n    }\n  } else {\n    this.interval = interval;\n  }\n\n  this.parentBucket = parentBucket;\n  this.content = 0;\n  this.lastDrip = +new Date();\n};\n\nTokenBucket.prototype = {\n  bucketSize: 1,\n  tokensPerInterval: 1,\n  interval: 1000,\n  parentBucket: null,\n  content: 0,\n  lastDrip: 0,\n\n  /**\r\n   * Remove the requested number of tokens and fire the given callback. If the\r\n   * bucket (and any parent buckets) contains enough tokens this will happen\r\n   * immediately. Otherwise, the removal and callback will happen when enough\r\n   * tokens become available.\r\n   * @param {Number} count The number of tokens to remove.\r\n   * @param {Function} callback(err, remainingTokens)\r\n   * @returns {Boolean} True if the callback was fired immediately, otherwise\r\n   *  false.\r\n   */\n  removeTokens: function removeTokens(count, callback) {\n    var self = this; // Is this an infinite size bucket?\n\n    if (!this.bucketSize) {\n      process.nextTick(callback.bind(null, null, count, Number.POSITIVE_INFINITY));\n      return true;\n    } // Make sure the bucket can hold the requested number of tokens\n\n\n    if (count > this.bucketSize) {\n      process.nextTick(callback.bind(null, 'Requested tokens ' + count + ' exceeds bucket size ' + this.bucketSize, null));\n      return false;\n    } // Drip new tokens into this bucket\n\n\n    this.drip(); // If we don't have enough tokens in this bucket, come back later\n\n    if (count > this.content) return comeBackLater();\n\n    if (this.parentBucket) {\n      // Remove the requested from the parent bucket first\n      return this.parentBucket.removeTokens(count, function (err, remainingTokens) {\n        if (err) return callback(err, null); // Check that we still have enough tokens in this bucket\n\n        if (count > self.content) return comeBackLater(); // Tokens were removed from the parent bucket, now remove them from\n        // this bucket and fire the callback. Note that we look at the current\n        // bucket and parent bucket's remaining tokens and return the smaller\n        // of the two values\n\n        self.content -= count;\n        callback(null, Math.min(remainingTokens, self.content));\n      });\n    } else {\n      // Remove the requested tokens from this bucket and fire the callback\n      this.content -= count;\n      process.nextTick(callback.bind(null, null, this.content));\n      return true;\n    }\n\n    function comeBackLater() {\n      // How long do we need to wait to make up the difference in tokens?\n      var waitInterval = Math.ceil((count - self.content) * (self.interval / self.tokensPerInterval));\n      setTimeout(function () {\n        self.removeTokens(count, callback);\n      }, waitInterval);\n      return false;\n    }\n  },\n\n  /**\r\n   * Attempt to remove the requested number of tokens and return immediately.\r\n   * If the bucket (and any parent buckets) contains enough tokens this will\r\n   * return true, otherwise false is returned.\r\n   * @param {Number} count The number of tokens to remove.\r\n   * @param {Boolean} True if the tokens were successfully removed, otherwise\r\n   *  false.\r\n   */\n  tryRemoveTokens: function tryRemoveTokens(count) {\n    // Is this an infinite size bucket?\n    if (!this.bucketSize) return true; // Make sure the bucket can hold the requested number of tokens\n\n    if (count > this.bucketSize) return false; // Drip new tokens into this bucket\n\n    this.drip(); // If we don't have enough tokens in this bucket, return false\n\n    if (count > this.content) return false; // Try to remove the requested tokens from the parent bucket\n\n    if (this.parentBucket && !this.parentBucket.tryRemoveTokens(count)) return false; // Remove the requested tokens from this bucket and return\n\n    this.content -= count;\n    return true;\n  },\n\n  /**\r\n   * Add any new tokens to the bucket since the last drip.\r\n   * @returns {Boolean} True if new tokens were added, otherwise false.\r\n   */\n  drip: function drip() {\n    if (!this.tokensPerInterval) {\n      this.content = this.bucketSize;\n      return;\n    }\n\n    var now = +new Date();\n    var deltaMS = Math.max(now - this.lastDrip, 0);\n    this.lastDrip = now;\n    var dripAmount = deltaMS * (this.tokensPerInterval / this.interval);\n    this.content = Math.min(this.content + dripAmount, this.bucketSize);\n  }\n};\nmodule.exports = TokenBucket;","map":null,"metadata":{},"sourceType":"script"}