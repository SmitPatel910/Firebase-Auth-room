{"ast":null,"code":"/*! firebase-admin v9.11.0 */\n\"use strict\";\n/*!\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useEmulator = exports.TenantAwareAuthRequestHandler = exports.AuthRequestHandler = exports.AbstractAuthRequestHandler = exports.FIREBASE_AUTH_SIGN_UP_NEW_USER = exports.FIREBASE_AUTH_SET_ACCOUNT_INFO = exports.FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS = exports.FIREBASE_AUTH_DELETE_ACCOUNT = exports.FIREBASE_AUTH_GET_ACCOUNTS_INFO = exports.FIREBASE_AUTH_GET_ACCOUNT_INFO = exports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT = exports.FIREBASE_AUTH_UPLOAD_ACCOUNT = exports.FIREBASE_AUTH_CREATE_SESSION_COOKIE = exports.EMAIL_ACTION_REQUEST_TYPES = exports.RESERVED_CLAIMS = void 0;\n\nvar validator = require(\"../utils/validator\");\n\nvar deep_copy_1 = require(\"../utils/deep-copy\");\n\nvar identifier_1 = require(\"./identifier\");\n\nvar error_1 = require(\"../utils/error\");\n\nvar api_request_1 = require(\"../utils/api-request\");\n\nvar user_import_builder_1 = require(\"./user-import-builder\");\n\nvar utils = require(\"../utils/index\");\n\nvar action_code_settings_builder_1 = require(\"./action-code-settings-builder\");\n\nvar auth_config_1 = require(\"./auth-config\");\n\nvar tenant_1 = require(\"./tenant\");\n/** Firebase Auth request header. */\n\n\nvar FIREBASE_AUTH_HEADER = {\n  'X-Client-Version': \"Node/Admin/\" + utils.getSdkVersion()\n};\n/** Firebase Auth request timeout duration in milliseconds. */\n\nvar FIREBASE_AUTH_TIMEOUT = 25000;\n/** List of reserved claims which cannot be provided when creating a custom token. */\n\nexports.RESERVED_CLAIMS = ['acr', 'amr', 'at_hash', 'aud', 'auth_time', 'azp', 'cnf', 'c_hash', 'exp', 'iat', 'iss', 'jti', 'nbf', 'nonce', 'sub', 'firebase'];\n/** List of supported email action request types. */\n\nexports.EMAIL_ACTION_REQUEST_TYPES = ['PASSWORD_RESET', 'VERIFY_EMAIL', 'EMAIL_SIGNIN'];\n/** Maximum allowed number of characters in the custom claims payload. */\n\nvar MAX_CLAIMS_PAYLOAD_SIZE = 1000;\n/** Maximum allowed number of users to batch download at one time. */\n\nvar MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE = 1000;\n/** Maximum allowed number of users to batch upload at one time. */\n\nvar MAX_UPLOAD_ACCOUNT_BATCH_SIZE = 1000;\n/** Maximum allowed number of users to batch get at one time. */\n\nvar MAX_GET_ACCOUNTS_BATCH_SIZE = 100;\n/** Maximum allowed number of users to batch delete at one time. */\n\nvar MAX_DELETE_ACCOUNTS_BATCH_SIZE = 1000;\n/** Minimum allowed session cookie duration in seconds (5 minutes). */\n\nvar MIN_SESSION_COOKIE_DURATION_SECS = 5 * 60;\n/** Maximum allowed session cookie duration in seconds (2 weeks). */\n\nvar MAX_SESSION_COOKIE_DURATION_SECS = 14 * 24 * 60 * 60;\n/** Maximum allowed number of provider configurations to batch download at one time. */\n\nvar MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE = 100;\n/** The Firebase Auth backend base URL format. */\n\nvar FIREBASE_AUTH_BASE_URL_FORMAT = 'https://identitytoolkit.googleapis.com/{version}/projects/{projectId}{api}';\n/** Firebase Auth base URlLformat when using the auth emultor. */\n\nvar FIREBASE_AUTH_EMULATOR_BASE_URL_FORMAT = 'http://{host}/identitytoolkit.googleapis.com/{version}/projects/{projectId}{api}';\n/** The Firebase Auth backend multi-tenancy base URL format. */\n\nvar FIREBASE_AUTH_TENANT_URL_FORMAT = FIREBASE_AUTH_BASE_URL_FORMAT.replace('projects/{projectId}', 'projects/{projectId}/tenants/{tenantId}');\n/** Firebase Auth base URL format when using the auth emultor with multi-tenancy. */\n\nvar FIREBASE_AUTH_EMULATOR_TENANT_URL_FORMAT = FIREBASE_AUTH_EMULATOR_BASE_URL_FORMAT.replace('projects/{projectId}', 'projects/{projectId}/tenants/{tenantId}');\n/** Maximum allowed number of tenants to download at one time. */\n\nvar MAX_LIST_TENANT_PAGE_SIZE = 1000;\n/**\n * Enum for the user write operation type.\n */\n\nvar WriteOperationType;\n\n(function (WriteOperationType) {\n  WriteOperationType[\"Create\"] = \"create\";\n  WriteOperationType[\"Update\"] = \"update\";\n  WriteOperationType[\"Upload\"] = \"upload\";\n})(WriteOperationType || (WriteOperationType = {}));\n/** Defines a base utility to help with resource URL construction. */\n\n\nvar AuthResourceUrlBuilder =\n/** @class */\nfunction () {\n  /**\n   * The resource URL builder constructor.\n   *\n   * @param {string} projectId The resource project ID.\n   * @param {string} version The endpoint API version.\n   * @constructor\n   */\n  function AuthResourceUrlBuilder(app, version) {\n    if (version === void 0) {\n      version = 'v1';\n    }\n\n    this.app = app;\n    this.version = version;\n\n    if (useEmulator()) {\n      this.urlFormat = utils.formatString(FIREBASE_AUTH_EMULATOR_BASE_URL_FORMAT, {\n        host: emulatorHost()\n      });\n    } else {\n      this.urlFormat = FIREBASE_AUTH_BASE_URL_FORMAT;\n    }\n  }\n  /**\n   * Returns the resource URL corresponding to the provided parameters.\n   *\n   * @param {string=} api The backend API name.\n   * @param {object=} params The optional additional parameters to substitute in the\n   *     URL path.\n   * @return {Promise<string>} The corresponding resource URL.\n   */\n\n\n  AuthResourceUrlBuilder.prototype.getUrl = function (api, params) {\n    var _this = this;\n\n    return this.getProjectId().then(function (projectId) {\n      var baseParams = {\n        version: _this.version,\n        projectId: projectId,\n        api: api || ''\n      };\n      var baseUrl = utils.formatString(_this.urlFormat, baseParams); // Substitute additional api related parameters.\n\n      return utils.formatString(baseUrl, params || {});\n    });\n  };\n\n  AuthResourceUrlBuilder.prototype.getProjectId = function () {\n    var _this = this;\n\n    if (this.projectId) {\n      return Promise.resolve(this.projectId);\n    }\n\n    return utils.findProjectId(this.app).then(function (projectId) {\n      if (!validator.isNonEmptyString(projectId)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREDENTIAL, 'Failed to determine project ID for Auth. Initialize the ' + 'SDK with service account credentials or set project ID as an app option. ' + 'Alternatively set the GOOGLE_CLOUD_PROJECT environment variable.');\n      }\n\n      _this.projectId = projectId;\n      return projectId;\n    });\n  };\n\n  return AuthResourceUrlBuilder;\n}();\n/** Tenant aware resource builder utility. */\n\n\nvar TenantAwareAuthResourceUrlBuilder =\n/** @class */\nfunction (_super) {\n  __extends(TenantAwareAuthResourceUrlBuilder, _super);\n  /**\n   * The tenant aware resource URL builder constructor.\n   *\n   * @param {string} projectId The resource project ID.\n   * @param {string} version The endpoint API version.\n   * @param {string} tenantId The tenant ID.\n   * @constructor\n   */\n\n\n  function TenantAwareAuthResourceUrlBuilder(app, version, tenantId) {\n    var _this = _super.call(this, app, version) || this;\n\n    _this.app = app;\n    _this.version = version;\n    _this.tenantId = tenantId;\n\n    if (useEmulator()) {\n      _this.urlFormat = utils.formatString(FIREBASE_AUTH_EMULATOR_TENANT_URL_FORMAT, {\n        host: emulatorHost()\n      });\n    } else {\n      _this.urlFormat = FIREBASE_AUTH_TENANT_URL_FORMAT;\n    }\n\n    return _this;\n  }\n  /**\n   * Returns the resource URL corresponding to the provided parameters.\n   *\n   * @param {string=} api The backend API name.\n   * @param {object=} params The optional additional parameters to substitute in the\n   *     URL path.\n   * @return {Promise<string>} The corresponding resource URL.\n   */\n\n\n  TenantAwareAuthResourceUrlBuilder.prototype.getUrl = function (api, params) {\n    var _this = this;\n\n    return _super.prototype.getUrl.call(this, api, params).then(function (url) {\n      return utils.formatString(url, {\n        tenantId: _this.tenantId\n      });\n    });\n  };\n\n  return TenantAwareAuthResourceUrlBuilder;\n}(AuthResourceUrlBuilder);\n/**\n * Auth-specific HTTP client which uses the special \"owner\" token\n * when communicating with the Auth Emulator.\n */\n\n\nvar AuthHttpClient =\n/** @class */\nfunction (_super) {\n  __extends(AuthHttpClient, _super);\n\n  function AuthHttpClient() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  AuthHttpClient.prototype.getToken = function () {\n    if (useEmulator()) {\n      return Promise.resolve('owner');\n    }\n\n    return _super.prototype.getToken.call(this);\n  };\n\n  return AuthHttpClient;\n}(api_request_1.AuthorizedHttpClient);\n/**\n * Validates an AuthFactorInfo object. All unsupported parameters\n * are removed from the original request. If an invalid field is passed\n * an error is thrown.\n *\n * @param request The AuthFactorInfo request object.\n */\n\n\nfunction validateAuthFactorInfo(request) {\n  var validKeys = {\n    mfaEnrollmentId: true,\n    displayName: true,\n    phoneInfo: true,\n    enrolledAt: true\n  }; // Remove unsupported keys from the original request.\n\n  for (var key in request) {\n    if (!(key in validKeys)) {\n      delete request[key];\n    }\n  } // No enrollment ID is available for signupNewUser. Use another identifier.\n\n\n  var authFactorInfoIdentifier = request.mfaEnrollmentId || request.phoneInfo || JSON.stringify(request); // Enrollment uid may or may not be specified for update operations.\n\n  if (typeof request.mfaEnrollmentId !== 'undefined' && !validator.isNonEmptyString(request.mfaEnrollmentId)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID, 'The second factor \"uid\" must be a valid non-empty string.');\n  }\n\n  if (typeof request.displayName !== 'undefined' && !validator.isString(request.displayName)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME, \"The second factor \\\"displayName\\\" for \\\"\" + authFactorInfoIdentifier + \"\\\" must be a valid string.\");\n  } // enrolledAt must be a valid UTC date string.\n\n\n  if (typeof request.enrolledAt !== 'undefined' && !validator.isISODateString(request.enrolledAt)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLMENT_TIME, \"The second factor \\\"enrollmentTime\\\" for \\\"\" + authFactorInfoIdentifier + \"\\\" must be a valid \" + 'UTC date string.');\n  } // Validate required fields depending on second factor type.\n\n\n  if (typeof request.phoneInfo !== 'undefined') {\n    // phoneNumber should be a string and a valid phone number.\n    if (!validator.isPhoneNumber(request.phoneInfo)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER, \"The second factor \\\"phoneNumber\\\" for \\\"\" + authFactorInfoIdentifier + \"\\\" must be a non-empty \" + 'E.164 standard compliant identifier string.');\n    }\n  } else {\n    // Invalid second factor. For example, a phone second factor may have been provided without\n    // a phone number. A TOTP based second factor may require a secret key, etc.\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLED_FACTORS, 'MFAInfo object provided is invalid.');\n  }\n}\n/**\n * Validates a providerUserInfo object. All unsupported parameters\n * are removed from the original request. If an invalid field is passed\n * an error is thrown.\n *\n * @param {any} request The providerUserInfo request object.\n */\n\n\nfunction validateProviderUserInfo(request) {\n  var validKeys = {\n    rawId: true,\n    providerId: true,\n    email: true,\n    displayName: true,\n    photoUrl: true\n  }; // Remove invalid keys from original request.\n\n  for (var key in request) {\n    if (!(key in validKeys)) {\n      delete request[key];\n    }\n  }\n\n  if (!validator.isNonEmptyString(request.providerId)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID);\n  }\n\n  if (typeof request.displayName !== 'undefined' && typeof request.displayName !== 'string') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME, \"The provider \\\"displayName\\\" for \\\"\" + request.providerId + \"\\\" must be a valid string.\");\n  }\n\n  if (!validator.isNonEmptyString(request.rawId)) {\n    // This is called localId on the backend but the developer specifies this as\n    // uid externally. So the error message should use the client facing name.\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID, \"The provider \\\"uid\\\" for \\\"\" + request.providerId + \"\\\" must be a valid non-empty string.\");\n  } // email should be a string and a valid email.\n\n\n  if (typeof request.email !== 'undefined' && !validator.isEmail(request.email)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL, \"The provider \\\"email\\\" for \\\"\" + request.providerId + \"\\\" must be a valid email string.\");\n  } // photoUrl should be a URL.\n\n\n  if (typeof request.photoUrl !== 'undefined' && !validator.isURL(request.photoUrl)) {\n    // This is called photoUrl on the backend but the developer specifies this as\n    // photoURL externally. So the error message should use the client facing name.\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHOTO_URL, \"The provider \\\"photoURL\\\" for \\\"\" + request.providerId + \"\\\" must be a valid URL string.\");\n  }\n}\n/**\n * Validates a create/edit request object. All unsupported parameters\n * are removed from the original request. If an invalid field is passed\n * an error is thrown.\n *\n * @param request The create/edit request object.\n * @param writeOperationType The write operation type.\n */\n\n\nfunction validateCreateEditRequest(request, writeOperationType) {\n  var uploadAccountRequest = writeOperationType === WriteOperationType.Upload; // Hash set of whitelisted parameters.\n\n  var validKeys = {\n    displayName: true,\n    localId: true,\n    email: true,\n    password: true,\n    rawPassword: true,\n    emailVerified: true,\n    photoUrl: true,\n    disabled: true,\n    disableUser: true,\n    deleteAttribute: true,\n    deleteProvider: true,\n    sanityCheck: true,\n    phoneNumber: true,\n    customAttributes: true,\n    validSince: true,\n    // Pass linkProviderUserInfo only for updates (i.e. not for uploads.)\n    linkProviderUserInfo: !uploadAccountRequest,\n    // Pass tenantId only for uploadAccount requests.\n    tenantId: uploadAccountRequest,\n    passwordHash: uploadAccountRequest,\n    salt: uploadAccountRequest,\n    createdAt: uploadAccountRequest,\n    lastLoginAt: uploadAccountRequest,\n    providerUserInfo: uploadAccountRequest,\n    mfaInfo: uploadAccountRequest,\n    // Only for non-uploadAccount requests.\n    mfa: !uploadAccountRequest\n  }; // Remove invalid keys from original request.\n\n  for (var key in request) {\n    if (!(key in validKeys)) {\n      delete request[key];\n    }\n  }\n\n  if (typeof request.tenantId !== 'undefined' && !validator.isNonEmptyString(request.tenantId)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID);\n  } // For any invalid parameter, use the external key name in the error description.\n  // displayName should be a string.\n\n\n  if (typeof request.displayName !== 'undefined' && !validator.isString(request.displayName)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME);\n  }\n\n  if ((typeof request.localId !== 'undefined' || uploadAccountRequest) && !validator.isUid(request.localId)) {\n    // This is called localId on the backend but the developer specifies this as\n    // uid externally. So the error message should use the client facing name.\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID);\n  } // email should be a string and a valid email.\n\n\n  if (typeof request.email !== 'undefined' && !validator.isEmail(request.email)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);\n  } // phoneNumber should be a string and a valid phone number.\n\n\n  if (typeof request.phoneNumber !== 'undefined' && !validator.isPhoneNumber(request.phoneNumber)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER);\n  } // password should be a string and a minimum of 6 chars.\n\n\n  if (typeof request.password !== 'undefined' && !validator.isPassword(request.password)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD);\n  } // rawPassword should be a string and a minimum of 6 chars.\n\n\n  if (typeof request.rawPassword !== 'undefined' && !validator.isPassword(request.rawPassword)) {\n    // This is called rawPassword on the backend but the developer specifies this as\n    // password externally. So the error message should use the client facing name.\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD);\n  } // emailVerified should be a boolean.\n\n\n  if (typeof request.emailVerified !== 'undefined' && typeof request.emailVerified !== 'boolean') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL_VERIFIED);\n  } // photoUrl should be a URL.\n\n\n  if (typeof request.photoUrl !== 'undefined' && !validator.isURL(request.photoUrl)) {\n    // This is called photoUrl on the backend but the developer specifies this as\n    // photoURL externally. So the error message should use the client facing name.\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHOTO_URL);\n  } // disabled should be a boolean.\n\n\n  if (typeof request.disabled !== 'undefined' && typeof request.disabled !== 'boolean') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISABLED_FIELD);\n  } // validSince should be a number.\n\n\n  if (typeof request.validSince !== 'undefined' && !validator.isNumber(request.validSince)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TOKENS_VALID_AFTER_TIME);\n  } // createdAt should be a number.\n\n\n  if (typeof request.createdAt !== 'undefined' && !validator.isNumber(request.createdAt)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREATION_TIME);\n  } // lastSignInAt should be a number.\n\n\n  if (typeof request.lastLoginAt !== 'undefined' && !validator.isNumber(request.lastLoginAt)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_LAST_SIGN_IN_TIME);\n  } // disableUser should be a boolean.\n\n\n  if (typeof request.disableUser !== 'undefined' && typeof request.disableUser !== 'boolean') {\n    // This is called disableUser on the backend but the developer specifies this as\n    // disabled externally. So the error message should use the client facing name.\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISABLED_FIELD);\n  } // customAttributes should be stringified JSON with no blacklisted claims.\n  // The payload should not exceed 1KB.\n\n\n  if (typeof request.customAttributes !== 'undefined') {\n    var developerClaims_1;\n\n    try {\n      developerClaims_1 = JSON.parse(request.customAttributes);\n    } catch (error) {\n      // JSON parsing error. This should never happen as we stringify the claims internally.\n      // However, we still need to check since setAccountInfo via edit requests could pass\n      // this field.\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CLAIMS, error.message);\n    }\n\n    var invalidClaims_1 = []; // Check for any invalid claims.\n\n    exports.RESERVED_CLAIMS.forEach(function (blacklistedClaim) {\n      if (Object.prototype.hasOwnProperty.call(developerClaims_1, blacklistedClaim)) {\n        invalidClaims_1.push(blacklistedClaim);\n      }\n    }); // Throw an error if an invalid claim is detected.\n\n    if (invalidClaims_1.length > 0) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.FORBIDDEN_CLAIM, invalidClaims_1.length > 1 ? \"Developer claims \\\"\" + invalidClaims_1.join('\", \"') + \"\\\" are reserved and cannot be specified.\" : \"Developer claim \\\"\" + invalidClaims_1[0] + \"\\\" is reserved and cannot be specified.\");\n    } // Check claims payload does not exceed maxmimum size.\n\n\n    if (request.customAttributes.length > MAX_CLAIMS_PAYLOAD_SIZE) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.CLAIMS_TOO_LARGE, \"Developer claims payload should not exceed \" + MAX_CLAIMS_PAYLOAD_SIZE + \" characters.\");\n    }\n  } // passwordHash has to be a base64 encoded string.\n\n\n  if (typeof request.passwordHash !== 'undefined' && !validator.isString(request.passwordHash)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_HASH);\n  } // salt has to be a base64 encoded string.\n\n\n  if (typeof request.salt !== 'undefined' && !validator.isString(request.salt)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_SALT);\n  } // providerUserInfo has to be an array of valid UserInfo requests.\n\n\n  if (typeof request.providerUserInfo !== 'undefined' && !validator.isArray(request.providerUserInfo)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_DATA);\n  } else if (validator.isArray(request.providerUserInfo)) {\n    request.providerUserInfo.forEach(function (providerUserInfoEntry) {\n      validateProviderUserInfo(providerUserInfoEntry);\n    });\n  } // linkProviderUserInfo must be a (single) UserProvider value.\n\n\n  if (typeof request.linkProviderUserInfo !== 'undefined') {\n    validateProviderUserInfo(request.linkProviderUserInfo);\n  } // mfaInfo is used for importUsers.\n  // mfa.enrollments is used for setAccountInfo.\n  // enrollments has to be an array of valid AuthFactorInfo requests.\n\n\n  var enrollments = null;\n\n  if (request.mfaInfo) {\n    enrollments = request.mfaInfo;\n  } else if (request.mfa && request.mfa.enrollments) {\n    enrollments = request.mfa.enrollments;\n  }\n\n  if (enrollments) {\n    if (!validator.isArray(enrollments)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLED_FACTORS);\n    }\n\n    enrollments.forEach(function (authFactorInfoEntry) {\n      validateAuthFactorInfo(authFactorInfoEntry);\n    });\n  }\n}\n/** Instantiates the createSessionCookie endpoint settings. */\n\n\nexports.FIREBASE_AUTH_CREATE_SESSION_COOKIE = new api_request_1.ApiSettings(':createSessionCookie', 'POST') // Set request validator.\n.setRequestValidator(function (request) {\n  // Validate the ID token is a non-empty string.\n  if (!validator.isNonEmptyString(request.idToken)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ID_TOKEN);\n  } // Validate the custom session cookie duration.\n\n\n  if (!validator.isNumber(request.validDuration) || request.validDuration < MIN_SESSION_COOKIE_DURATION_SECS || request.validDuration > MAX_SESSION_COOKIE_DURATION_SECS) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION);\n  }\n}) // Set response validator.\n.setResponseValidator(function (response) {\n  // Response should always contain the session cookie.\n  if (!validator.isNonEmptyString(response.sessionCookie)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR);\n  }\n});\n/** Instantiates the uploadAccount endpoint settings. */\n\nexports.FIREBASE_AUTH_UPLOAD_ACCOUNT = new api_request_1.ApiSettings('/accounts:batchCreate', 'POST');\n/** Instantiates the downloadAccount endpoint settings. */\n\nexports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT = new api_request_1.ApiSettings('/accounts:batchGet', 'GET') // Set request validator.\n.setRequestValidator(function (request) {\n  // Validate next page token.\n  if (typeof request.nextPageToken !== 'undefined' && !validator.isNonEmptyString(request.nextPageToken)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\n  } // Validate max results.\n\n\n  if (!validator.isNumber(request.maxResults) || request.maxResults <= 0 || request.maxResults > MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Required \"maxResults\" must be a positive integer that does not exceed ' + (MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE + \".\"));\n  }\n});\n/** Instantiates the getAccountInfo endpoint settings. */\n\nexports.FIREBASE_AUTH_GET_ACCOUNT_INFO = new api_request_1.ApiSettings('/accounts:lookup', 'POST') // Set request validator.\n.setRequestValidator(function (request) {\n  if (!request.localId && !request.email && !request.phoneNumber && !request.federatedUserId) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');\n  }\n}) // Set response validator.\n.setResponseValidator(function (response) {\n  if (!response.users || !response.users.length) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_NOT_FOUND);\n  }\n});\n/**\n * Instantiates the getAccountInfo endpoint settings for use when fetching info\n * for multiple accounts.\n */\n\nexports.FIREBASE_AUTH_GET_ACCOUNTS_INFO = new api_request_1.ApiSettings('/accounts:lookup', 'POST') // Set request validator.\n.setRequestValidator(function (request) {\n  if (!request.localId && !request.email && !request.phoneNumber && !request.federatedUserId) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');\n  }\n});\n/** Instantiates the deleteAccount endpoint settings. */\n\nexports.FIREBASE_AUTH_DELETE_ACCOUNT = new api_request_1.ApiSettings('/accounts:delete', 'POST') // Set request validator.\n.setRequestValidator(function (request) {\n  if (!request.localId) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');\n  }\n});\nexports.FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS = new api_request_1.ApiSettings('/accounts:batchDelete', 'POST').setRequestValidator(function (request) {\n  if (!request.localIds) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifiers');\n  }\n\n  if (typeof request.force === 'undefined' || request.force !== true) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing force=true field');\n  }\n}).setResponseValidator(function (response) {\n  var errors = response.errors || [];\n  errors.forEach(function (batchDeleteErrorInfo) {\n    if (typeof batchDeleteErrorInfo.index === 'undefined') {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server BatchDeleteAccountResponse is missing an errors.index field');\n    }\n\n    if (!batchDeleteErrorInfo.localId) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server BatchDeleteAccountResponse is missing an errors.localId field');\n    } // Allow the (error) message to be missing/undef.\n\n  });\n});\n/** Instantiates the setAccountInfo endpoint settings for updating existing accounts. */\n\nexports.FIREBASE_AUTH_SET_ACCOUNT_INFO = new api_request_1.ApiSettings('/accounts:update', 'POST') // Set request validator.\n.setRequestValidator(function (request) {\n  // localId is a required parameter.\n  if (typeof request.localId === 'undefined') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');\n  } // Throw error when tenantId is passed in POST body.\n\n\n  if (typeof request.tenantId !== 'undefined') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"tenantId\" is an invalid \"UpdateRequest\" property.');\n  }\n\n  validateCreateEditRequest(request, WriteOperationType.Update);\n}) // Set response validator.\n.setResponseValidator(function (response) {\n  // If the localId is not returned, then the request failed.\n  if (!response.localId) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_NOT_FOUND);\n  }\n});\n/**\n * Instantiates the signupNewUser endpoint settings for creating a new user with or without\n * uid being specified. The backend will create a new one if not provided and return it.\n */\n\nexports.FIREBASE_AUTH_SIGN_UP_NEW_USER = new api_request_1.ApiSettings('/accounts', 'POST') // Set request validator.\n.setRequestValidator(function (request) {\n  // signupNewUser does not support customAttributes.\n  if (typeof request.customAttributes !== 'undefined') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"customAttributes\" cannot be set when creating a new user.');\n  } // signupNewUser does not support validSince.\n\n\n  if (typeof request.validSince !== 'undefined') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"validSince\" cannot be set when creating a new user.');\n  } // Throw error when tenantId is passed in POST body.\n\n\n  if (typeof request.tenantId !== 'undefined') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"tenantId\" is an invalid \"CreateRequest\" property.');\n  }\n\n  validateCreateEditRequest(request, WriteOperationType.Create);\n}) // Set response validator.\n.setResponseValidator(function (response) {\n  // If the localId is not returned, then the request failed.\n  if (!response.localId) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new user');\n  }\n});\nvar FIREBASE_AUTH_GET_OOB_CODE = new api_request_1.ApiSettings('/accounts:sendOobCode', 'POST') // Set request validator.\n.setRequestValidator(function (request) {\n  if (!validator.isEmail(request.email)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);\n  }\n\n  if (exports.EMAIL_ACTION_REQUEST_TYPES.indexOf(request.requestType) === -1) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"\\\"\" + request.requestType + \"\\\" is not a supported email action request type.\");\n  }\n}) // Set response validator.\n.setResponseValidator(function (response) {\n  // If the oobLink is not returned, then the request failed.\n  if (!response.oobLink) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create the email action link');\n  }\n});\n/** Instantiates the retrieve OIDC configuration endpoint settings. */\n\nvar GET_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs/{providerId}', 'GET') // Set response validator.\n.setResponseValidator(function (response) {\n  // Response should always contain the OIDC provider resource name.\n  if (!validator.isNonEmptyString(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to get OIDC configuration');\n  }\n});\n/** Instantiates the delete OIDC configuration endpoint settings. */\n\nvar DELETE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs/{providerId}', 'DELETE');\n/** Instantiates the create OIDC configuration endpoint settings. */\n\nvar CREATE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs?oauthIdpConfigId={providerId}', 'POST') // Set response validator.\n.setResponseValidator(function (response) {\n  // Response should always contain the OIDC provider resource name.\n  if (!validator.isNonEmptyString(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new OIDC configuration');\n  }\n});\n/** Instantiates the update OIDC configuration endpoint settings. */\n\nvar UPDATE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs/{providerId}?updateMask={updateMask}', 'PATCH') // Set response validator.\n.setResponseValidator(function (response) {\n  // Response should always contain the configuration resource name.\n  if (!validator.isNonEmptyString(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update OIDC configuration');\n  }\n});\n/** Instantiates the list OIDC configuration endpoint settings. */\n\nvar LIST_OAUTH_IDP_CONFIGS = new api_request_1.ApiSettings('/oauthIdpConfigs', 'GET') // Set request validator.\n.setRequestValidator(function (request) {\n  // Validate next page token.\n  if (typeof request.pageToken !== 'undefined' && !validator.isNonEmptyString(request.pageToken)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\n  } // Validate max results.\n\n\n  if (!validator.isNumber(request.pageSize) || request.pageSize <= 0 || request.pageSize > MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Required \"maxResults\" must be a positive integer that does not exceed ' + (MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE + \".\"));\n  }\n});\n/** Instantiates the retrieve SAML configuration endpoint settings. */\n\nvar GET_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs/{providerId}', 'GET') // Set response validator.\n.setResponseValidator(function (response) {\n  // Response should always contain the SAML provider resource name.\n  if (!validator.isNonEmptyString(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to get SAML configuration');\n  }\n});\n/** Instantiates the delete SAML configuration endpoint settings. */\n\nvar DELETE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs/{providerId}', 'DELETE');\n/** Instantiates the create SAML configuration endpoint settings. */\n\nvar CREATE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs?inboundSamlConfigId={providerId}', 'POST') // Set response validator.\n.setResponseValidator(function (response) {\n  // Response should always contain the SAML provider resource name.\n  if (!validator.isNonEmptyString(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new SAML configuration');\n  }\n});\n/** Instantiates the update SAML configuration endpoint settings. */\n\nvar UPDATE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs/{providerId}?updateMask={updateMask}', 'PATCH') // Set response validator.\n.setResponseValidator(function (response) {\n  // Response should always contain the configuration resource name.\n  if (!validator.isNonEmptyString(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update SAML configuration');\n  }\n});\n/** Instantiates the list SAML configuration endpoint settings. */\n\nvar LIST_INBOUND_SAML_CONFIGS = new api_request_1.ApiSettings('/inboundSamlConfigs', 'GET') // Set request validator.\n.setRequestValidator(function (request) {\n  // Validate next page token.\n  if (typeof request.pageToken !== 'undefined' && !validator.isNonEmptyString(request.pageToken)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\n  } // Validate max results.\n\n\n  if (!validator.isNumber(request.pageSize) || request.pageSize <= 0 || request.pageSize > MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Required \"maxResults\" must be a positive integer that does not exceed ' + (MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE + \".\"));\n  }\n});\n/**\n * Class that provides the mechanism to send requests to the Firebase Auth backend endpoints.\n */\n\nvar AbstractAuthRequestHandler =\n/** @class */\nfunction () {\n  /**\n   * @param {FirebaseApp} app The app used to fetch access tokens to sign API requests.\n   * @constructor\n   */\n  function AbstractAuthRequestHandler(app) {\n    this.app = app;\n\n    if (typeof app !== 'object' || app === null || !('options' in app)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'First argument passed to admin.auth() must be a valid Firebase app instance.');\n    }\n\n    this.httpClient = new AuthHttpClient(app);\n  }\n  /**\n   * @param {any} response The response to check for errors.\n   * @return {string|null} The error code if present; null otherwise.\n   */\n\n\n  AbstractAuthRequestHandler.getErrorCode = function (response) {\n    return validator.isNonNullObject(response) && response.error && response.error.message || null;\n  };\n\n  AbstractAuthRequestHandler.addUidToRequest = function (id, request) {\n    if (!validator.isUid(id.uid)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID);\n    }\n\n    request.localId ? request.localId.push(id.uid) : request.localId = [id.uid];\n    return request;\n  };\n\n  AbstractAuthRequestHandler.addEmailToRequest = function (id, request) {\n    if (!validator.isEmail(id.email)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);\n    }\n\n    request.email ? request.email.push(id.email) : request.email = [id.email];\n    return request;\n  };\n\n  AbstractAuthRequestHandler.addPhoneToRequest = function (id, request) {\n    if (!validator.isPhoneNumber(id.phoneNumber)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER);\n    }\n\n    request.phoneNumber ? request.phoneNumber.push(id.phoneNumber) : request.phoneNumber = [id.phoneNumber];\n    return request;\n  };\n\n  AbstractAuthRequestHandler.addProviderToRequest = function (id, request) {\n    if (!validator.isNonEmptyString(id.providerId)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID);\n    }\n\n    if (!validator.isNonEmptyString(id.providerUid)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_UID);\n    }\n\n    var federatedUserId = {\n      providerId: id.providerId,\n      rawId: id.providerUid\n    };\n    request.federatedUserId ? request.federatedUserId.push(federatedUserId) : request.federatedUserId = [federatedUserId];\n    return request;\n  };\n  /**\n   * Creates a new Firebase session cookie with the specified duration that can be used for\n   * session management (set as a server side session cookie with custom cookie policy).\n   * The session cookie JWT will have the same payload claims as the provided ID token.\n   *\n   * @param {string} idToken The Firebase ID token to exchange for a session cookie.\n   * @param {number} expiresIn The session cookie duration in milliseconds.\n   *\n   * @return {Promise<string>} A promise that resolves on success with the created session cookie.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.createSessionCookie = function (idToken, expiresIn) {\n    var request = {\n      idToken: idToken,\n      // Convert to seconds.\n      validDuration: expiresIn / 1000\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_CREATE_SESSION_COOKIE, request).then(function (response) {\n      return response.sessionCookie;\n    });\n  };\n  /**\n   * Looks up a user by uid.\n   *\n   * @param {string} uid The uid of the user to lookup.\n   * @return {Promise<object>} A promise that resolves with the user information.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.getAccountInfoByUid = function (uid) {\n    if (!validator.isUid(uid)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\n    }\n\n    var request = {\n      localId: [uid]\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);\n  };\n  /**\n   * Looks up a user by email.\n   *\n   * @param {string} email The email of the user to lookup.\n   * @return {Promise<object>} A promise that resolves with the user information.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.getAccountInfoByEmail = function (email) {\n    if (!validator.isEmail(email)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL));\n    }\n\n    var request = {\n      email: [email]\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);\n  };\n  /**\n   * Looks up a user by phone number.\n   *\n   * @param {string} phoneNumber The phone number of the user to lookup.\n   * @return {Promise<object>} A promise that resolves with the user information.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.getAccountInfoByPhoneNumber = function (phoneNumber) {\n    if (!validator.isPhoneNumber(phoneNumber)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER));\n    }\n\n    var request = {\n      phoneNumber: [phoneNumber]\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);\n  };\n\n  AbstractAuthRequestHandler.prototype.getAccountInfoByFederatedUid = function (providerId, rawId) {\n    if (!validator.isNonEmptyString(providerId) || !validator.isNonEmptyString(rawId)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID);\n    }\n\n    var request = {\n      federatedUserId: [{\n        providerId: providerId,\n        rawId: rawId\n      }]\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);\n  };\n  /**\n   * Looks up multiple users by their identifiers (uid, email, etc).\n   *\n   * @param {UserIdentifier[]} identifiers The identifiers indicating the users\n   *     to be looked up. Must have <= 100 entries.\n   * @param {Promise<object>} A promise that resolves with the set of successfully\n   *     looked up users. Possibly empty if no users were looked up.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.getAccountInfoByIdentifiers = function (identifiers) {\n    if (identifiers.length === 0) {\n      return Promise.resolve({\n        users: []\n      });\n    } else if (identifiers.length > MAX_GET_ACCOUNTS_BATCH_SIZE) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, '`identifiers` parameter must have <= ' + MAX_GET_ACCOUNTS_BATCH_SIZE + ' entries.');\n    }\n\n    var request = {};\n\n    for (var _i = 0, identifiers_1 = identifiers; _i < identifiers_1.length; _i++) {\n      var id = identifiers_1[_i];\n\n      if (identifier_1.isUidIdentifier(id)) {\n        request = AbstractAuthRequestHandler.addUidToRequest(id, request);\n      } else if (identifier_1.isEmailIdentifier(id)) {\n        request = AbstractAuthRequestHandler.addEmailToRequest(id, request);\n      } else if (identifier_1.isPhoneIdentifier(id)) {\n        request = AbstractAuthRequestHandler.addPhoneToRequest(id, request);\n      } else if (identifier_1.isProviderIdentifier(id)) {\n        request = AbstractAuthRequestHandler.addProviderToRequest(id, request);\n      } else {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Unrecognized identifier: ' + id);\n      }\n    }\n\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNTS_INFO, request);\n  };\n  /**\n   * Exports the users (single batch only) with a size of maxResults and starting from\n   * the offset as specified by pageToken.\n   *\n   * @param {number=} maxResults The page size, 1000 if undefined. This is also the maximum\n   *     allowed limit.\n   * @param {string=} pageToken The next page token. If not specified, returns users starting\n   *     without any offset. Users are returned in the order they were created from oldest to\n   *     newest, relative to the page token offset.\n   * @return {Promise<object>} A promise that resolves with the current batch of downloaded\n   *     users and the next page token if available. For the last page, an empty list of users\n   *     and no page token are returned.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.downloadAccount = function (maxResults, pageToken) {\n    if (maxResults === void 0) {\n      maxResults = MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE;\n    } // Construct request.\n\n\n    var request = {\n      maxResults: maxResults,\n      nextPageToken: pageToken\n    }; // Remove next page token if not provided.\n\n    if (typeof request.nextPageToken === 'undefined') {\n      delete request.nextPageToken;\n    }\n\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT, request).then(function (response) {\n      // No more users available.\n      if (!response.users) {\n        response.users = [];\n      }\n\n      return response;\n    });\n  };\n  /**\n   * Imports the list of users provided to Firebase Auth. This is useful when\n   * migrating from an external authentication system without having to use the Firebase CLI SDK.\n   * At most, 1000 users are allowed to be imported one at a time.\n   * When importing a list of password users, UserImportOptions are required to be specified.\n   *\n   * @param {UserImportRecord[]} users The list of user records to import to Firebase Auth.\n   * @param {UserImportOptions=} options The user import options, required when the users provided\n   *     include password credentials.\n   * @return {Promise<UserImportResult>} A promise that resolves when the operation completes\n   *     with the result of the import. This includes the number of successful imports, the number\n   *     of failed uploads and their corresponding errors.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.uploadAccount = function (users, options) {\n    // This will throw if any error is detected in the hash options.\n    // For errors in the list of users, this will not throw and will report the errors and the\n    // corresponding user index in the user import generated response below.\n    // No need to validate raw request or raw response as this is done in UserImportBuilder.\n    var userImportBuilder = new user_import_builder_1.UserImportBuilder(users, options, function (userRequest) {\n      // Pass true to validate the uploadAccount specific fields.\n      validateCreateEditRequest(userRequest, WriteOperationType.Upload);\n    });\n    var request = userImportBuilder.buildRequest(); // Fail quickly if more users than allowed are to be imported.\n\n    if (validator.isArray(users) && users.length > MAX_UPLOAD_ACCOUNT_BATCH_SIZE) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, \"A maximum of \" + MAX_UPLOAD_ACCOUNT_BATCH_SIZE + \" users can be imported at once.\");\n    } // If no remaining user in request after client side processing, there is no need\n    // to send the request to the server.\n\n\n    if (!request.users || request.users.length === 0) {\n      return Promise.resolve(userImportBuilder.buildResponse([]));\n    }\n\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_UPLOAD_ACCOUNT, request).then(function (response) {\n      // No error object is returned if no error encountered.\n      var failedUploads = response.error || []; // Rewrite response as UserImportResult and re-insert client previously detected errors.\n\n      return userImportBuilder.buildResponse(failedUploads);\n    });\n  };\n  /**\n   * Deletes an account identified by a uid.\n   *\n   * @param {string} uid The uid of the user to delete.\n   * @return {Promise<object>} A promise that resolves when the user is deleted.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.deleteAccount = function (uid) {\n    if (!validator.isUid(uid)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\n    }\n\n    var request = {\n      localId: uid\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_DELETE_ACCOUNT, request);\n  };\n\n  AbstractAuthRequestHandler.prototype.deleteAccounts = function (uids, force) {\n    if (uids.length === 0) {\n      return Promise.resolve({});\n    } else if (uids.length > MAX_DELETE_ACCOUNTS_BATCH_SIZE) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, '`uids` parameter must have <= ' + MAX_DELETE_ACCOUNTS_BATCH_SIZE + ' entries.');\n    }\n\n    var request = {\n      localIds: [],\n      force: force\n    };\n    uids.forEach(function (uid) {\n      if (!validator.isUid(uid)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID);\n      }\n\n      request.localIds.push(uid);\n    });\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS, request);\n  };\n  /**\n   * Sets additional developer claims on an existing user identified by provided UID.\n   *\n   * @param {string} uid The user to edit.\n   * @param {object} customUserClaims The developer claims to set.\n   * @return {Promise<string>} A promise that resolves when the operation completes\n   *     with the user id that was edited.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.setCustomUserClaims = function (uid, customUserClaims) {\n    // Validate user UID.\n    if (!validator.isUid(uid)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\n    } else if (!validator.isObject(customUserClaims)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'CustomUserClaims argument must be an object or null.'));\n    } // Delete operation. Replace null with an empty object.\n\n\n    if (customUserClaims === null) {\n      customUserClaims = {};\n    } // Construct custom user attribute editting request.\n\n\n    var request = {\n      localId: uid,\n      customAttributes: JSON.stringify(customUserClaims)\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request).then(function (response) {\n      return response.localId;\n    });\n  };\n  /**\n   * Edits an existing user.\n   *\n   * @param {string} uid The user to edit.\n   * @param {object} properties The properties to set on the user.\n   * @return {Promise<string>} A promise that resolves when the operation completes\n   *     with the user id that was edited.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.updateExistingAccount = function (uid, properties) {\n    if (!validator.isUid(uid)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\n    } else if (!validator.isNonNullObject(properties)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Properties argument must be a non-null object.'));\n    } else if (validator.isNonNullObject(properties.providerToLink)) {\n      // TODO(rsgowman): These checks overlap somewhat with\n      // validateProviderUserInfo. It may be possible to refactor a bit.\n      if (!validator.isNonEmptyString(properties.providerToLink.providerId)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'providerToLink.providerId of properties argument must be a non-empty string.');\n      }\n\n      if (!validator.isNonEmptyString(properties.providerToLink.uid)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'providerToLink.uid of properties argument must be a non-empty string.');\n      }\n    } else if (typeof properties.providersToUnlink !== 'undefined') {\n      if (!validator.isArray(properties.providersToUnlink)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'providersToUnlink of properties argument must be an array of strings.');\n      }\n\n      properties.providersToUnlink.forEach(function (providerId) {\n        if (!validator.isNonEmptyString(providerId)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'providersToUnlink of properties argument must be an array of strings.');\n        }\n      });\n    } // Build the setAccountInfo request.\n\n\n    var request = deep_copy_1.deepCopy(properties);\n    request.localId = uid; // For deleting displayName or photoURL, these values must be passed as null.\n    // They will be removed from the backend request and an additional parameter\n    // deleteAttribute: ['PHOTO_URL', 'DISPLAY_NAME']\n    // with an array of the parameter names to delete will be passed.\n    // Parameters that are deletable and their deleteAttribute names.\n    // Use client facing names, photoURL instead of photoUrl.\n\n    var deletableParams = {\n      displayName: 'DISPLAY_NAME',\n      photoURL: 'PHOTO_URL'\n    }; // Properties to delete if available.\n\n    request.deleteAttribute = [];\n\n    for (var key in deletableParams) {\n      if (request[key] === null) {\n        // Add property identifier to list of attributes to delete.\n        request.deleteAttribute.push(deletableParams[key]); // Remove property from request.\n\n        delete request[key];\n      }\n    }\n\n    if (request.deleteAttribute.length === 0) {\n      delete request.deleteAttribute;\n    } // For deleting phoneNumber, this value must be passed as null.\n    // It will be removed from the backend request and an additional parameter\n    // deleteProvider: ['phone'] with an array of providerIds (phone in this case),\n    // will be passed.\n\n\n    if (request.phoneNumber === null) {\n      request.deleteProvider ? request.deleteProvider.push('phone') : request.deleteProvider = ['phone'];\n      delete request.phoneNumber;\n    }\n\n    if (typeof request.providerToLink !== 'undefined') {\n      request.linkProviderUserInfo = deep_copy_1.deepCopy(request.providerToLink);\n      delete request.providerToLink;\n      request.linkProviderUserInfo.rawId = request.linkProviderUserInfo.uid;\n      delete request.linkProviderUserInfo.uid;\n    }\n\n    if (typeof request.providersToUnlink !== 'undefined') {\n      if (!validator.isArray(request.deleteProvider)) {\n        request.deleteProvider = [];\n      }\n\n      request.deleteProvider = request.deleteProvider.concat(request.providersToUnlink);\n      delete request.providersToUnlink;\n    } // Rewrite photoURL to photoUrl.\n\n\n    if (typeof request.photoURL !== 'undefined') {\n      request.photoUrl = request.photoURL;\n      delete request.photoURL;\n    } // Rewrite disabled to disableUser.\n\n\n    if (typeof request.disabled !== 'undefined') {\n      request.disableUser = request.disabled;\n      delete request.disabled;\n    } // Construct mfa related user data.\n\n\n    if (validator.isNonNullObject(request.multiFactor)) {\n      if (request.multiFactor.enrolledFactors === null) {\n        // Remove all second factors.\n        request.mfa = {};\n      } else if (validator.isArray(request.multiFactor.enrolledFactors)) {\n        request.mfa = {\n          enrollments: []\n        };\n\n        try {\n          request.multiFactor.enrolledFactors.forEach(function (multiFactorInfo) {\n            request.mfa.enrollments.push(user_import_builder_1.convertMultiFactorInfoToServerFormat(multiFactorInfo));\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n\n        if (request.mfa.enrollments.length === 0) {\n          delete request.mfa.enrollments;\n        }\n      }\n\n      delete request.multiFactor;\n    }\n\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request).then(function (response) {\n      return response.localId;\n    });\n  };\n  /**\n   * Revokes all refresh tokens for the specified user identified by the uid provided.\n   * In addition to revoking all refresh tokens for a user, all ID tokens issued\n   * before revocation will also be revoked on the Auth backend. Any request with an\n   * ID token generated before revocation will be rejected with a token expired error.\n   * Note that due to the fact that the timestamp is stored in seconds, any tokens minted in\n   * the same second as the revocation will still be valid. If there is a chance that a token\n   * was minted in the last second, delay for 1 second before revoking.\n   *\n   * @param {string} uid The user whose tokens are to be revoked.\n   * @return {Promise<string>} A promise that resolves when the operation completes\n   *     successfully with the user id of the corresponding user.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.revokeRefreshTokens = function (uid) {\n    // Validate user UID.\n    if (!validator.isUid(uid)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\n    }\n\n    var request = {\n      localId: uid,\n      // validSince is in UTC seconds.\n      validSince: Math.floor(new Date().getTime() / 1000)\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request).then(function (response) {\n      return response.localId;\n    });\n  };\n  /**\n   * Create a new user with the properties supplied.\n   *\n   * @param {object} properties The properties to set on the user.\n   * @return {Promise<string>} A promise that resolves when the operation completes\n   *     with the user id that was created.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.createNewAccount = function (properties) {\n    if (!validator.isNonNullObject(properties)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Properties argument must be a non-null object.'));\n    }\n\n    var request = deep_copy_1.deepCopy(properties); // Rewrite photoURL to photoUrl.\n\n    if (typeof request.photoURL !== 'undefined') {\n      request.photoUrl = request.photoURL;\n      delete request.photoURL;\n    } // Rewrite uid to localId if it exists.\n\n\n    if (typeof request.uid !== 'undefined') {\n      request.localId = request.uid;\n      delete request.uid;\n    } // Construct mfa related user data.\n\n\n    if (validator.isNonNullObject(request.multiFactor)) {\n      if (validator.isNonEmptyArray(request.multiFactor.enrolledFactors)) {\n        var mfaInfo_1 = [];\n\n        try {\n          request.multiFactor.enrolledFactors.forEach(function (multiFactorInfo) {\n            // Enrollment time and uid are not allowed for signupNewUser endpoint.\n            // They will automatically be provisioned server side.\n            if ('enrollmentTime' in multiFactorInfo) {\n              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"enrollmentTime\" is not supported when adding second factors via \"createUser()\"');\n            } else if ('uid' in multiFactorInfo) {\n              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"uid\" is not supported when adding second factors via \"createUser()\"');\n            }\n\n            mfaInfo_1.push(user_import_builder_1.convertMultiFactorInfoToServerFormat(multiFactorInfo));\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n\n        request.mfaInfo = mfaInfo_1;\n      }\n\n      delete request.multiFactor;\n    }\n\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SIGN_UP_NEW_USER, request).then(function (response) {\n      // Return the user id.\n      return response.localId;\n    });\n  };\n  /**\n   * Generates the out of band email action link for the email specified using the action code settings provided.\n   * Returns a promise that resolves with the generated link.\n   *\n   * @param {string} requestType The request type. This could be either used for password reset,\n   *     email verification, email link sign-in.\n   * @param {string} email The email of the user the link is being sent to.\n   * @param {ActionCodeSettings=} actionCodeSettings The optional action code setings which defines whether\n   *     the link is to be handled by a mobile app and the additional state information to be passed in the\n   *     deep link, etc. Required when requestType == 'EMAIL_SIGNIN'\n   * @return {Promise<string>} A promise that resolves with the email action link.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.getEmailActionLink = function (requestType, email, actionCodeSettings) {\n    var request = {\n      requestType: requestType,\n      email: email,\n      returnOobLink: true\n    }; // ActionCodeSettings required for email link sign-in to determine the url where the sign-in will\n    // be completed.\n\n    if (typeof actionCodeSettings === 'undefined' && requestType === 'EMAIL_SIGNIN') {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"`actionCodeSettings` is required when `requestType` === 'EMAIL_SIGNIN'\"));\n    }\n\n    if (typeof actionCodeSettings !== 'undefined' || requestType === 'EMAIL_SIGNIN') {\n      try {\n        var builder = new action_code_settings_builder_1.ActionCodeSettingsBuilder(actionCodeSettings);\n        request = deep_copy_1.deepExtend(request, builder.buildRequest());\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }\n\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), FIREBASE_AUTH_GET_OOB_CODE, request).then(function (response) {\n      // Return the link.\n      return response.oobLink;\n    });\n  };\n  /**\n   * Looks up an OIDC provider configuration by provider ID.\n   *\n   * @param {string} providerId The provider identifier of the configuration to lookup.\n   * @return {Promise<OIDCConfigServerResponse>} A promise that resolves with the provider configuration information.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.getOAuthIdpConfig = function (providerId) {\n    if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    }\n\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), GET_OAUTH_IDP_CONFIG, {}, {\n      providerId: providerId\n    });\n  };\n  /**\n   * Lists the OIDC configurations (single batch only) with a size of maxResults and starting from\n   * the offset as specified by pageToken.\n   *\n   * @param {number=} maxResults The page size, 100 if undefined. This is also the maximum\n   *     allowed limit.\n   * @param {string=} pageToken The next page token. If not specified, returns OIDC configurations\n   *     without any offset. Configurations are returned in the order they were created from oldest to\n   *     newest, relative to the page token offset.\n   * @return {Promise<object>} A promise that resolves with the current batch of downloaded\n   *     OIDC configurations and the next page token if available. For the last page, an empty list of provider\n   *     configuration and no page token are returned.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.listOAuthIdpConfigs = function (maxResults, pageToken) {\n    if (maxResults === void 0) {\n      maxResults = MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE;\n    }\n\n    var request = {\n      pageSize: maxResults\n    }; // Add next page token if provided.\n\n    if (typeof pageToken !== 'undefined') {\n      request.pageToken = pageToken;\n    }\n\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), LIST_OAUTH_IDP_CONFIGS, request).then(function (response) {\n      if (!response.oauthIdpConfigs) {\n        response.oauthIdpConfigs = [];\n        delete response.nextPageToken;\n      }\n\n      return response;\n    });\n  };\n  /**\n   * Deletes an OIDC configuration identified by a providerId.\n   *\n   * @param {string} providerId The identifier of the OIDC configuration to delete.\n   * @return {Promise<void>} A promise that resolves when the OIDC provider is deleted.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.deleteOAuthIdpConfig = function (providerId) {\n    if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    }\n\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), DELETE_OAUTH_IDP_CONFIG, {}, {\n      providerId: providerId\n    }).then(function () {// Return nothing.\n    });\n  };\n  /**\n   * Creates a new OIDC provider configuration with the properties provided.\n   *\n   * @param {AuthProviderConfig} options The properties to set on the new OIDC provider configuration to be created.\n   * @return {Promise<OIDCConfigServerResponse>} A promise that resolves with the newly created OIDC\n   *     configuration.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.createOAuthIdpConfig = function (options) {\n    // Construct backend request.\n    var request;\n\n    try {\n      request = auth_config_1.OIDCConfig.buildServerRequest(options) || {};\n    } catch (e) {\n      return Promise.reject(e);\n    }\n\n    var providerId = options.providerId;\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), CREATE_OAUTH_IDP_CONFIG, request, {\n      providerId: providerId\n    }).then(function (response) {\n      if (!auth_config_1.OIDCConfig.getProviderIdFromResourceName(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new OIDC provider configuration');\n      }\n\n      return response;\n    });\n  };\n  /**\n   * Updates an existing OIDC provider configuration with the properties provided.\n   *\n   * @param {string} providerId The provider identifier of the OIDC configuration to update.\n   * @param {OIDCUpdateAuthProviderRequest} options The properties to update on the existing configuration.\n   * @return {Promise<OIDCConfigServerResponse>} A promise that resolves with the modified provider\n   *     configuration.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.updateOAuthIdpConfig = function (providerId, options) {\n    if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    } // Construct backend request.\n\n\n    var request;\n\n    try {\n      request = auth_config_1.OIDCConfig.buildServerRequest(options, true) || {};\n    } catch (e) {\n      return Promise.reject(e);\n    }\n\n    var updateMask = utils.generateUpdateMask(request);\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), UPDATE_OAUTH_IDP_CONFIG, request, {\n      providerId: providerId,\n      updateMask: updateMask.join(',')\n    }).then(function (response) {\n      if (!auth_config_1.OIDCConfig.getProviderIdFromResourceName(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update OIDC provider configuration');\n      }\n\n      return response;\n    });\n  };\n  /**\n   * Looks up an SAML provider configuration by provider ID.\n   *\n   * @param {string} providerId The provider identifier of the configuration to lookup.\n   * @return {Promise<SAMLConfigServerResponse>} A promise that resolves with the provider configuration information.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.getInboundSamlConfig = function (providerId) {\n    if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    }\n\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), GET_INBOUND_SAML_CONFIG, {}, {\n      providerId: providerId\n    });\n  };\n  /**\n   * Lists the SAML configurations (single batch only) with a size of maxResults and starting from\n   * the offset as specified by pageToken.\n   *\n   * @param {number=} maxResults The page size, 100 if undefined. This is also the maximum\n   *     allowed limit.\n   * @param {string=} pageToken The next page token. If not specified, returns SAML configurations starting\n   *     without any offset. Configurations are returned in the order they were created from oldest to\n   *     newest, relative to the page token offset.\n   * @return {Promise<object>} A promise that resolves with the current batch of downloaded\n   *     SAML configurations and the next page token if available. For the last page, an empty list of provider\n   *     configuration and no page token are returned.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.listInboundSamlConfigs = function (maxResults, pageToken) {\n    if (maxResults === void 0) {\n      maxResults = MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE;\n    }\n\n    var request = {\n      pageSize: maxResults\n    }; // Add next page token if provided.\n\n    if (typeof pageToken !== 'undefined') {\n      request.pageToken = pageToken;\n    }\n\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), LIST_INBOUND_SAML_CONFIGS, request).then(function (response) {\n      if (!response.inboundSamlConfigs) {\n        response.inboundSamlConfigs = [];\n        delete response.nextPageToken;\n      }\n\n      return response;\n    });\n  };\n  /**\n   * Deletes a SAML configuration identified by a providerId.\n   *\n   * @param {string} providerId The identifier of the SAML configuration to delete.\n   * @return {Promise<void>} A promise that resolves when the SAML provider is deleted.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.deleteInboundSamlConfig = function (providerId) {\n    if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    }\n\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), DELETE_INBOUND_SAML_CONFIG, {}, {\n      providerId: providerId\n    }).then(function () {// Return nothing.\n    });\n  };\n  /**\n   * Creates a new SAML provider configuration with the properties provided.\n   *\n   * @param {AuthProviderConfig} options The properties to set on the new SAML provider configuration to be created.\n   * @return {Promise<SAMLConfigServerResponse>} A promise that resolves with the newly created SAML\n   *     configuration.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.createInboundSamlConfig = function (options) {\n    // Construct backend request.\n    var request;\n\n    try {\n      request = auth_config_1.SAMLConfig.buildServerRequest(options) || {};\n    } catch (e) {\n      return Promise.reject(e);\n    }\n\n    var providerId = options.providerId;\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), CREATE_INBOUND_SAML_CONFIG, request, {\n      providerId: providerId\n    }).then(function (response) {\n      if (!auth_config_1.SAMLConfig.getProviderIdFromResourceName(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new SAML provider configuration');\n      }\n\n      return response;\n    });\n  };\n  /**\n   * Updates an existing SAML provider configuration with the properties provided.\n   *\n   * @param {string} providerId The provider identifier of the SAML configuration to update.\n   * @param {SAMLUpdateAuthProviderRequest} options The properties to update on the existing configuration.\n   * @return {Promise<SAMLConfigServerResponse>} A promise that resolves with the modified provider\n   *     configuration.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.updateInboundSamlConfig = function (providerId, options) {\n    if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    } // Construct backend request.\n\n\n    var request;\n\n    try {\n      request = auth_config_1.SAMLConfig.buildServerRequest(options, true) || {};\n    } catch (e) {\n      return Promise.reject(e);\n    }\n\n    var updateMask = utils.generateUpdateMask(request);\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), UPDATE_INBOUND_SAML_CONFIG, request, {\n      providerId: providerId,\n      updateMask: updateMask.join(',')\n    }).then(function (response) {\n      if (!auth_config_1.SAMLConfig.getProviderIdFromResourceName(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update SAML provider configuration');\n      }\n\n      return response;\n    });\n  };\n  /**\n   * Invokes the request handler based on the API settings object passed.\n   *\n   * @param {AuthResourceUrlBuilder} urlBuilder The URL builder for Auth endpoints.\n   * @param {ApiSettings} apiSettings The API endpoint settings to apply to request and response.\n   * @param {object} requestData The request data.\n   * @param {object=} additionalResourceParams Additional resource related params if needed.\n   * @return {Promise<object>} A promise that resolves with the response.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.invokeRequestHandler = function (urlBuilder, apiSettings, requestData, additionalResourceParams) {\n    var _this = this;\n\n    return urlBuilder.getUrl(apiSettings.getEndpoint(), additionalResourceParams).then(function (url) {\n      // Validate request.\n      var requestValidator = apiSettings.getRequestValidator();\n      requestValidator(requestData); // Process request.\n\n      var req = {\n        method: apiSettings.getHttpMethod(),\n        url: url,\n        headers: FIREBASE_AUTH_HEADER,\n        data: requestData,\n        timeout: FIREBASE_AUTH_TIMEOUT\n      };\n      return _this.httpClient.send(req);\n    }).then(function (response) {\n      // Validate response.\n      var responseValidator = apiSettings.getResponseValidator();\n      responseValidator(response.data); // Return entire response.\n\n      return response.data;\n    }).catch(function (err) {\n      if (err instanceof api_request_1.HttpError) {\n        var error = err.response.data;\n        var errorCode = AbstractAuthRequestHandler.getErrorCode(error);\n\n        if (!errorCode) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Error returned from server: ' + error + '. Additionally, an ' + 'internal error occurred while attempting to extract the ' + 'errorcode from the error.');\n        }\n\n        throw error_1.FirebaseAuthError.fromServerError(errorCode,\n        /* message */\n        undefined, error);\n      }\n\n      throw err;\n    });\n  };\n  /**\n   * @return {AuthResourceUrlBuilder} The current Auth user management resource URL builder.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.getAuthUrlBuilder = function () {\n    if (!this.authUrlBuilder) {\n      this.authUrlBuilder = this.newAuthUrlBuilder();\n    }\n\n    return this.authUrlBuilder;\n  };\n  /**\n   * @return {AuthResourceUrlBuilder} The current project config resource URL builder.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.getProjectConfigUrlBuilder = function () {\n    if (!this.projectConfigUrlBuilder) {\n      this.projectConfigUrlBuilder = this.newProjectConfigUrlBuilder();\n    }\n\n    return this.projectConfigUrlBuilder;\n  };\n\n  return AbstractAuthRequestHandler;\n}();\n\nexports.AbstractAuthRequestHandler = AbstractAuthRequestHandler;\n/** Instantiates the getTenant endpoint settings. */\n\nvar GET_TENANT = new api_request_1.ApiSettings('/tenants/{tenantId}', 'GET') // Set response validator.\n.setResponseValidator(function (response) {\n  // Response should always contain at least the tenant name.\n  if (!validator.isNonEmptyString(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to get tenant');\n  }\n});\n/** Instantiates the deleteTenant endpoint settings. */\n\nvar DELETE_TENANT = new api_request_1.ApiSettings('/tenants/{tenantId}', 'DELETE');\n/** Instantiates the updateTenant endpoint settings. */\n\nvar UPDATE_TENANT = new api_request_1.ApiSettings('/tenants/{tenantId}?updateMask={updateMask}', 'PATCH') // Set response validator.\n.setResponseValidator(function (response) {\n  // Response should always contain at least the tenant name.\n  if (!validator.isNonEmptyString(response.name) || !tenant_1.Tenant.getTenantIdFromResourceName(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update tenant');\n  }\n});\n/** Instantiates the listTenants endpoint settings. */\n\nvar LIST_TENANTS = new api_request_1.ApiSettings('/tenants', 'GET') // Set request validator.\n.setRequestValidator(function (request) {\n  // Validate next page token.\n  if (typeof request.pageToken !== 'undefined' && !validator.isNonEmptyString(request.pageToken)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\n  } // Validate max results.\n\n\n  if (!validator.isNumber(request.pageSize) || request.pageSize <= 0 || request.pageSize > MAX_LIST_TENANT_PAGE_SIZE) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Required \"maxResults\" must be a positive non-zero number that does not exceed ' + (\"the allowed \" + MAX_LIST_TENANT_PAGE_SIZE + \".\"));\n  }\n});\n/** Instantiates the createTenant endpoint settings. */\n\nvar CREATE_TENANT = new api_request_1.ApiSettings('/tenants', 'POST') // Set response validator.\n.setResponseValidator(function (response) {\n  // Response should always contain at least the tenant name.\n  if (!validator.isNonEmptyString(response.name) || !tenant_1.Tenant.getTenantIdFromResourceName(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new tenant');\n  }\n});\n/**\n * Utility for sending requests to Auth server that are Auth instance related. This includes user and\n * tenant management related APIs. This extends the BaseFirebaseAuthRequestHandler class and defines\n * additional tenant management related APIs.\n */\n\nvar AuthRequestHandler =\n/** @class */\nfunction (_super) {\n  __extends(AuthRequestHandler, _super);\n  /**\n   * The FirebaseAuthRequestHandler constructor used to initialize an instance using a FirebaseApp.\n   *\n   * @param {FirebaseApp} app The app used to fetch access tokens to sign API requests.\n   * @constructor.\n   */\n\n\n  function AuthRequestHandler(app) {\n    var _this = _super.call(this, app) || this;\n\n    _this.tenantMgmtResourceBuilder = new AuthResourceUrlBuilder(app, 'v2');\n    return _this;\n  }\n  /**\n   * @return {AuthResourceUrlBuilder} A new Auth user management resource URL builder instance.\n   */\n\n\n  AuthRequestHandler.prototype.newAuthUrlBuilder = function () {\n    return new AuthResourceUrlBuilder(this.app, 'v1');\n  };\n  /**\n   * @return {AuthResourceUrlBuilder} A new project config resource URL builder instance.\n   */\n\n\n  AuthRequestHandler.prototype.newProjectConfigUrlBuilder = function () {\n    return new AuthResourceUrlBuilder(this.app, 'v2');\n  };\n  /**\n   * Looks up a tenant by tenant ID.\n   *\n   * @param {string} tenantId The tenant identifier of the tenant to lookup.\n   * @return {Promise<TenantServerResponse>} A promise that resolves with the tenant information.\n   */\n\n\n  AuthRequestHandler.prototype.getTenant = function (tenantId) {\n    if (!validator.isNonEmptyString(tenantId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));\n    }\n\n    return this.invokeRequestHandler(this.tenantMgmtResourceBuilder, GET_TENANT, {}, {\n      tenantId: tenantId\n    }).then(function (response) {\n      return response;\n    });\n  };\n  /**\n   * Exports the tenants (single batch only) with a size of maxResults and starting from\n   * the offset as specified by pageToken.\n   *\n   * @param {number=} maxResults The page size, 1000 if undefined. This is also the maximum\n   *     allowed limit.\n   * @param {string=} pageToken The next page token. If not specified, returns tenants starting\n   *     without any offset. Tenants are returned in the order they were created from oldest to\n   *     newest, relative to the page token offset.\n   * @return {Promise<object>} A promise that resolves with the current batch of downloaded\n   *     tenants and the next page token if available. For the last page, an empty list of tenants\n   *     and no page token are returned.\n   */\n\n\n  AuthRequestHandler.prototype.listTenants = function (maxResults, pageToken) {\n    if (maxResults === void 0) {\n      maxResults = MAX_LIST_TENANT_PAGE_SIZE;\n    }\n\n    var request = {\n      pageSize: maxResults,\n      pageToken: pageToken\n    }; // Remove next page token if not provided.\n\n    if (typeof request.pageToken === 'undefined') {\n      delete request.pageToken;\n    }\n\n    return this.invokeRequestHandler(this.tenantMgmtResourceBuilder, LIST_TENANTS, request).then(function (response) {\n      if (!response.tenants) {\n        response.tenants = [];\n        delete response.nextPageToken;\n      }\n\n      return response;\n    });\n  };\n  /**\n   * Deletes a tenant identified by a tenantId.\n   *\n   * @param {string} tenantId The identifier of the tenant to delete.\n   * @return {Promise<void>} A promise that resolves when the tenant is deleted.\n   */\n\n\n  AuthRequestHandler.prototype.deleteTenant = function (tenantId) {\n    if (!validator.isNonEmptyString(tenantId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));\n    }\n\n    return this.invokeRequestHandler(this.tenantMgmtResourceBuilder, DELETE_TENANT, {}, {\n      tenantId: tenantId\n    }).then(function () {// Return nothing.\n    });\n  };\n  /**\n   * Creates a new tenant with the properties provided.\n   *\n   * @param {TenantOptions} tenantOptions The properties to set on the new tenant to be created.\n   * @return {Promise<TenantServerResponse>} A promise that resolves with the newly created tenant object.\n   */\n\n\n  AuthRequestHandler.prototype.createTenant = function (tenantOptions) {\n    try {\n      // Construct backend request.\n      var request = tenant_1.Tenant.buildServerRequest(tenantOptions, true);\n      return this.invokeRequestHandler(this.tenantMgmtResourceBuilder, CREATE_TENANT, request).then(function (response) {\n        return response;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n  /**\n   * Updates an existing tenant with the properties provided.\n   *\n   * @param {string} tenantId The tenant identifier of the tenant to update.\n   * @param {TenantOptions} tenantOptions The properties to update on the existing tenant.\n   * @return {Promise<TenantServerResponse>} A promise that resolves with the modified tenant object.\n   */\n\n\n  AuthRequestHandler.prototype.updateTenant = function (tenantId, tenantOptions) {\n    if (!validator.isNonEmptyString(tenantId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));\n    }\n\n    try {\n      // Construct backend request.\n      var request = tenant_1.Tenant.buildServerRequest(tenantOptions, false); // Do not traverse deep into testPhoneNumbers. The entire content should be replaced\n      // and not just specific phone numbers.\n\n      var updateMask = utils.generateUpdateMask(request, ['testPhoneNumbers']);\n      return this.invokeRequestHandler(this.tenantMgmtResourceBuilder, UPDATE_TENANT, request, {\n        tenantId: tenantId,\n        updateMask: updateMask.join(',')\n      }).then(function (response) {\n        return response;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  return AuthRequestHandler;\n}(AbstractAuthRequestHandler);\n\nexports.AuthRequestHandler = AuthRequestHandler;\n/**\n * Utility for sending requests to Auth server that are tenant Auth instance related. This includes user\n * management related APIs for specified tenants.\n * This extends the BaseFirebaseAuthRequestHandler class.\n */\n\nvar TenantAwareAuthRequestHandler =\n/** @class */\nfunction (_super) {\n  __extends(TenantAwareAuthRequestHandler, _super);\n  /**\n   * The FirebaseTenantRequestHandler constructor used to initialize an instance using a\n   * FirebaseApp and a tenant ID.\n   *\n   * @param {FirebaseApp} app The app used to fetch access tokens to sign API requests.\n   * @param {string} tenantId The request handler's tenant ID.\n   * @constructor\n   */\n\n\n  function TenantAwareAuthRequestHandler(app, tenantId) {\n    var _this = _super.call(this, app) || this;\n\n    _this.tenantId = tenantId;\n    return _this;\n  }\n  /**\n   * @return {AuthResourceUrlBuilder} A new Auth user management resource URL builder instance.\n   */\n\n\n  TenantAwareAuthRequestHandler.prototype.newAuthUrlBuilder = function () {\n    return new TenantAwareAuthResourceUrlBuilder(this.app, 'v1', this.tenantId);\n  };\n  /**\n   * @return {AuthResourceUrlBuilder} A new project config resource URL builder instance.\n   */\n\n\n  TenantAwareAuthRequestHandler.prototype.newProjectConfigUrlBuilder = function () {\n    return new TenantAwareAuthResourceUrlBuilder(this.app, 'v2', this.tenantId);\n  };\n  /**\n   * Imports the list of users provided to Firebase Auth. This is useful when\n   * migrating from an external authentication system without having to use the Firebase CLI SDK.\n   * At most, 1000 users are allowed to be imported one at a time.\n   * When importing a list of password users, UserImportOptions are required to be specified.\n   *\n   * Overrides the superclass methods by adding an additional check to match tenant IDs of\n   * imported user records if present.\n   *\n   * @param {UserImportRecord[]} users The list of user records to import to Firebase Auth.\n   * @param {UserImportOptions=} options The user import options, required when the users provided\n   *     include password credentials.\n   * @return {Promise<UserImportResult>} A promise that resolves when the operation completes\n   *     with the result of the import. This includes the number of successful imports, the number\n   *     of failed uploads and their corresponding errors.\n   */\n\n\n  TenantAwareAuthRequestHandler.prototype.uploadAccount = function (users, options) {\n    var _this = this; // Add additional check to match tenant ID of imported user records.\n\n\n    users.forEach(function (user, index) {\n      if (validator.isNonEmptyString(user.tenantId) && user.tenantId !== _this.tenantId) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID, \"UserRecord of index \\\"\" + index + \"\\\" has mismatching tenant ID \\\"\" + user.tenantId + \"\\\"\");\n      }\n    });\n    return _super.prototype.uploadAccount.call(this, users, options);\n  };\n\n  return TenantAwareAuthRequestHandler;\n}(AbstractAuthRequestHandler);\n\nexports.TenantAwareAuthRequestHandler = TenantAwareAuthRequestHandler;\n\nfunction emulatorHost() {\n  return process.env.FIREBASE_AUTH_EMULATOR_HOST;\n}\n/**\n * When true the SDK should communicate with the Auth Emulator for all API\n * calls and also produce unsigned tokens.\n */\n\n\nfunction useEmulator() {\n  return !!emulatorHost();\n}\n\nexports.useEmulator = useEmulator;","map":null,"metadata":{},"sourceType":"script"}