{"ast":null,"code":"var _objectSpread = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread\");\n\nvar _require = require('../errors'),\n    JWTClaimInvalid = _require.JWTClaimInvalid;\n\nvar secs = require('../help/secs');\n\nvar epoch = require('../help/epoch');\n\nvar isObject = require('../help/is_object');\n\nvar _verify = require('./verify');\n\nvar _require2 = require('./shared_validations'),\n    isString = _require2.isString,\n    isRequired = _require2.isRequired,\n    isTimestamp = _require2.isTimestamp,\n    isStringOrArrayOfStrings = _require2.isStringOrArrayOfStrings;\n\nvar isPayloadRequired = isRequired.bind(undefined, JWTClaimInvalid);\nvar isPayloadString = isString.bind(undefined, JWTClaimInvalid);\nvar isOptionString = isString.bind(undefined, TypeError);\n\nvar defineLazyExportWithWarning = function defineLazyExportWithWarning(obj, property, name, definition) {\n  Object.defineProperty(obj, property, {\n    enumerable: true,\n    configurable: true,\n    value: function value() {\n      process.emitWarning(\"The \".concat(name, \" API implements an IETF draft. Breaking draft implementations are included as minor versions of the jose library, therefore, the ~ semver operator should be used and close attention be payed to library changelog as well as the drafts themselves.\"), 'DraftWarning');\n      Object.defineProperty(obj, property, {\n        enumerable: true,\n        configurable: true,\n        value: definition\n      });\n      return obj[property].apply(obj, arguments);\n    }\n  });\n};\n\nvar validateCommonOptions = function validateCommonOptions(options, profile) {\n  if (!isObject(options)) {\n    throw new TypeError('options must be an object');\n  }\n\n  if (!options.issuer) {\n    throw new TypeError(\"\\\"issuer\\\" option is required to validate \".concat(profile));\n  }\n\n  if (!options.audience) {\n    throw new TypeError(\"\\\"audience\\\" option is required to validate \".concat(profile));\n  }\n};\n\nmodule.exports = {\n  IdToken: {\n    verify: function verify(token, key) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      validateCommonOptions(options, 'an ID Token');\n\n      if ('maxAuthAge' in options) {\n        isOptionString(options.maxAuthAge, 'options.maxAuthAge');\n      }\n\n      if ('nonce' in options) {\n        isOptionString(options.nonce, 'options.nonce');\n      }\n\n      var unix = epoch(options.now || new Date());\n\n      var result = _verify(token, key, _objectSpread({}, options));\n\n      var payload = options.complete ? result.payload : result;\n\n      if (Array.isArray(payload.aud) && payload.aud.length > 1) {\n        isPayloadRequired(payload.azp, '\"azp\" claim', 'azp');\n      }\n\n      isPayloadRequired(payload.iat, '\"iat\" claim', 'iat');\n      isPayloadRequired(payload.sub, '\"sub\" claim', 'sub');\n      isPayloadRequired(payload.exp, '\"exp\" claim', 'exp');\n      isTimestamp(payload.auth_time, 'auth_time', !!options.maxAuthAge);\n      isPayloadString(payload.nonce, '\"nonce\" claim', 'nonce', !!options.nonce);\n      isPayloadString(payload.acr, '\"acr\" claim', 'acr');\n      isStringOrArrayOfStrings(payload.amr, 'amr');\n\n      if (options.nonce && payload.nonce !== options.nonce) {\n        throw new JWTClaimInvalid('unexpected \"nonce\" claim value', 'nonce', 'check_failed');\n      }\n\n      var tolerance = options.clockTolerance ? secs(options.clockTolerance) : 0;\n\n      if (options.maxAuthAge) {\n        var maxAuthAgeSeconds = secs(options.maxAuthAge);\n\n        if (payload.auth_time + maxAuthAgeSeconds < unix - tolerance) {\n          throw new JWTClaimInvalid('\"auth_time\" claim timestamp check failed (too much time has elapsed since the last End-User authentication)', 'auth_time', 'check_failed');\n        }\n      }\n\n      if (Array.isArray(payload.aud) && payload.aud.length > 1 && payload.azp !== options.audience) {\n        throw new JWTClaimInvalid('unexpected \"azp\" claim value', 'azp', 'check_failed');\n      }\n\n      return result;\n    }\n  },\n  LogoutToken: {},\n  AccessToken: {}\n};\ndefineLazyExportWithWarning(module.exports.LogoutToken, 'verify', 'jose.JWT.LogoutToken.verify', function (token, key) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  validateCommonOptions(options, 'a Logout Token');\n\n  var result = _verify(token, key, _objectSpread({}, options));\n\n  var payload = options.complete ? result.payload : result;\n  isPayloadRequired(payload.iat, '\"iat\" claim', 'iat');\n  isPayloadRequired(payload.jti, '\"jti\" claim', 'jti');\n  isPayloadString(payload.sid, '\"sid\" claim', 'sid');\n\n  if (!('sid' in payload) && !('sub' in payload)) {\n    throw new JWTClaimInvalid('either \"sid\" or \"sub\" (or both) claims must be present');\n  }\n\n  if ('nonce' in payload) {\n    throw new JWTClaimInvalid('\"nonce\" claim is prohibited', 'nonce', 'prohibited');\n  }\n\n  if (!('events' in payload)) {\n    throw new JWTClaimInvalid('\"events\" claim is missing', 'events', 'missing');\n  }\n\n  if (!isObject(payload.events)) {\n    throw new JWTClaimInvalid('\"events\" claim must be an object', 'events', 'invalid');\n  }\n\n  if (!('http://schemas.openid.net/event/backchannel-logout' in payload.events)) {\n    throw new JWTClaimInvalid('\"http://schemas.openid.net/event/backchannel-logout\" member is missing in the \"events\" claim', 'events', 'invalid');\n  }\n\n  if (!isObject(payload.events['http://schemas.openid.net/event/backchannel-logout'])) {\n    throw new JWTClaimInvalid('\"http://schemas.openid.net/event/backchannel-logout\" member in the \"events\" claim must be an object', 'events', 'invalid');\n  }\n\n  return result;\n});\ndefineLazyExportWithWarning(module.exports.AccessToken, 'verify', 'jose.JWT.AccessToken.verify', function (token, key) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  validateCommonOptions(options, 'a JWT Access Token');\n  isOptionString(options.maxAuthAge, 'options.maxAuthAge');\n  var unix = epoch(options.now || new Date());\n  var typ = 'at+JWT';\n\n  var result = _verify(token, key, _objectSpread({}, options, {\n    typ: typ\n  }));\n\n  var payload = options.complete ? result.payload : result;\n  isPayloadRequired(payload.iat, '\"iat\" claim', 'iat');\n  isPayloadRequired(payload.exp, '\"exp\" claim', 'exp');\n  isPayloadRequired(payload.sub, '\"sub\" claim', 'sub');\n  isPayloadRequired(payload.jti, '\"jti\" claim', 'jti');\n  isPayloadString(payload.client_id, '\"client_id\" claim', 'client_id', true);\n  isTimestamp(payload.auth_time, 'auth_time', !!options.maxAuthAge);\n  isPayloadString(payload.acr, '\"acr\" claim', 'acr');\n  isStringOrArrayOfStrings(payload.amr, 'amr');\n  var tolerance = options.clockTolerance ? secs(options.clockTolerance) : 0;\n\n  if (options.maxAuthAge) {\n    var maxAuthAgeSeconds = secs(options.maxAuthAge);\n\n    if (payload.auth_time + maxAuthAgeSeconds < unix - tolerance) {\n      throw new JWTClaimInvalid('\"auth_time\" claim timestamp check failed (too much time has elapsed since the last End-User authentication)', 'auth_time', 'check_failed');\n    }\n  }\n\n  return result;\n});","map":null,"metadata":{},"sourceType":"script"}