{"ast":null,"code":"/*! firebase-admin v9.11.0 */\n\"use strict\";\n/*!\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OIDCConfig = exports.SAMLConfig = exports.EmailSignInConfig = exports.validateTestPhoneNumbers = exports.MultiFactorAuthConfig = exports.MAXIMUM_TEST_PHONE_NUMBERS = void 0;\n\nvar validator = require(\"../utils/validator\");\n\nvar deep_copy_1 = require(\"../utils/deep-copy\");\n\nvar error_1 = require(\"../utils/error\");\n/** A maximum of 10 test phone number / code pairs can be configured. */\n\n\nexports.MAXIMUM_TEST_PHONE_NUMBERS = 10;\n/** Client Auth factor type to server auth factor type mapping. */\n\nvar AUTH_FACTOR_CLIENT_TO_SERVER_TYPE = {\n  phone: 'PHONE_SMS'\n};\n/** Server Auth factor type to client auth factor type mapping. */\n\nvar AUTH_FACTOR_SERVER_TO_CLIENT_TYPE = Object.keys(AUTH_FACTOR_CLIENT_TO_SERVER_TYPE).reduce(function (res, key) {\n  res[AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[key]] = key;\n  return res;\n}, {});\n/**\n * Defines the multi-factor config class used to convert client side MultiFactorConfig\n * to a format that is understood by the Auth server.\n */\n\nvar MultiFactorAuthConfig =\n/** @class */\nfunction () {\n  /**\n   * The MultiFactorAuthConfig constructor.\n   *\n   * @param response The server side response used to initialize the\n   *     MultiFactorAuthConfig object.\n   * @constructor\n   */\n  function MultiFactorAuthConfig(response) {\n    var _this = this;\n\n    if (typeof response.state === 'undefined') {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor configuration response');\n    }\n\n    this.state = response.state;\n    this.factorIds = [];\n    (response.enabledProviders || []).forEach(function (enabledProvider) {\n      // Ignore unsupported types. It is possible the current admin SDK version is\n      // not up to date and newer backend types are supported.\n      if (typeof AUTH_FACTOR_SERVER_TO_CLIENT_TYPE[enabledProvider] !== 'undefined') {\n        _this.factorIds.push(AUTH_FACTOR_SERVER_TO_CLIENT_TYPE[enabledProvider]);\n      }\n    });\n  }\n  /**\n   * Static method to convert a client side request to a MultiFactorAuthServerConfig.\n   * Throws an error if validation fails.\n   *\n   * @param options The options object to convert to a server request.\n   * @return The resulting server request.\n   */\n\n\n  MultiFactorAuthConfig.buildServerRequest = function (options) {\n    var request = {};\n    MultiFactorAuthConfig.validate(options);\n\n    if (Object.prototype.hasOwnProperty.call(options, 'state')) {\n      request.state = options.state;\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, 'factorIds')) {\n      (options.factorIds || []).forEach(function (factorId) {\n        if (typeof request.enabledProviders === 'undefined') {\n          request.enabledProviders = [];\n        }\n\n        request.enabledProviders.push(AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[factorId]);\n      }); // In case an empty array is passed. Ensure it gets populated so the array is cleared.\n\n      if (options.factorIds && options.factorIds.length === 0) {\n        request.enabledProviders = [];\n      }\n    }\n\n    return request;\n  };\n  /**\n   * Validates the MultiFactorConfig options object. Throws an error on failure.\n   *\n   * @param options The options object to validate.\n   */\n\n\n  MultiFactorAuthConfig.validate = function (options) {\n    var validKeys = {\n      state: true,\n      factorIds: true\n    };\n\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig\" must be a non-null object.');\n    } // Check for unsupported top level attributes.\n\n\n    for (var key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, \"\\\"\" + key + \"\\\" is not a valid MultiFactorConfig parameter.\");\n      }\n    } // Validate content.\n\n\n    if (typeof options.state !== 'undefined' && options.state !== 'ENABLED' && options.state !== 'DISABLED') {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig.state\" must be either \"ENABLED\" or \"DISABLED\".');\n    }\n\n    if (typeof options.factorIds !== 'undefined') {\n      if (!validator.isArray(options.factorIds)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig.factorIds\" must be an array of valid \"AuthFactorTypes\".');\n      } // Validate content of array.\n\n\n      options.factorIds.forEach(function (factorId) {\n        if (typeof AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[factorId] === 'undefined') {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, \"\\\"\" + factorId + \"\\\" is not a valid \\\"AuthFactorType\\\".\");\n        }\n      });\n    }\n  };\n  /** @return The plain object representation of the multi-factor config instance. */\n\n\n  MultiFactorAuthConfig.prototype.toJSON = function () {\n    return {\n      state: this.state,\n      factorIds: this.factorIds\n    };\n  };\n\n  return MultiFactorAuthConfig;\n}();\n\nexports.MultiFactorAuthConfig = MultiFactorAuthConfig;\n/**\n * Validates the provided map of test phone number / code pairs.\n * @param testPhoneNumbers The phone number / code pairs to validate.\n */\n\nfunction validateTestPhoneNumbers(testPhoneNumbers) {\n  if (!validator.isObject(testPhoneNumbers)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"testPhoneNumbers\" must be a map of phone number / code pairs.');\n  }\n\n  if (Object.keys(testPhoneNumbers).length > exports.MAXIMUM_TEST_PHONE_NUMBERS) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_TEST_PHONE_NUMBER_EXCEEDED);\n  }\n\n  for (var phoneNumber in testPhoneNumbers) {\n    // Validate phone number.\n    if (!validator.isPhoneNumber(phoneNumber)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TESTING_PHONE_NUMBER, \"\\\"\" + phoneNumber + \"\\\" is not a valid E.164 standard compliant phone number.\");\n    } // Validate code.\n\n\n    if (!validator.isString(testPhoneNumbers[phoneNumber]) || !/^[\\d]{6}$/.test(testPhoneNumbers[phoneNumber])) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TESTING_PHONE_NUMBER, \"\\\"\" + testPhoneNumbers[phoneNumber] + \"\\\" is not a valid 6 digit code string.\");\n    }\n  }\n}\n\nexports.validateTestPhoneNumbers = validateTestPhoneNumbers;\n/**\n * Defines the email sign-in config class used to convert client side EmailSignInConfig\n * to a format that is understood by the Auth server.\n */\n\nvar EmailSignInConfig =\n/** @class */\nfunction () {\n  /**\n   * The EmailSignInConfig constructor.\n   *\n   * @param {any} response The server side response used to initialize the\n   *     EmailSignInConfig object.\n   * @constructor\n   */\n  function EmailSignInConfig(response) {\n    if (typeof response.allowPasswordSignup === 'undefined') {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid email sign-in configuration response');\n    }\n\n    this.enabled = response.allowPasswordSignup;\n    this.passwordRequired = !response.enableEmailLinkSignin;\n  }\n  /**\n   * Static method to convert a client side request to a EmailSignInConfigServerRequest.\n   * Throws an error if validation fails.\n   *\n   * @param {any} options The options object to convert to a server request.\n   * @return {EmailSignInConfigServerRequest} The resulting server request.\n   */\n\n\n  EmailSignInConfig.buildServerRequest = function (options) {\n    var request = {};\n    EmailSignInConfig.validate(options);\n\n    if (Object.prototype.hasOwnProperty.call(options, 'enabled')) {\n      request.allowPasswordSignup = options.enabled;\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, 'passwordRequired')) {\n      request.enableEmailLinkSignin = !options.passwordRequired;\n    }\n\n    return request;\n  };\n  /**\n   * Validates the EmailSignInConfig options object. Throws an error on failure.\n   *\n   * @param {any} options The options object to validate.\n   */\n\n\n  EmailSignInConfig.validate = function (options) {\n    // TODO: Validate the request.\n    var validKeys = {\n      enabled: true,\n      passwordRequired: true\n    };\n\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"EmailSignInConfig\" must be a non-null object.');\n    } // Check for unsupported top level attributes.\n\n\n    for (var key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"\\\"\" + key + \"\\\" is not a valid EmailSignInConfig parameter.\");\n      }\n    } // Validate content.\n\n\n    if (typeof options.enabled !== 'undefined' && !validator.isBoolean(options.enabled)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"EmailSignInConfig.enabled\" must be a boolean.');\n    }\n\n    if (typeof options.passwordRequired !== 'undefined' && !validator.isBoolean(options.passwordRequired)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"EmailSignInConfig.passwordRequired\" must be a boolean.');\n    }\n  };\n  /** @return {object} The plain object representation of the email sign-in config. */\n\n\n  EmailSignInConfig.prototype.toJSON = function () {\n    return {\n      enabled: this.enabled,\n      passwordRequired: this.passwordRequired\n    };\n  };\n\n  return EmailSignInConfig;\n}();\n\nexports.EmailSignInConfig = EmailSignInConfig;\n/**\n * Defines the SAMLConfig class used to convert a client side configuration to its\n * server side representation.\n */\n\nvar SAMLConfig =\n/** @class */\nfunction () {\n  /**\n   * The SAMLConfig constructor.\n   *\n   * @param {any} response The server side response used to initialize the SAMLConfig object.\n   * @constructor\n   */\n  function SAMLConfig(response) {\n    if (!response || !response.idpConfig || !response.idpConfig.idpEntityId || !response.idpConfig.ssoUrl || !response.spConfig || !response.spConfig.spEntityId || !response.name || !(validator.isString(response.name) && SAMLConfig.getProviderIdFromResourceName(response.name))) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n    }\n\n    var providerId = SAMLConfig.getProviderIdFromResourceName(response.name);\n\n    if (!providerId) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n    }\n\n    this.providerId = providerId; // RP config.\n\n    this.rpEntityId = response.spConfig.spEntityId;\n    this.callbackURL = response.spConfig.callbackUri; // IdP config.\n\n    this.idpEntityId = response.idpConfig.idpEntityId;\n    this.ssoURL = response.idpConfig.ssoUrl;\n    this.enableRequestSigning = !!response.idpConfig.signRequest;\n    var x509Certificates = [];\n\n    for (var _i = 0, _a = response.idpConfig.idpCertificates || []; _i < _a.length; _i++) {\n      var cert = _a[_i];\n\n      if (cert.x509Certificate) {\n        x509Certificates.push(cert.x509Certificate);\n      }\n    }\n\n    this.x509Certificates = x509Certificates; // When enabled is undefined, it takes its default value of false.\n\n    this.enabled = !!response.enabled;\n    this.displayName = response.displayName;\n  }\n  /**\n   * Converts a client side request to a SAMLConfigServerRequest which is the format\n   * accepted by the backend server.\n   * Throws an error if validation fails. If the request is not a SAMLConfig request,\n   * returns null.\n   *\n   * @param {SAMLAuthProviderRequest} options The options object to convert to a server request.\n   * @param {boolean=} ignoreMissingFields Whether to ignore missing fields.\n   * @return {?SAMLConfigServerRequest} The resulting server request or null if not valid.\n   */\n\n\n  SAMLConfig.buildServerRequest = function (options, ignoreMissingFields) {\n    if (ignoreMissingFields === void 0) {\n      ignoreMissingFields = false;\n    }\n\n    var makeRequest = validator.isNonNullObject(options) && (options.providerId || ignoreMissingFields);\n\n    if (!makeRequest) {\n      return null;\n    }\n\n    var request = {}; // Validate options.\n\n    SAMLConfig.validate(options, ignoreMissingFields);\n    request.enabled = options.enabled;\n    request.displayName = options.displayName; // IdP config.\n\n    if (options.idpEntityId || options.ssoURL || options.x509Certificates) {\n      request.idpConfig = {\n        idpEntityId: options.idpEntityId,\n        ssoUrl: options.ssoURL,\n        signRequest: options.enableRequestSigning,\n        idpCertificates: typeof options.x509Certificates === 'undefined' ? undefined : []\n      };\n\n      if (options.x509Certificates) {\n        for (var _i = 0, _a = options.x509Certificates || []; _i < _a.length; _i++) {\n          var cert = _a[_i];\n          request.idpConfig.idpCertificates.push({\n            x509Certificate: cert\n          });\n        }\n      }\n    } // RP config.\n\n\n    if (options.callbackURL || options.rpEntityId) {\n      request.spConfig = {\n        spEntityId: options.rpEntityId,\n        callbackUri: options.callbackURL\n      };\n    }\n\n    return request;\n  };\n  /**\n   * Returns the provider ID corresponding to the resource name if available.\n   *\n   * @param {string} resourceName The server side resource name.\n   * @return {?string} The provider ID corresponding to the resource, null otherwise.\n   */\n\n\n  SAMLConfig.getProviderIdFromResourceName = function (resourceName) {\n    // name is of form projects/project1/inboundSamlConfigs/providerId1\n    var matchProviderRes = resourceName.match(/\\/inboundSamlConfigs\\/(saml\\..*)$/);\n\n    if (!matchProviderRes || matchProviderRes.length < 2) {\n      return null;\n    }\n\n    return matchProviderRes[1];\n  };\n  /**\n   * @param {any} providerId The provider ID to check.\n   * @return {boolean} Whether the provider ID corresponds to a SAML provider.\n   */\n\n\n  SAMLConfig.isProviderId = function (providerId) {\n    return validator.isNonEmptyString(providerId) && providerId.indexOf('saml.') === 0;\n  };\n  /**\n   * Validates the SAMLConfig options object. Throws an error on failure.\n   *\n   * @param {SAMLAuthProviderRequest} options The options object to validate.\n   * @param {boolean=} ignoreMissingFields Whether to ignore missing fields.\n   */\n\n\n  SAMLConfig.validate = function (options, ignoreMissingFields) {\n    if (ignoreMissingFields === void 0) {\n      ignoreMissingFields = false;\n    }\n\n    var validKeys = {\n      enabled: true,\n      displayName: true,\n      providerId: true,\n      idpEntityId: true,\n      ssoURL: true,\n      x509Certificates: true,\n      rpEntityId: true,\n      callbackURL: true,\n      enableRequestSigning: true\n    };\n\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig\" must be a valid non-null object.');\n    } // Check for unsupported top level attributes.\n\n\n    for (var key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, \"\\\"\" + key + \"\\\" is not a valid SAML config parameter.\");\n      }\n    } // Required fields.\n\n\n    if (validator.isNonEmptyString(options.providerId)) {\n      if (options.providerId.indexOf('saml.') !== 0) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"SAMLAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"saml.\".');\n      }\n    } else if (!ignoreMissingFields) {\n      // providerId is required and not provided correctly.\n      throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"SAMLAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"saml.\".');\n    }\n\n    if (!(ignoreMissingFields && typeof options.idpEntityId === 'undefined') && !validator.isNonEmptyString(options.idpEntityId)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.idpEntityId\" must be a valid non-empty string.');\n    }\n\n    if (!(ignoreMissingFields && typeof options.ssoURL === 'undefined') && !validator.isURL(options.ssoURL)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.ssoURL\" must be a valid URL string.');\n    }\n\n    if (!(ignoreMissingFields && typeof options.rpEntityId === 'undefined') && !validator.isNonEmptyString(options.rpEntityId)) {\n      throw new error_1.FirebaseAuthError(!options.rpEntityId ? error_1.AuthClientErrorCode.MISSING_SAML_RELYING_PARTY_CONFIG : error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.rpEntityId\" must be a valid non-empty string.');\n    }\n\n    if (!(ignoreMissingFields && typeof options.callbackURL === 'undefined') && !validator.isURL(options.callbackURL)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.callbackURL\" must be a valid URL string.');\n    }\n\n    if (!(ignoreMissingFields && typeof options.x509Certificates === 'undefined') && !validator.isArray(options.x509Certificates)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.x509Certificates\" must be a valid array of X509 certificate strings.');\n    }\n\n    (options.x509Certificates || []).forEach(function (cert) {\n      if (!validator.isNonEmptyString(cert)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.x509Certificates\" must be a valid array of X509 certificate strings.');\n      }\n    });\n\n    if (typeof options.enableRequestSigning !== 'undefined' && !validator.isBoolean(options.enableRequestSigning)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.enableRequestSigning\" must be a boolean.');\n    }\n\n    if (typeof options.enabled !== 'undefined' && !validator.isBoolean(options.enabled)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.enabled\" must be a boolean.');\n    }\n\n    if (typeof options.displayName !== 'undefined' && !validator.isString(options.displayName)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.displayName\" must be a valid string.');\n    }\n  };\n  /** @return The plain object representation of the SAMLConfig. */\n\n\n  SAMLConfig.prototype.toJSON = function () {\n    return {\n      enabled: this.enabled,\n      displayName: this.displayName,\n      providerId: this.providerId,\n      idpEntityId: this.idpEntityId,\n      ssoURL: this.ssoURL,\n      x509Certificates: deep_copy_1.deepCopy(this.x509Certificates),\n      rpEntityId: this.rpEntityId,\n      callbackURL: this.callbackURL,\n      enableRequestSigning: this.enableRequestSigning\n    };\n  };\n\n  return SAMLConfig;\n}();\n\nexports.SAMLConfig = SAMLConfig;\n/**\n * Defines the OIDCConfig class used to convert a client side configuration to its\n * server side representation.\n */\n\nvar OIDCConfig =\n/** @class */\nfunction () {\n  /**\n   * The OIDCConfig constructor.\n   *\n   * @param {any} response The server side response used to initialize the OIDCConfig object.\n   * @constructor\n   */\n  function OIDCConfig(response) {\n    if (!response || !response.issuer || !response.clientId || !response.name || !(validator.isString(response.name) && OIDCConfig.getProviderIdFromResourceName(response.name))) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid OIDC configuration response');\n    }\n\n    var providerId = OIDCConfig.getProviderIdFromResourceName(response.name);\n\n    if (!providerId) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n    }\n\n    this.providerId = providerId;\n    this.clientId = response.clientId;\n    this.issuer = response.issuer; // When enabled is undefined, it takes its default value of false.\n\n    this.enabled = !!response.enabled;\n    this.displayName = response.displayName;\n\n    if (typeof response.clientSecret !== 'undefined') {\n      this.clientSecret = response.clientSecret;\n    }\n\n    if (typeof response.responseType !== 'undefined') {\n      this.responseType = response.responseType;\n    }\n  }\n  /**\n   * Converts a client side request to a OIDCConfigServerRequest which is the format\n   * accepted by the backend server.\n   * Throws an error if validation fails. If the request is not a OIDCConfig request,\n   * returns null.\n   *\n   * @param options The options object to convert to a server request.\n   * @param ignoreMissingFields Whether to ignore missing fields.\n   * @return The resulting server request or null if not valid.\n   */\n\n\n  OIDCConfig.buildServerRequest = function (options, ignoreMissingFields) {\n    if (ignoreMissingFields === void 0) {\n      ignoreMissingFields = false;\n    }\n\n    var makeRequest = validator.isNonNullObject(options) && (options.providerId || ignoreMissingFields);\n\n    if (!makeRequest) {\n      return null;\n    }\n\n    var request = {}; // Validate options.\n\n    OIDCConfig.validate(options, ignoreMissingFields);\n    request.enabled = options.enabled;\n    request.displayName = options.displayName;\n    request.issuer = options.issuer;\n    request.clientId = options.clientId;\n\n    if (typeof options.clientSecret !== 'undefined') {\n      request.clientSecret = options.clientSecret;\n    }\n\n    if (typeof options.responseType !== 'undefined') {\n      request.responseType = options.responseType;\n    }\n\n    return request;\n  };\n  /**\n   * Returns the provider ID corresponding to the resource name if available.\n   *\n   * @param {string} resourceName The server side resource name\n   * @return {?string} The provider ID corresponding to the resource, null otherwise.\n   */\n\n\n  OIDCConfig.getProviderIdFromResourceName = function (resourceName) {\n    // name is of form projects/project1/oauthIdpConfigs/providerId1\n    var matchProviderRes = resourceName.match(/\\/oauthIdpConfigs\\/(oidc\\..*)$/);\n\n    if (!matchProviderRes || matchProviderRes.length < 2) {\n      return null;\n    }\n\n    return matchProviderRes[1];\n  };\n  /**\n   * @param {any} providerId The provider ID to check.\n   * @return {boolean} Whether the provider ID corresponds to an OIDC provider.\n   */\n\n\n  OIDCConfig.isProviderId = function (providerId) {\n    return validator.isNonEmptyString(providerId) && providerId.indexOf('oidc.') === 0;\n  };\n  /**\n   * Validates the OIDCConfig options object. Throws an error on failure.\n   *\n   * @param options The options object to validate.\n   * @param ignoreMissingFields Whether to ignore missing fields.\n   */\n\n\n  OIDCConfig.validate = function (options, ignoreMissingFields) {\n    if (ignoreMissingFields === void 0) {\n      ignoreMissingFields = false;\n    }\n\n    var validKeys = {\n      enabled: true,\n      displayName: true,\n      providerId: true,\n      clientId: true,\n      issuer: true,\n      clientSecret: true,\n      responseType: true\n    };\n    var validResponseTypes = {\n      idToken: true,\n      code: true\n    };\n\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig\" must be a valid non-null object.');\n    } // Check for unsupported top level attributes.\n\n\n    for (var key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, \"\\\"\" + key + \"\\\" is not a valid OIDC config parameter.\");\n      }\n    } // Required fields.\n\n\n    if (validator.isNonEmptyString(options.providerId)) {\n      if (options.providerId.indexOf('oidc.') !== 0) {\n        throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"OIDCAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"oidc.\".');\n      }\n    } else if (!ignoreMissingFields) {\n      throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"OIDCAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"oidc.\".');\n    }\n\n    if (!(ignoreMissingFields && typeof options.clientId === 'undefined') && !validator.isNonEmptyString(options.clientId)) {\n      throw new error_1.FirebaseAuthError(!options.clientId ? error_1.AuthClientErrorCode.MISSING_OAUTH_CLIENT_ID : error_1.AuthClientErrorCode.INVALID_OAUTH_CLIENT_ID, '\"OIDCAuthProviderConfig.clientId\" must be a valid non-empty string.');\n    }\n\n    if (!(ignoreMissingFields && typeof options.issuer === 'undefined') && !validator.isURL(options.issuer)) {\n      throw new error_1.FirebaseAuthError(!options.issuer ? error_1.AuthClientErrorCode.MISSING_ISSUER : error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.issuer\" must be a valid URL string.');\n    }\n\n    if (typeof options.enabled !== 'undefined' && !validator.isBoolean(options.enabled)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.enabled\" must be a boolean.');\n    }\n\n    if (typeof options.displayName !== 'undefined' && !validator.isString(options.displayName)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.displayName\" must be a valid string.');\n    }\n\n    if (typeof options.clientSecret !== 'undefined' && !validator.isNonEmptyString(options.clientSecret)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.clientSecret\" must be a valid string.');\n    }\n\n    if (validator.isNonNullObject(options.responseType) && typeof options.responseType !== 'undefined') {\n      Object.keys(options.responseType).forEach(function (key) {\n        if (!(key in validResponseTypes)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, \"\\\"\" + key + \"\\\" is not a valid OAuthResponseType parameter.\");\n        }\n      });\n      var idToken = options.responseType.idToken;\n\n      if (typeof idToken !== 'undefined' && !validator.isBoolean(idToken)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"OIDCAuthProviderConfig.responseType.idToken\" must be a boolean.');\n      }\n\n      var code = options.responseType.code;\n\n      if (typeof code !== 'undefined') {\n        if (!validator.isBoolean(code)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"OIDCAuthProviderConfig.responseType.code\" must be a boolean.');\n        } // If code flow is enabled, client secret must be provided.\n\n\n        if (code && typeof options.clientSecret === 'undefined') {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_OAUTH_CLIENT_SECRET, 'The OAuth configuration client secret is required to enable OIDC code flow.');\n        }\n      }\n\n      var allKeys = Object.keys(options.responseType).length;\n      var enabledCount = Object.values(options.responseType).filter(Boolean).length; // Only one of OAuth response types can be set to true.\n\n      if (allKeys > 1 && enabledCount != 1) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_OAUTH_RESPONSETYPE, 'Only exactly one OAuth responseType should be set to true.');\n      }\n    }\n  };\n  /** @return {OIDCAuthProviderConfig} The plain object representation of the OIDCConfig. */\n\n\n  OIDCConfig.prototype.toJSON = function () {\n    return {\n      enabled: this.enabled,\n      displayName: this.displayName,\n      providerId: this.providerId,\n      issuer: this.issuer,\n      clientId: this.clientId,\n      clientSecret: deep_copy_1.deepCopy(this.clientSecret),\n      responseType: deep_copy_1.deepCopy(this.responseType)\n    };\n  };\n\n  return OIDCConfig;\n}();\n\nexports.OIDCConfig = OIDCConfig;","map":null,"metadata":{},"sourceType":"script"}