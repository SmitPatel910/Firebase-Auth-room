{"ast":null,"code":"/*! firebase-admin v9.11.0 */\n\"use strict\";\n/*!\n * Copyright 2020 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RemoteConfig = void 0;\n\nvar validator = require(\"../utils/validator\");\n\nvar remote_config_api_client_internal_1 = require(\"./remote-config-api-client-internal\");\n/**\n * Remote Config service bound to the provided app.\n */\n\n\nvar RemoteConfig =\n/** @class */\nfunction () {\n  /**\n   * @param app The app for this RemoteConfig service.\n   * @constructor\n   */\n  function RemoteConfig(app) {\n    this.app = app;\n    this.client = new remote_config_api_client_internal_1.RemoteConfigApiClient(app);\n  }\n  /**\n   * Gets the current active version of the {@link remoteConfig.RemoteConfigTemplate\n   * `RemoteConfigTemplate`} of the project.\n   *\n   * @return A promise that fulfills with a `RemoteConfigTemplate`.\n   */\n\n\n  RemoteConfig.prototype.getTemplate = function () {\n    return this.client.getTemplate().then(function (templateResponse) {\n      return new RemoteConfigTemplateImpl(templateResponse);\n    });\n  };\n  /**\n   * Gets the requested version of the {@link remoteConfig.RemoteConfigTemplate\n    * `RemoteConfigTemplate`} of the project.\n   *\n   * @param versionNumber Version number of the Remote Config template to look up.\n   *\n   * @return A promise that fulfills with a `RemoteConfigTemplate`.\n   */\n\n\n  RemoteConfig.prototype.getTemplateAtVersion = function (versionNumber) {\n    return this.client.getTemplateAtVersion(versionNumber).then(function (templateResponse) {\n      return new RemoteConfigTemplateImpl(templateResponse);\n    });\n  };\n  /**\n   * Validates a {@link remoteConfig.RemoteConfigTemplate `RemoteConfigTemplate`}.\n   *\n   * @param template The Remote Config template to be validated.\n   * @returns A promise that fulfills with the validated `RemoteConfigTemplate`.\n   */\n\n\n  RemoteConfig.prototype.validateTemplate = function (template) {\n    return this.client.validateTemplate(template).then(function (templateResponse) {\n      return new RemoteConfigTemplateImpl(templateResponse);\n    });\n  };\n  /**\n   * Publishes a Remote Config template.\n   *\n   * @param template The Remote Config template to be published.\n   * @param options Optional options object when publishing a Remote Config template:\n   *    - {boolean} `force` Setting this to `true` forces the Remote Config template to\n   *      be updated and circumvent the ETag. This approach is not recommended\n   *      because it risks causing the loss of updates to your Remote Config\n   *      template if multiple clients are updating the Remote Config template.\n   *      See {@link https://firebase.google.com/docs/remote-config/use-config-rest#etag_usage_and_forced_updates\n   *      ETag usage and forced updates}.\n   *\n   * @return A Promise that fulfills with the published `RemoteConfigTemplate`.\n   */\n\n\n  RemoteConfig.prototype.publishTemplate = function (template, options) {\n    return this.client.publishTemplate(template, options).then(function (templateResponse) {\n      return new RemoteConfigTemplateImpl(templateResponse);\n    });\n  };\n  /**\n   * Rolls back a project's published Remote Config template to the specified version.\n   * A rollback is equivalent to getting a previously published Remote Config\n   * template and re-publishing it using a force update.\n   *\n   * @param versionNumber The version number of the Remote Config template to roll back to.\n   *    The specified version number must be lower than the current version number, and not have\n   *    been deleted due to staleness. Only the last 300 versions are stored.\n   *    All versions that correspond to non-active Remote Config templates (that is, all except the\n   *    template that is being fetched by clients) are also deleted if they are more than 90 days old.\n   * @return A promise that fulfills with the published `RemoteConfigTemplate`.\n   */\n\n\n  RemoteConfig.prototype.rollback = function (versionNumber) {\n    return this.client.rollback(versionNumber).then(function (templateResponse) {\n      return new RemoteConfigTemplateImpl(templateResponse);\n    });\n  };\n  /**\n   * Gets a list of Remote Config template versions that have been published, sorted in reverse\n   * chronological order. Only the last 300 versions are stored.\n   * All versions that correspond to non-active Remote Config templates (i.e., all except the\n   * template that is being fetched by clients) are also deleted if they are older than 90 days.\n   *\n   * @param options Optional options object for getting a list of versions.\n   * @return A promise that fulfills with a `ListVersionsResult`.\n   */\n\n\n  RemoteConfig.prototype.listVersions = function (options) {\n    return this.client.listVersions(options).then(function (listVersionsResponse) {\n      var _a, _b;\n\n      return {\n        versions: (_b = (_a = listVersionsResponse.versions) === null || _a === void 0 ? void 0 : _a.map(function (version) {\n          return new VersionImpl(version);\n        })) !== null && _b !== void 0 ? _b : [],\n        nextPageToken: listVersionsResponse.nextPageToken\n      };\n    });\n  };\n  /**\n   * Creates and returns a new Remote Config template from a JSON string.\n   *\n   * @param json The JSON string to populate a Remote Config template.\n   *\n   * @return A new template instance.\n   */\n\n\n  RemoteConfig.prototype.createTemplateFromJSON = function (json) {\n    if (!validator.isNonEmptyString(json)) {\n      throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'JSON string must be a valid non-empty string');\n    }\n\n    var template;\n\n    try {\n      template = JSON.parse(json);\n    } catch (e) {\n      throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', \"Failed to parse the JSON string: \" + json + \". \" + e);\n    }\n\n    return new RemoteConfigTemplateImpl(template);\n  };\n\n  return RemoteConfig;\n}();\n\nexports.RemoteConfig = RemoteConfig;\n/**\n * Remote Config template internal implementation.\n */\n\nvar RemoteConfigTemplateImpl =\n/** @class */\nfunction () {\n  function RemoteConfigTemplateImpl(config) {\n    if (!validator.isNonNullObject(config) || !validator.isNonEmptyString(config.etag)) {\n      throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', \"Invalid Remote Config template: \" + JSON.stringify(config));\n    }\n\n    this.etagInternal = config.etag;\n\n    if (typeof config.parameters !== 'undefined') {\n      if (!validator.isNonNullObject(config.parameters)) {\n        throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Remote Config parameters must be a non-null object');\n      }\n\n      this.parameters = config.parameters;\n    } else {\n      this.parameters = {};\n    }\n\n    if (typeof config.parameterGroups !== 'undefined') {\n      if (!validator.isNonNullObject(config.parameterGroups)) {\n        throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Remote Config parameter groups must be a non-null object');\n      }\n\n      this.parameterGroups = config.parameterGroups;\n    } else {\n      this.parameterGroups = {};\n    }\n\n    if (typeof config.conditions !== 'undefined') {\n      if (!validator.isArray(config.conditions)) {\n        throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Remote Config conditions must be an array');\n      }\n\n      this.conditions = config.conditions;\n    } else {\n      this.conditions = [];\n    }\n\n    if (typeof config.version !== 'undefined') {\n      this.version = new VersionImpl(config.version);\n    }\n  }\n\n  Object.defineProperty(RemoteConfigTemplateImpl.prototype, \"etag\", {\n    /**\n     * Gets the ETag of the template.\n     *\n     * @return {string} The ETag of the Remote Config template.\n     */\n    get: function get() {\n      return this.etagInternal;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * @return {RemoteConfigTemplate} A JSON-serializable representation of this object.\n   */\n\n  RemoteConfigTemplateImpl.prototype.toJSON = function () {\n    return {\n      conditions: this.conditions,\n      parameters: this.parameters,\n      parameterGroups: this.parameterGroups,\n      etag: this.etag,\n      version: this.version\n    };\n  };\n\n  return RemoteConfigTemplateImpl;\n}();\n/**\n* Remote Config Version internal implementation.\n*/\n\n\nvar VersionImpl =\n/** @class */\nfunction () {\n  function VersionImpl(version) {\n    if (!validator.isNonNullObject(version)) {\n      throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', \"Invalid Remote Config version instance: \" + JSON.stringify(version));\n    }\n\n    if (typeof version.versionNumber !== 'undefined') {\n      if (!validator.isNonEmptyString(version.versionNumber) && !validator.isNumber(version.versionNumber)) {\n        throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Version number must be a non-empty string in int64 format or a number');\n      }\n\n      if (!Number.isInteger(Number(version.versionNumber))) {\n        throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Version number must be an integer or a string in int64 format');\n      }\n\n      this.versionNumber = version.versionNumber;\n    }\n\n    if (typeof version.updateOrigin !== 'undefined') {\n      if (!validator.isNonEmptyString(version.updateOrigin)) {\n        throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Version update origin must be a non-empty string');\n      }\n\n      this.updateOrigin = version.updateOrigin;\n    }\n\n    if (typeof version.updateType !== 'undefined') {\n      if (!validator.isNonEmptyString(version.updateType)) {\n        throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Version update type must be a non-empty string');\n      }\n\n      this.updateType = version.updateType;\n    }\n\n    if (typeof version.updateUser !== 'undefined') {\n      if (!validator.isNonNullObject(version.updateUser)) {\n        throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Version update user must be a non-null object');\n      }\n\n      this.updateUser = version.updateUser;\n    }\n\n    if (typeof version.description !== 'undefined') {\n      if (!validator.isNonEmptyString(version.description)) {\n        throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Version description must be a non-empty string');\n      }\n\n      this.description = version.description;\n    }\n\n    if (typeof version.rollbackSource !== 'undefined') {\n      if (!validator.isNonEmptyString(version.rollbackSource)) {\n        throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Version rollback source must be a non-empty string');\n      }\n\n      this.rollbackSource = version.rollbackSource;\n    }\n\n    if (typeof version.isLegacy !== 'undefined') {\n      if (!validator.isBoolean(version.isLegacy)) {\n        throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Version.isLegacy must be a boolean');\n      }\n\n      this.isLegacy = version.isLegacy;\n    } // The backend API provides timestamps in ISO date strings. The Admin SDK exposes timestamps\n    // in UTC date strings. If a developer uses a previously obtained template with UTC timestamps\n    // we could still validate it below.\n\n\n    if (typeof version.updateTime !== 'undefined') {\n      if (!this.isValidTimestamp(version.updateTime)) {\n        throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Version update time must be a valid date string');\n      }\n\n      this.updateTime = new Date(version.updateTime).toUTCString();\n    }\n  }\n  /**\n   * @return {Version} A JSON-serializable representation of this object.\n   */\n\n\n  VersionImpl.prototype.toJSON = function () {\n    return {\n      versionNumber: this.versionNumber,\n      updateOrigin: this.updateOrigin,\n      updateType: this.updateType,\n      updateUser: this.updateUser,\n      description: this.description,\n      rollbackSource: this.rollbackSource,\n      isLegacy: this.isLegacy,\n      updateTime: this.updateTime\n    };\n  };\n\n  VersionImpl.prototype.isValidTimestamp = function (timestamp) {\n    // This validation fails for timestamps earlier than January 1, 1970 and considers strings\n    // such as \"1.2\" as valid timestamps.\n    return validator.isNonEmptyString(timestamp) && new Date(timestamp).getTime() > 0;\n  };\n\n  return VersionImpl;\n}();","map":null,"metadata":{},"sourceType":"script"}