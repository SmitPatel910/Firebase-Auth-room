{"ast":null,"code":"var MAX_OCTET = 0x80;\nvar CLASS_UNIVERSAL = 0;\nvar PRIMITIVE_BIT = 0x20;\nvar TAG_SEQ = 0x10;\nvar TAG_INT = 0x02;\nvar ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;\nvar ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;\n\nvar getParamSize = function getParamSize(keySize) {\n  return (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);\n};\n\nvar paramBytesForAlg = {\n  ES256: getParamSize(256),\n  ES256K: getParamSize(256),\n  ES384: getParamSize(384),\n  ES512: getParamSize(521)\n};\n\nvar countPadding = function countPadding(buf, start, stop) {\n  var padding = 0;\n\n  while (start + padding < stop && buf[start + padding] === 0) {\n    ++padding;\n  }\n\n  var needsSign = buf[start + padding] >= MAX_OCTET;\n\n  if (needsSign) {\n    --padding;\n  }\n\n  return padding;\n};\n\nmodule.exports.derToJose = function (signature, alg) {\n  if (!Buffer.isBuffer(signature)) {\n    throw new TypeError('ECDSA signature must be a Buffer');\n  }\n\n  if (!paramBytesForAlg[alg]) {\n    throw new Error(\"Unknown algorithm \\\"\".concat(alg, \"\\\"\"));\n  }\n\n  var paramBytes = paramBytesForAlg[alg]; // the DER encoded param should at most be the param size, plus a padding\n  // zero, since due to being a signed integer\n\n  var maxEncodedParamLength = paramBytes + 1;\n  var inputLength = signature.length;\n  var offset = 0;\n\n  if (signature[offset++] !== ENCODED_TAG_SEQ) {\n    throw new Error('Could not find expected \"seq\"');\n  }\n\n  var seqLength = signature[offset++];\n\n  if (seqLength === (MAX_OCTET | 1)) {\n    seqLength = signature[offset++];\n  }\n\n  if (inputLength - offset < seqLength) {\n    throw new Error(\"\\\"seq\\\" specified length of \".concat(seqLength, \"\\\", only \").concat(inputLength - offset, \"\\\" remaining\"));\n  }\n\n  if (signature[offset++] !== ENCODED_TAG_INT) {\n    throw new Error('Could not find expected \"int\" for \"r\"');\n  }\n\n  var rLength = signature[offset++];\n\n  if (inputLength - offset - 2 < rLength) {\n    throw new Error(\"\\\"r\\\" specified length of \\\"\".concat(rLength, \"\\\", only \\\"\").concat(inputLength - offset - 2, \"\\\" available\"));\n  }\n\n  if (maxEncodedParamLength < rLength) {\n    throw new Error(\"\\\"r\\\" specified length of \\\"\".concat(rLength, \"\\\", max of \\\"\").concat(maxEncodedParamLength, \"\\\" is acceptable\"));\n  }\n\n  var rOffset = offset;\n  offset += rLength;\n\n  if (signature[offset++] !== ENCODED_TAG_INT) {\n    throw new Error('Could not find expected \"int\" for \"s\"');\n  }\n\n  var sLength = signature[offset++];\n\n  if (inputLength - offset !== sLength) {\n    throw new Error(\"\\\"s\\\" specified length of \\\"\".concat(sLength, \"\\\", expected \\\"\").concat(inputLength - offset, \"\\\"\"));\n  }\n\n  if (maxEncodedParamLength < sLength) {\n    throw new Error(\"\\\"s\\\" specified length of \\\"\".concat(sLength, \"\\\", max of \\\"\").concat(maxEncodedParamLength, \"\\\" is acceptable\"));\n  }\n\n  var sOffset = offset;\n  offset += sLength;\n\n  if (offset !== inputLength) {\n    throw new Error(\"Expected to consume entire buffer, but \\\"\".concat(inputLength - offset, \"\\\" bytes remain\"));\n  }\n\n  var rPadding = paramBytes - rLength;\n  var sPadding = paramBytes - sLength;\n  var dst = Buffer.allocUnsafe(rPadding + rLength + sPadding + sLength);\n\n  for (offset = 0; offset < rPadding; ++offset) {\n    dst[offset] = 0;\n  }\n\n  signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);\n  offset = paramBytes;\n\n  for (var o = offset; offset < o + sPadding; ++offset) {\n    dst[offset] = 0;\n  }\n\n  signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);\n  return dst;\n};\n\nmodule.exports.joseToDer = function (signature, alg) {\n  if (!Buffer.isBuffer(signature)) {\n    throw new TypeError('ECDSA signature must be a Buffer');\n  }\n\n  if (!paramBytesForAlg[alg]) {\n    throw new TypeError(\"Unknown algorithm \\\"\".concat(alg, \"\\\"\"));\n  }\n\n  var paramBytes = paramBytesForAlg[alg];\n  var signatureBytes = signature.length;\n\n  if (signatureBytes !== paramBytes * 2) {\n    throw new Error(\"\\\"\".concat(alg, \"\\\" signatures must be \\\"\").concat(paramBytes * 2, \"\\\" bytes, saw \\\"\").concat(signatureBytes, \"\\\"\"));\n  }\n\n  var rPadding = countPadding(signature, 0, paramBytes);\n  var sPadding = countPadding(signature, paramBytes, signature.length);\n  var rLength = paramBytes - rPadding;\n  var sLength = paramBytes - sPadding;\n  var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;\n  var shortLength = rsBytes < MAX_OCTET;\n  var dst = Buffer.allocUnsafe((shortLength ? 2 : 3) + rsBytes);\n  var offset = 0;\n  dst[offset++] = ENCODED_TAG_SEQ;\n\n  if (shortLength) {\n    // Bit 8 has value \"0\"\n    // bits 7-1 give the length.\n    dst[offset++] = rsBytes;\n  } else {\n    // Bit 8 of first octet has value \"1\"\n    // bits 7-1 give the number of additional length octets.\n    dst[offset++] = MAX_OCTET | 1; // eslint-disable-line no-tabs\n    // length, base 256\n\n    dst[offset++] = rsBytes & 0xff;\n  }\n\n  dst[offset++] = ENCODED_TAG_INT;\n  dst[offset++] = rLength;\n\n  if (rPadding < 0) {\n    dst[offset++] = 0;\n    offset += signature.copy(dst, offset, 0, paramBytes);\n  } else {\n    offset += signature.copy(dst, offset, rPadding, paramBytes);\n  }\n\n  dst[offset++] = ENCODED_TAG_INT;\n  dst[offset++] = sLength;\n\n  if (sPadding < 0) {\n    dst[offset++] = 0;\n    signature.copy(dst, offset, paramBytes);\n  } else {\n    signature.copy(dst, offset, paramBytes + sPadding);\n  }\n\n  return dst;\n};","map":null,"metadata":{},"sourceType":"script"}