{"ast":null,"code":"module.exports = LRUCache; // This will be a proper iterable 'Map' in engines that support it,\n// or a fakey-fake PseudoMap in older versions.\n\nvar Map = require('pseudomap');\n\nvar util = require('util'); // A linked list to keep track of recently-used-ness\n\n\nvar Yallist = require('yallist'); // use symbols if possible, otherwise just _props\n\n\nvar symbols = {};\nvar hasSymbol = typeof Symbol === 'function';\nvar makeSymbol;\n/* istanbul ignore if */\n\nif (hasSymbol) {\n  makeSymbol = function makeSymbol(key) {\n    return Symbol.for(key);\n  };\n} else {\n  makeSymbol = function makeSymbol(key) {\n    return '_' + key;\n  };\n}\n\nfunction priv(obj, key, val) {\n  var sym;\n\n  if (symbols[key]) {\n    sym = symbols[key];\n  } else {\n    sym = makeSymbol(key);\n    symbols[key] = sym;\n  }\n\n  if (arguments.length === 2) {\n    return obj[sym];\n  } else {\n    obj[sym] = val;\n    return val;\n  }\n}\n\nfunction naiveLength() {\n  return 1;\n} // lruList is a yallist where the head is the youngest\n// item, and the tail is the oldest.  the list contains the Hit\n// objects as the entries.\n// Each Hit object has a reference to its Yallist.Node.  This\n// never changes.\n//\n// cache is a Map (or PseudoMap) that matches the keys to\n// the Yallist.Node object.\n\n\nfunction LRUCache(options) {\n  if (!(this instanceof LRUCache)) {\n    return new LRUCache(options);\n  }\n\n  if (typeof options === 'number') {\n    options = {\n      max: options\n    };\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  var max = priv(this, 'max', options.max); // Kind of weird to have a default max of Infinity, but oh well.\n\n  if (!max || !(typeof max === 'number') || max <= 0) {\n    priv(this, 'max', Infinity);\n  }\n\n  var lc = options.length || naiveLength;\n\n  if (typeof lc !== 'function') {\n    lc = naiveLength;\n  }\n\n  priv(this, 'lengthCalculator', lc);\n  priv(this, 'allowStale', options.stale || false);\n  priv(this, 'maxAge', options.maxAge || 0);\n  priv(this, 'dispose', options.dispose);\n  this.reset();\n} // resize the cache when the max changes.\n\n\nObject.defineProperty(LRUCache.prototype, 'max', {\n  set: function set(mL) {\n    if (!mL || !(typeof mL === 'number') || mL <= 0) {\n      mL = Infinity;\n    }\n\n    priv(this, 'max', mL);\n    trim(this);\n  },\n  get: function get() {\n    return priv(this, 'max');\n  },\n  enumerable: true\n});\nObject.defineProperty(LRUCache.prototype, 'allowStale', {\n  set: function set(allowStale) {\n    priv(this, 'allowStale', !!allowStale);\n  },\n  get: function get() {\n    return priv(this, 'allowStale');\n  },\n  enumerable: true\n});\nObject.defineProperty(LRUCache.prototype, 'maxAge', {\n  set: function set(mA) {\n    if (!mA || !(typeof mA === 'number') || mA < 0) {\n      mA = 0;\n    }\n\n    priv(this, 'maxAge', mA);\n    trim(this);\n  },\n  get: function get() {\n    return priv(this, 'maxAge');\n  },\n  enumerable: true\n}); // resize the cache when the lengthCalculator changes.\n\nObject.defineProperty(LRUCache.prototype, 'lengthCalculator', {\n  set: function set(lC) {\n    if (typeof lC !== 'function') {\n      lC = naiveLength;\n    }\n\n    if (lC !== priv(this, 'lengthCalculator')) {\n      priv(this, 'lengthCalculator', lC);\n      priv(this, 'length', 0);\n      priv(this, 'lruList').forEach(function (hit) {\n        hit.length = priv(this, 'lengthCalculator').call(this, hit.value, hit.key);\n        priv(this, 'length', priv(this, 'length') + hit.length);\n      }, this);\n    }\n\n    trim(this);\n  },\n  get: function get() {\n    return priv(this, 'lengthCalculator');\n  },\n  enumerable: true\n});\nObject.defineProperty(LRUCache.prototype, 'length', {\n  get: function get() {\n    return priv(this, 'length');\n  },\n  enumerable: true\n});\nObject.defineProperty(LRUCache.prototype, 'itemCount', {\n  get: function get() {\n    return priv(this, 'lruList').length;\n  },\n  enumerable: true\n});\n\nLRUCache.prototype.rforEach = function (fn, thisp) {\n  thisp = thisp || this;\n\n  for (var walker = priv(this, 'lruList').tail; walker !== null;) {\n    var prev = walker.prev;\n    forEachStep(this, fn, walker, thisp);\n    walker = prev;\n  }\n};\n\nfunction forEachStep(self, fn, node, thisp) {\n  var hit = node.value;\n\n  if (isStale(self, hit)) {\n    del(self, node);\n\n    if (!priv(self, 'allowStale')) {\n      hit = undefined;\n    }\n  }\n\n  if (hit) {\n    fn.call(thisp, hit.value, hit.key, self);\n  }\n}\n\nLRUCache.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this;\n\n  for (var walker = priv(this, 'lruList').head; walker !== null;) {\n    var next = walker.next;\n    forEachStep(this, fn, walker, thisp);\n    walker = next;\n  }\n};\n\nLRUCache.prototype.keys = function () {\n  return priv(this, 'lruList').toArray().map(function (k) {\n    return k.key;\n  }, this);\n};\n\nLRUCache.prototype.values = function () {\n  return priv(this, 'lruList').toArray().map(function (k) {\n    return k.value;\n  }, this);\n};\n\nLRUCache.prototype.reset = function () {\n  if (priv(this, 'dispose') && priv(this, 'lruList') && priv(this, 'lruList').length) {\n    priv(this, 'lruList').forEach(function (hit) {\n      priv(this, 'dispose').call(this, hit.key, hit.value);\n    }, this);\n  }\n\n  priv(this, 'cache', new Map()); // hash of items by key\n\n  priv(this, 'lruList', new Yallist()); // list of items in order of use recency\n\n  priv(this, 'length', 0); // length of items in the list\n};\n\nLRUCache.prototype.dump = function () {\n  return priv(this, 'lruList').map(function (hit) {\n    if (!isStale(this, hit)) {\n      return {\n        k: hit.key,\n        v: hit.value,\n        e: hit.now + (hit.maxAge || 0)\n      };\n    }\n  }, this).toArray().filter(function (h) {\n    return h;\n  });\n};\n\nLRUCache.prototype.dumpLru = function () {\n  return priv(this, 'lruList');\n};\n\nLRUCache.prototype.inspect = function (n, opts) {\n  var str = 'LRUCache {';\n  var extras = false;\n  var as = priv(this, 'allowStale');\n\n  if (as) {\n    str += '\\n  allowStale: true';\n    extras = true;\n  }\n\n  var max = priv(this, 'max');\n\n  if (max && max !== Infinity) {\n    if (extras) {\n      str += ',';\n    }\n\n    str += '\\n  max: ' + util.inspect(max, opts);\n    extras = true;\n  }\n\n  var maxAge = priv(this, 'maxAge');\n\n  if (maxAge) {\n    if (extras) {\n      str += ',';\n    }\n\n    str += '\\n  maxAge: ' + util.inspect(maxAge, opts);\n    extras = true;\n  }\n\n  var lc = priv(this, 'lengthCalculator');\n\n  if (lc && lc !== naiveLength) {\n    if (extras) {\n      str += ',';\n    }\n\n    str += '\\n  length: ' + util.inspect(priv(this, 'length'), opts);\n    extras = true;\n  }\n\n  var didFirst = false;\n  priv(this, 'lruList').forEach(function (item) {\n    if (didFirst) {\n      str += ',\\n  ';\n    } else {\n      if (extras) {\n        str += ',\\n';\n      }\n\n      didFirst = true;\n      str += '\\n  ';\n    }\n\n    var key = util.inspect(item.key).split('\\n').join('\\n  ');\n    var val = {\n      value: item.value\n    };\n\n    if (item.maxAge !== maxAge) {\n      val.maxAge = item.maxAge;\n    }\n\n    if (lc !== naiveLength) {\n      val.length = item.length;\n    }\n\n    if (isStale(this, item)) {\n      val.stale = true;\n    }\n\n    val = util.inspect(val, opts).split('\\n').join('\\n  ');\n    str += key + ' => ' + val;\n  });\n\n  if (didFirst || extras) {\n    str += '\\n';\n  }\n\n  str += '}';\n  return str;\n};\n\nLRUCache.prototype.set = function (key, value, maxAge) {\n  maxAge = maxAge || priv(this, 'maxAge');\n  var now = maxAge ? Date.now() : 0;\n  var len = priv(this, 'lengthCalculator').call(this, value, key);\n\n  if (priv(this, 'cache').has(key)) {\n    if (len > priv(this, 'max')) {\n      del(this, priv(this, 'cache').get(key));\n      return false;\n    }\n\n    var node = priv(this, 'cache').get(key);\n    var item = node.value; // dispose of the old one before overwriting\n\n    if (priv(this, 'dispose')) {\n      priv(this, 'dispose').call(this, key, item.value);\n    }\n\n    item.now = now;\n    item.maxAge = maxAge;\n    item.value = value;\n    priv(this, 'length', priv(this, 'length') + (len - item.length));\n    item.length = len;\n    this.get(key);\n    trim(this);\n    return true;\n  }\n\n  var hit = new Entry(key, value, len, now, maxAge); // oversized objects fall out of cache automatically.\n\n  if (hit.length > priv(this, 'max')) {\n    if (priv(this, 'dispose')) {\n      priv(this, 'dispose').call(this, key, value);\n    }\n\n    return false;\n  }\n\n  priv(this, 'length', priv(this, 'length') + hit.length);\n  priv(this, 'lruList').unshift(hit);\n  priv(this, 'cache').set(key, priv(this, 'lruList').head);\n  trim(this);\n  return true;\n};\n\nLRUCache.prototype.has = function (key) {\n  if (!priv(this, 'cache').has(key)) return false;\n  var hit = priv(this, 'cache').get(key).value;\n\n  if (isStale(this, hit)) {\n    return false;\n  }\n\n  return true;\n};\n\nLRUCache.prototype.get = function (key) {\n  return get(this, key, true);\n};\n\nLRUCache.prototype.peek = function (key) {\n  return get(this, key, false);\n};\n\nLRUCache.prototype.pop = function () {\n  var node = priv(this, 'lruList').tail;\n  if (!node) return null;\n  del(this, node);\n  return node.value;\n};\n\nLRUCache.prototype.del = function (key) {\n  del(this, priv(this, 'cache').get(key));\n};\n\nLRUCache.prototype.load = function (arr) {\n  // reset the cache\n  this.reset();\n  var now = Date.now(); // A previous serialized cache has the most recent items first\n\n  for (var l = arr.length - 1; l >= 0; l--) {\n    var hit = arr[l];\n    var expiresAt = hit.e || 0;\n\n    if (expiresAt === 0) {\n      // the item was created without expiration in a non aged cache\n      this.set(hit.k, hit.v);\n    } else {\n      var maxAge = expiresAt - now; // dont add already expired items\n\n      if (maxAge > 0) {\n        this.set(hit.k, hit.v, maxAge);\n      }\n    }\n  }\n};\n\nLRUCache.prototype.prune = function () {\n  var self = this;\n  priv(this, 'cache').forEach(function (value, key) {\n    get(self, key, false);\n  });\n};\n\nfunction get(self, key, doUse) {\n  var node = priv(self, 'cache').get(key);\n\n  if (node) {\n    var hit = node.value;\n\n    if (isStale(self, hit)) {\n      del(self, node);\n      if (!priv(self, 'allowStale')) hit = undefined;\n    } else {\n      if (doUse) {\n        priv(self, 'lruList').unshiftNode(node);\n      }\n    }\n\n    if (hit) hit = hit.value;\n  }\n\n  return hit;\n}\n\nfunction isStale(self, hit) {\n  if (!hit || !hit.maxAge && !priv(self, 'maxAge')) {\n    return false;\n  }\n\n  var stale = false;\n  var diff = Date.now() - hit.now;\n\n  if (hit.maxAge) {\n    stale = diff > hit.maxAge;\n  } else {\n    stale = priv(self, 'maxAge') && diff > priv(self, 'maxAge');\n  }\n\n  return stale;\n}\n\nfunction trim(self) {\n  if (priv(self, 'length') > priv(self, 'max')) {\n    for (var walker = priv(self, 'lruList').tail; priv(self, 'length') > priv(self, 'max') && walker !== null;) {\n      // We know that we're about to delete this one, and also\n      // what the next least recently used key will be, so just\n      // go ahead and set it now.\n      var prev = walker.prev;\n      del(self, walker);\n      walker = prev;\n    }\n  }\n}\n\nfunction del(self, node) {\n  if (node) {\n    var hit = node.value;\n\n    if (priv(self, 'dispose')) {\n      priv(self, 'dispose').call(this, hit.key, hit.value);\n    }\n\n    priv(self, 'length', priv(self, 'length') - hit.length);\n    priv(self, 'cache').delete(hit.key);\n    priv(self, 'lruList').removeNode(node);\n  }\n} // classy, since V8 prefers predictable objects.\n\n\nfunction Entry(key, value, length, now, maxAge) {\n  this.key = key;\n  this.value = value;\n  this.length = length;\n  this.now = now;\n  this.maxAge = maxAge || 0;\n}","map":null,"metadata":{},"sourceType":"script"}