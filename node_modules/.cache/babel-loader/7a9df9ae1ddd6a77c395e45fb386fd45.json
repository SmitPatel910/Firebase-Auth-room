{"ast":null,"code":"\"use strict\"; // Copyright 2014 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\Smit\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Smit\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Smit\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\Smit\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\Smit\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _assertThisInitialized = require(\"C:\\\\Users\\\\Smit\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"C:\\\\Users\\\\Smit\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _wrapNativeSuper = require(\"C:\\\\Users\\\\Smit\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/wrapNativeSuper\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*!\n * @module common/util\n */\n\nvar projectify_1 = require(\"@google-cloud/projectify\");\n\nvar ent = require(\"ent\");\n\nvar extend = require(\"extend\");\n\nvar google_auth_library_1 = require(\"google-auth-library\");\n\nvar retryRequest = require(\"retry-request\");\n\nvar stream_1 = require(\"stream\");\n\nvar teeny_request_1 = require(\"teeny-request\"); // eslint-disable-next-line @typescript-eslint/no-var-requires\n\n\nvar duplexify = require('duplexify');\n\nvar requestDefaults = {\n  timeout: 60000,\n  gzip: true,\n  forever: true,\n  pool: {\n    maxSockets: Infinity\n  }\n};\n/**\n * Default behavior: Automatically retry retriable server errors.\n *\n * @const {boolean}\n * @private\n */\n\nvar AUTO_RETRY_DEFAULT = true;\n/**\n * Default behavior: Only attempt to retry retriable errors 3 times.\n *\n * @const {number}\n * @private\n */\n\nvar MAX_RETRY_DEFAULT = 3;\n/**\n * Custom error type for API errors.\n *\n * @param {object} errorBody - Error object.\n */\n\nvar ApiError = /*#__PURE__*/function (_Error) {\n  _inherits(ApiError, _Error);\n\n  function ApiError(errorBodyOrMessage) {\n    var _this;\n\n    _classCallCheck(this, ApiError);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ApiError).call(this));\n\n    if (typeof errorBodyOrMessage !== 'object') {\n      _this.message = errorBodyOrMessage || '';\n      return _possibleConstructorReturn(_this);\n    }\n\n    var errorBody = errorBodyOrMessage;\n    _this.code = errorBody.code;\n    _this.errors = errorBody.errors;\n    _this.response = errorBody.response;\n\n    try {\n      _this.errors = JSON.parse(_this.response.body).error.errors;\n    } catch (e) {\n      _this.errors = errorBody.errors;\n    }\n\n    _this.message = ApiError.createMultiErrorMessage(errorBody, _this.errors);\n    Error.captureStackTrace(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * Pieces together an error message by combining all unique error messages\n   * returned from a single GoogleError\n   *\n   * @private\n   *\n   * @param {GoogleErrorBody} err The original error.\n   * @param {GoogleInnerError[]} [errors] Inner errors, if any.\n   * @returns {string}\n   */\n\n\n  _createClass(ApiError, null, [{\n    key: \"createMultiErrorMessage\",\n    value: function createMultiErrorMessage(err, errors) {\n      var messages = new Set();\n\n      if (err.message) {\n        messages.add(err.message);\n      }\n\n      if (errors && errors.length) {\n        errors.forEach(function (_ref) {\n          var message = _ref.message;\n          return messages.add(message);\n        });\n      } else if (err.response && err.response.body) {\n        messages.add(ent.decode(err.response.body.toString()));\n      } else if (!err.message) {\n        messages.add('A failure occurred during this request.');\n      }\n\n      var messageArr = Array.from(messages);\n\n      if (messageArr.length > 1) {\n        messageArr = messageArr.map(function (message, i) {\n          return \"    \".concat(i + 1, \". \").concat(message);\n        });\n        messageArr.unshift('Multiple errors occurred during the request. Please see the `errors` array for complete details.\\n');\n        messageArr.push('\\n');\n      }\n\n      return messageArr.join('\\n');\n    }\n  }]);\n\n  return ApiError;\n}(_wrapNativeSuper(Error));\n\nexports.ApiError = ApiError;\n/**\n * Custom error type for partial errors returned from the API.\n *\n * @param {object} b - Error object.\n */\n\nvar PartialFailureError = /*#__PURE__*/function (_Error2) {\n  _inherits(PartialFailureError, _Error2);\n\n  function PartialFailureError(b) {\n    var _this2;\n\n    _classCallCheck(this, PartialFailureError);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(PartialFailureError).call(this));\n    var errorObject = b;\n    _this2.errors = errorObject.errors;\n    _this2.name = 'PartialFailureError';\n    _this2.response = errorObject.response;\n    _this2.message = ApiError.createMultiErrorMessage(errorObject, _this2.errors);\n    return _this2;\n  }\n\n  return PartialFailureError;\n}(_wrapNativeSuper(Error));\n\nexports.PartialFailureError = PartialFailureError;\n\nvar Util = /*#__PURE__*/function () {\n  function Util() {\n    _classCallCheck(this, Util);\n\n    this.ApiError = ApiError;\n    this.PartialFailureError = PartialFailureError;\n  }\n  /**\n   * No op.\n   *\n   * @example\n   * function doSomething(callback) {\n   *   callback = callback || noop;\n   * }\n   */\n\n\n  _createClass(Util, [{\n    key: \"noop\",\n    value: function noop() {}\n    /**\n     * Uniformly process an API response.\n     *\n     * @param {*} err - Error value.\n     * @param {*} resp - Response value.\n     * @param {*} body - Body value.\n     * @param {function} callback - The callback function.\n     */\n\n  }, {\n    key: \"handleResp\",\n    value: function handleResp(err, resp, body, callback) {\n      callback = callback || util.noop;\n      var parsedResp = extend(true, {\n        err: err || null\n      }, resp && util.parseHttpRespMessage(resp), body && util.parseHttpRespBody(body)); // Assign the parsed body to resp.body, even if { json: false } was passed\n      // as a request option.\n      // We assume that nobody uses the previously unparsed value of resp.body.\n\n      if (!parsedResp.err && resp && typeof parsedResp.body === 'object') {\n        parsedResp.resp.body = parsedResp.body;\n      }\n\n      if (parsedResp.err && resp) {\n        parsedResp.err.response = resp;\n      }\n\n      callback(parsedResp.err, parsedResp.body, parsedResp.resp);\n    }\n    /**\n     * Sniff an incoming HTTP response message for errors.\n     *\n     * @param {object} httpRespMessage - An incoming HTTP response message from `request`.\n     * @return {object} parsedHttpRespMessage - The parsed response.\n     * @param {?error} parsedHttpRespMessage.err - An error detected.\n     * @param {object} parsedHttpRespMessage.resp - The original response object.\n     */\n\n  }, {\n    key: \"parseHttpRespMessage\",\n    value: function parseHttpRespMessage(httpRespMessage) {\n      var parsedHttpRespMessage = {\n        resp: httpRespMessage\n      };\n\n      if (httpRespMessage.statusCode < 200 || httpRespMessage.statusCode > 299) {\n        // Unknown error. Format according to ApiError standard.\n        parsedHttpRespMessage.err = new ApiError({\n          errors: new Array(),\n          code: httpRespMessage.statusCode,\n          message: httpRespMessage.statusMessage,\n          response: httpRespMessage\n        });\n      }\n\n      return parsedHttpRespMessage;\n    }\n    /**\n     * Parse the response body from an HTTP request.\n     *\n     * @param {object} body - The response body.\n     * @return {object} parsedHttpRespMessage - The parsed response.\n     * @param {?error} parsedHttpRespMessage.err - An error detected.\n     * @param {object} parsedHttpRespMessage.body - The original body value provided\n     *     will try to be JSON.parse'd. If it's successful, the parsed value will\n     * be returned here, otherwise the original value and an error will be returned.\n     */\n\n  }, {\n    key: \"parseHttpRespBody\",\n    value: function parseHttpRespBody(body) {\n      var parsedHttpRespBody = {\n        body: body\n      };\n\n      if (typeof body === 'string') {\n        try {\n          parsedHttpRespBody.body = JSON.parse(body);\n        } catch (err) {\n          parsedHttpRespBody.body = body;\n        }\n      }\n\n      if (parsedHttpRespBody.body && parsedHttpRespBody.body.error) {\n        // Error from JSON API.\n        parsedHttpRespBody.err = new ApiError(parsedHttpRespBody.body.error);\n      }\n\n      return parsedHttpRespBody;\n    }\n    /**\n     * Take a Duplexify stream, fetch an authenticated connection header, and\n     * create an outgoing writable stream.\n     *\n     * @param {Duplexify} dup - Duplexify stream.\n     * @param {object} options - Configuration object.\n     * @param {module:common/connection} options.connection - A connection instance used to get a token with and send the request through.\n     * @param {object} options.metadata - Metadata to send at the head of the request.\n     * @param {object} options.request - Request object, in the format of a standard Node.js http.request() object.\n     * @param {string=} options.request.method - Default: \"POST\".\n     * @param {string=} options.request.qs.uploadType - Default: \"multipart\".\n     * @param {string=} options.streamContentType - Default: \"application/octet-stream\".\n     * @param {function} onComplete - Callback, executed after the writable Request stream has completed.\n     */\n\n  }, {\n    key: \"makeWritableStream\",\n    value: function makeWritableStream(dup, options, onComplete) {\n      onComplete = onComplete || util.noop;\n      var writeStream = new ProgressStream();\n      writeStream.on('progress', function (evt) {\n        return dup.emit('progress', evt);\n      });\n      dup.setWritable(writeStream);\n      var defaultReqOpts = {\n        method: 'POST',\n        qs: {\n          uploadType: 'multipart'\n        },\n        timeout: 0,\n        maxRetries: 0\n      };\n      var metadata = options.metadata || {};\n      var reqOpts = extend(true, defaultReqOpts, options.request, {\n        multipart: [{\n          'Content-Type': 'application/json',\n          body: JSON.stringify(metadata)\n        }, {\n          'Content-Type': metadata.contentType || 'application/octet-stream',\n          body: writeStream\n        }]\n      });\n      options.makeAuthenticatedRequest(reqOpts, {\n        onAuthenticated: function onAuthenticated(err, authenticatedReqOpts) {\n          if (err) {\n            dup.destroy(err);\n            return;\n          }\n\n          var request = teeny_request_1.teenyRequest.defaults(requestDefaults);\n          request(authenticatedReqOpts, function (err, resp, body) {\n            util.handleResp(err, resp, body, function (err, data) {\n              if (err) {\n                dup.destroy(err);\n                return;\n              }\n\n              dup.emit('response', resp);\n              onComplete(data);\n            });\n          });\n        }\n      });\n    }\n    /**\n     * Returns true if the API request should be retried, given the error that was\n     * given the first time the request was attempted. This is used for rate limit\n     * related errors as well as intermittent server errors.\n     *\n     * @param {error} err - The API error to check if it is appropriate to retry.\n     * @return {boolean} True if the API request should be retried, false otherwise.\n     */\n\n  }, {\n    key: \"shouldRetryRequest\",\n    value: function shouldRetryRequest(err) {\n      if (err) {\n        if ([408, 429, 500, 502, 503].indexOf(err.code) !== -1) {\n          return true;\n        }\n\n        if (err.errors) {\n          var _iterator = _createForOfIteratorHelper(err.errors),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var e = _step.value;\n              var reason = e.reason;\n\n              if (reason === 'rateLimitExceeded') {\n                return true;\n              }\n\n              if (reason === 'userRateLimitExceeded') {\n                return true;\n              }\n\n              if (reason && reason.includes('EAI_AGAIN')) {\n                return true;\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Get a function for making authenticated requests.\n     *\n     * @param {object} config - Configuration object.\n     * @param {boolean=} config.autoRetry - Automatically retry requests if the\n     *     response is related to rate limits or certain intermittent server\n     * errors. We will exponentially backoff subsequent requests by default.\n     * (default: true)\n     * @param {object=} config.credentials - Credentials object.\n     * @param {boolean=} config.customEndpoint - If true, just return the provided request options. Default: false.\n     * @param {string=} config.email - Account email address, required for PEM/P12 usage.\n     * @param {number=} config.maxRetries - Maximum number of automatic retries attempted before returning the error. (default: 3)\n     * @param {string=} config.keyFile - Path to a .json, .pem, or .p12 keyfile.\n     * @param {array} config.scopes - Array of scopes required for the API.\n     */\n\n  }, {\n    key: \"makeAuthenticatedRequestFactory\",\n    value: function makeAuthenticatedRequestFactory(config) {\n      var googleAutoAuthConfig = extend({}, config);\n\n      if (googleAutoAuthConfig.projectId === '{{projectId}}') {\n        delete googleAutoAuthConfig.projectId;\n      }\n\n      var authClient = googleAutoAuthConfig.authClient || new google_auth_library_1.GoogleAuth(googleAutoAuthConfig);\n\n      function makeAuthenticatedRequest(reqOpts, optionsOrCallback) {\n        var stream;\n        var projectId;\n        var reqConfig = extend({}, config);\n        var activeRequest_;\n\n        if (!optionsOrCallback) {\n          stream = duplexify();\n          reqConfig.stream = stream;\n        }\n\n        var options = typeof optionsOrCallback === 'object' ? optionsOrCallback : undefined;\n        var callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : undefined;\n\n        var onAuthenticated = function onAuthenticated(err, authenticatedReqOpts) {\n          var authLibraryError = err;\n          var autoAuthFailed = err && err.message.indexOf('Could not load the default credentials') > -1;\n\n          if (autoAuthFailed) {\n            // Even though authentication failed, the API might not actually\n            // care.\n            authenticatedReqOpts = reqOpts;\n          }\n\n          if (!err || autoAuthFailed) {\n            try {\n              authenticatedReqOpts = util.decorateRequest(authenticatedReqOpts, projectId);\n              err = null;\n            } catch (e) {\n              // A projectId was required, but we don't have one.\n              // Re-use the \"Could not load the default credentials error\" if\n              // auto auth failed.\n              err = err || e;\n            }\n          }\n\n          if (err) {\n            if (stream) {\n              stream.destroy(err);\n            } else {\n              var fn = options && options.onAuthenticated ? options.onAuthenticated : callback;\n              fn(err);\n            }\n\n            return;\n          }\n\n          if (options && options.onAuthenticated) {\n            options.onAuthenticated(null, authenticatedReqOpts);\n          } else {\n            activeRequest_ = util.makeRequest(authenticatedReqOpts, reqConfig, function (apiResponseError) {\n              if (apiResponseError && apiResponseError.code === 401 && authLibraryError) {\n                // Re-use the \"Could not load the default credentials error\" if\n                // the API request failed due to missing credentials.\n                apiResponseError = authLibraryError;\n              }\n\n              for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                params[_key - 1] = arguments[_key];\n              }\n\n              callback.apply(void 0, [apiResponseError].concat(params));\n            });\n          }\n        };\n\n        Promise.all([config.projectId && config.projectId !== '{{projectId}}' ? // The user provided a project ID. We don't need to check with the\n        // auth client, it could be incorrect.\n        new Promise(function (resolve) {\n          return resolve(config.projectId);\n        }) : authClient.getProjectId(), reqConfig.customEndpoint ? // Using a custom API override. Do not use `google-auth-library` for\n        // authentication. (ex: connecting to a local Datastore server)\n        new Promise(function (resolve) {\n          return resolve(reqOpts);\n        }) : authClient.authorizeRequest(reqOpts)]).then(function (_ref2) {\n          var _ref3 = _slicedToArray(_ref2, 2),\n              _projectId = _ref3[0],\n              authorizedReqOpts = _ref3[1];\n\n          projectId = _projectId;\n          onAuthenticated(null, authorizedReqOpts);\n        }).catch(onAuthenticated);\n\n        if (stream) {\n          return stream;\n        }\n\n        return {\n          abort: function abort() {\n            setImmediate(function () {\n              if (activeRequest_) {\n                activeRequest_.abort();\n                activeRequest_ = null;\n              }\n            });\n          }\n        };\n      }\n\n      var mar = makeAuthenticatedRequest;\n      mar.getCredentials = authClient.getCredentials.bind(authClient);\n      mar.authClient = authClient;\n      return mar;\n    }\n    /**\n     * Make a request through the `retryRequest` module with built-in error\n     * handling and exponential back off.\n     *\n     * @param {object} reqOpts - Request options in the format `request` expects.\n     * @param {object=} config - Configuration object.\n     * @param {boolean=} config.autoRetry - Automatically retry requests if the\n     *     response is related to rate limits or certain intermittent server\n     * errors. We will exponentially backoff subsequent requests by default.\n     * (default: true)\n     * @param {number=} config.maxRetries - Maximum number of automatic retries\n     *     attempted before returning the error. (default: 3)\n     * @param {object=} config.request - HTTP module for request calls.\n     * @param {function} callback - The callback function.\n     */\n\n  }, {\n    key: \"makeRequest\",\n    value: function makeRequest(reqOpts, config, callback) {\n      var _a, _b, _c, _d, _e, _f, _g;\n\n      var autoRetryValue = AUTO_RETRY_DEFAULT;\n\n      if (config.autoRetry !== undefined && ((_a = config.retryOptions) === null || _a === void 0 ? void 0 : _a.autoRetry) !== undefined) {\n        throw new ApiError('autoRetry is deprecated. Use retryOptions.autoRetry instead.');\n      } else if (config.autoRetry !== undefined) {\n        autoRetryValue = config.autoRetry;\n      } else if (((_b = config.retryOptions) === null || _b === void 0 ? void 0 : _b.autoRetry) !== undefined) {\n        autoRetryValue = config.retryOptions.autoRetry;\n      }\n\n      var maxRetryValue = MAX_RETRY_DEFAULT;\n\n      if (config.maxRetries && ((_c = config.retryOptions) === null || _c === void 0 ? void 0 : _c.maxRetries)) {\n        throw new ApiError('maxRetries is deprecated. Use retryOptions.maxRetries instead.');\n      } else if (config.maxRetries) {\n        maxRetryValue = config.maxRetries;\n      } else if ((_d = config.retryOptions) === null || _d === void 0 ? void 0 : _d.maxRetries) {\n        maxRetryValue = config.retryOptions.maxRetries;\n      }\n\n      var options = {\n        request: teeny_request_1.teenyRequest.defaults(requestDefaults),\n        retries: autoRetryValue !== false ? maxRetryValue : 0,\n        shouldRetryFn: function shouldRetryFn(httpRespMessage) {\n          var _a, _b;\n\n          var err = util.parseHttpRespMessage(httpRespMessage).err;\n\n          if ((_a = config.retryOptions) === null || _a === void 0 ? void 0 : _a.retryableErrorFn) {\n            return err && ((_b = config.retryOptions) === null || _b === void 0 ? void 0 : _b.retryableErrorFn(err));\n          }\n\n          return err && util.shouldRetryRequest(err);\n        },\n        maxRetryDelay: (_e = config.retryOptions) === null || _e === void 0 ? void 0 : _e.maxRetryDelay,\n        retryDelayMultiplier: (_f = config.retryOptions) === null || _f === void 0 ? void 0 : _f.retryDelayMultiplier,\n        totalTimeout: (_g = config.retryOptions) === null || _g === void 0 ? void 0 : _g.totalTimeout\n      };\n\n      if (typeof reqOpts.maxRetries === 'number') {\n        options.retries = reqOpts.maxRetries;\n      }\n\n      if (!config.stream) {\n        return retryRequest(reqOpts, options, function (err, response, body) {\n          util.handleResp(err, response, body, callback);\n        });\n      }\n\n      var dup = config.stream; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      var requestStream;\n      var isGetRequest = (reqOpts.method || 'GET').toUpperCase() === 'GET';\n\n      if (isGetRequest) {\n        requestStream = retryRequest(reqOpts, options);\n        dup.setReadable(requestStream);\n      } else {\n        // Streaming writable HTTP requests cannot be retried.\n        requestStream = options.request(reqOpts);\n        dup.setWritable(requestStream);\n      } // Replay the Request events back to the stream.\n\n\n      requestStream.on('error', dup.destroy.bind(dup)).on('response', dup.emit.bind(dup, 'response')).on('complete', dup.emit.bind(dup, 'complete'));\n      dup.abort = requestStream.abort;\n      return dup;\n    }\n    /**\n     * Decorate the options about to be made in a request.\n     *\n     * @param {object} reqOpts - The options to be passed to `request`.\n     * @param {string} projectId - The project ID.\n     * @return {object} reqOpts - The decorated reqOpts.\n     */\n\n  }, {\n    key: \"decorateRequest\",\n    value: function decorateRequest(reqOpts, projectId) {\n      delete reqOpts.autoPaginate;\n      delete reqOpts.autoPaginateVal;\n      delete reqOpts.objectMode;\n\n      if (reqOpts.qs !== null && typeof reqOpts.qs === 'object') {\n        delete reqOpts.qs.autoPaginate;\n        delete reqOpts.qs.autoPaginateVal;\n        reqOpts.qs = projectify_1.replaceProjectIdToken(reqOpts.qs, projectId);\n      }\n\n      if (Array.isArray(reqOpts.multipart)) {\n        reqOpts.multipart = reqOpts.multipart.map(function (part) {\n          return projectify_1.replaceProjectIdToken(part, projectId);\n        });\n      }\n\n      if (reqOpts.json !== null && typeof reqOpts.json === 'object') {\n        delete reqOpts.json.autoPaginate;\n        delete reqOpts.json.autoPaginateVal;\n        reqOpts.json = projectify_1.replaceProjectIdToken(reqOpts.json, projectId);\n      }\n\n      reqOpts.uri = projectify_1.replaceProjectIdToken(reqOpts.uri, projectId);\n      return reqOpts;\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  }, {\n    key: \"isCustomType\",\n    value: function isCustomType(unknown, module) {\n      function getConstructorName(obj) {\n        return obj.constructor && obj.constructor.name.toLowerCase();\n      }\n\n      var moduleNameParts = module.split('/');\n      var parentModuleName = moduleNameParts[0] && moduleNameParts[0].toLowerCase();\n      var subModuleName = moduleNameParts[1] && moduleNameParts[1].toLowerCase();\n\n      if (subModuleName && getConstructorName(unknown) !== subModuleName) {\n        return false;\n      }\n\n      var walkingModule = unknown; // eslint-disable-next-line no-constant-condition\n\n      while (true) {\n        if (getConstructorName(walkingModule) === parentModuleName) {\n          return true;\n        }\n\n        walkingModule = walkingModule.parent;\n\n        if (!walkingModule) {\n          return false;\n        }\n      }\n    }\n    /**\n     * Create a properly-formatted User-Agent string from a package.json file.\n     *\n     * @param {object} packageJson - A module's package.json file.\n     * @return {string} userAgent - The formatted User-Agent string.\n     */\n\n  }, {\n    key: \"getUserAgentFromPackageJson\",\n    value: function getUserAgentFromPackageJson(packageJson) {\n      var hyphenatedPackageName = packageJson.name.replace('@google-cloud', 'gcloud-node') // For legacy purposes.\n      .replace('/', '-'); // For UA spec-compliance purposes.\n\n      return hyphenatedPackageName + '/' + packageJson.version;\n    }\n    /**\n     * Given two parameters, figure out if this is either:\n     *  - Just a callback function\n     *  - An options object, and then a callback function\n     * @param optionsOrCallback An options object or callback.\n     * @param cb A potentially undefined callback.\n     */\n\n  }, {\n    key: \"maybeOptionsOrCallback\",\n    value: function maybeOptionsOrCallback(optionsOrCallback, cb) {\n      return typeof optionsOrCallback === 'function' ? [{}, optionsOrCallback] : [optionsOrCallback, cb];\n    }\n  }]);\n\n  return Util;\n}();\n\nexports.Util = Util;\n/**\n * Basic Passthrough Stream that records the number of bytes read\n * every time the cursor is moved.\n */\n\nvar ProgressStream = /*#__PURE__*/function (_stream_1$Transform) {\n  _inherits(ProgressStream, _stream_1$Transform);\n\n  function ProgressStream() {\n    var _this3;\n\n    _classCallCheck(this, ProgressStream);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(ProgressStream).apply(this, arguments));\n    _this3.bytesRead = 0;\n    return _this3;\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  _createClass(ProgressStream, [{\n    key: \"_transform\",\n    value: function _transform(chunk, encoding, callback) {\n      this.bytesRead += chunk.length;\n      this.emit('progress', {\n        bytesWritten: this.bytesRead,\n        contentLength: '*'\n      });\n      this.push(chunk);\n      callback();\n    }\n  }]);\n\n  return ProgressStream;\n}(stream_1.Transform);\n\nvar util = new Util();\nexports.util = util;","map":null,"metadata":{},"sourceType":"script"}