{"ast":null,"code":"var _toConsumableArray = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar base64url = require('../help/base64url');\n\nvar isDisjoint = require('../help/is_disjoint');\n\nvar isObject = require('../help/is_object');\n\nvar deepClone = require('../help/deep_clone');\n\nvar _require = require('../errors'),\n    JWSInvalid = _require.JWSInvalid;\n\nvar _require2 = require('../jwa'),\n    sign = _require2.sign;\n\nvar getKey = require('../help/get_key');\n\nvar serializers = require('./serializers');\n\nvar PROCESS_RECIPIENT = Symbol('PROCESS_RECIPIENT');\n\nvar Sign = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function Sign(payload) {\n    _classCallCheck(this, Sign);\n\n    if (typeof payload === 'string') {\n      payload = base64url.encode(payload);\n    } else if (Buffer.isBuffer(payload)) {\n      payload = base64url.encodeBuffer(payload);\n      this._binary = true;\n    } else if (isObject(payload)) {\n      payload = base64url.JSON.encode(payload);\n    } else {\n      throw new TypeError('payload argument must be a Buffer, string or an object');\n    }\n\n    this._payload = payload;\n    this._recipients = [];\n  }\n  /*\n   * @public\n   */\n\n\n  _createClass(Sign, [{\n    key: \"recipient\",\n    value: function recipient(key, protectedHeader, unprotectedHeader) {\n      key = getKey(key);\n\n      if (protectedHeader !== undefined && !isObject(protectedHeader)) {\n        throw new TypeError('protectedHeader argument must be a plain object when provided');\n      }\n\n      if (unprotectedHeader !== undefined && !isObject(unprotectedHeader)) {\n        throw new TypeError('unprotectedHeader argument must be a plain object when provided');\n      }\n\n      if (!isDisjoint(protectedHeader, unprotectedHeader)) {\n        throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n      }\n\n      this._recipients.push({\n        key: key,\n        protectedHeader: protectedHeader ? deepClone(protectedHeader) : undefined,\n        unprotectedHeader: unprotectedHeader ? deepClone(unprotectedHeader) : undefined\n      });\n\n      return this;\n    }\n    /*\n     * @private\n     */\n\n  }, {\n    key: PROCESS_RECIPIENT,\n    value: function value(recipient, first) {\n      var key = recipient.key,\n          protectedHeader = recipient.protectedHeader,\n          unprotectedHeader = recipient.unprotectedHeader;\n\n      if (key.use === 'enc') {\n        throw new TypeError('a key with \"use\":\"enc\" is not usable for signing');\n      }\n\n      var joseHeader = {\n        protected: protectedHeader || {},\n        unprotected: unprotectedHeader || {}\n      };\n      var alg = joseHeader.protected.alg || joseHeader.unprotected.alg;\n\n      if (!alg) {\n        alg = key.alg || _toConsumableArray(key.algorithms('sign'))[0];\n\n        if (recipient.protectedHeader) {\n          joseHeader.protected.alg = recipient.protectedHeader.alg = alg;\n        } else {\n          joseHeader.protected = recipient.protectedHeader = {\n            alg: alg\n          };\n        }\n      }\n\n      if (!alg) {\n        throw new JWSInvalid('could not resolve a usable \"alg\" for a recipient');\n      }\n\n      recipient.header = unprotectedHeader;\n      recipient.protected = Object.keys(joseHeader.protected).length ? base64url.JSON.encode(joseHeader.protected) : '';\n\n      if (first && joseHeader.protected.crit && joseHeader.protected.crit.includes('b64') && joseHeader.protected.b64 === false) {\n        if (this._binary) {\n          this._payload = base64url.decodeToBuffer(this._payload);\n        } else {\n          this._payload = base64url.decode(this._payload);\n        }\n      }\n\n      var data = Buffer.concat([Buffer.from(recipient.protected || ''), Buffer.from('.'), Buffer.from(this._payload)]);\n      recipient.signature = base64url.encodeBuffer(sign(alg, key, data));\n    }\n    /*\n     * @public\n     */\n\n  }, {\n    key: \"sign\",\n    value: function sign(serialization) {\n      var _this = this;\n\n      var serializer = serializers[serialization];\n\n      if (!serializer) {\n        throw new TypeError('serialization must be one of \"compact\", \"flattened\", \"general\"');\n      }\n\n      if (!this._recipients.length) {\n        throw new JWSInvalid('missing recipients');\n      }\n\n      serializer.validate(this, this._recipients);\n\n      this._recipients.forEach(function (recipient, i) {\n        _this[PROCESS_RECIPIENT](recipient, i === 0);\n      });\n\n      return serializer(this._payload, this._recipients);\n    }\n  }]);\n\n  return Sign;\n}();\n\nmodule.exports = Sign;","map":null,"metadata":{},"sourceType":"script"}