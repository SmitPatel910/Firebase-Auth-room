{"ast":null,"code":"/*! firebase-admin v9.11.0 */\n\"use strict\";\n/*!\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UserRecord = exports.UserInfo = exports.UserMetadata = exports.MultiFactor = exports.PhoneMultiFactorInfo = exports.MultiFactorInfo = void 0;\n\nvar deep_copy_1 = require(\"../utils/deep-copy\");\n\nvar validator_1 = require(\"../utils/validator\");\n\nvar utils = require(\"../utils\");\n\nvar error_1 = require(\"../utils/error\");\n/**\n * 'REDACTED', encoded as a base64 string.\n */\n\n\nvar B64_REDACTED = Buffer.from('REDACTED').toString('base64');\n/**\n * Parses a time stamp string or number and returns the corresponding date if valid.\n *\n * @param {any} time The unix timestamp string or number in milliseconds.\n * @return {string} The corresponding date as a UTC string, if valid. Otherwise, null.\n */\n\nfunction parseDate(time) {\n  try {\n    var date = new Date(parseInt(time, 10));\n\n    if (!isNaN(date.getTime())) {\n      return date.toUTCString();\n    }\n  } catch (e) {// Do nothing. null will be returned.\n  }\n\n  return null;\n}\n\nvar MultiFactorId;\n\n(function (MultiFactorId) {\n  MultiFactorId[\"Phone\"] = \"phone\";\n})(MultiFactorId || (MultiFactorId = {}));\n/**\n * Abstract class representing a multi-factor info interface.\n */\n\n\nvar MultiFactorInfo =\n/** @class */\nfunction () {\n  /**\n   * Initializes the MultiFactorInfo object using the server side response.\n   *\n   * @param response The server side response.\n   * @constructor\n   */\n  function MultiFactorInfo(response) {\n    this.initFromServerResponse(response);\n  }\n  /**\n   * Initializes the MultiFactorInfo associated subclass using the server side.\n   * If no MultiFactorInfo is associated with the response, null is returned.\n   *\n   * @param response The server side response.\n   * @constructor\n   */\n\n\n  MultiFactorInfo.initMultiFactorInfo = function (response) {\n    var multiFactorInfo = null; // Only PhoneMultiFactorInfo currently available.\n\n    try {\n      multiFactorInfo = new PhoneMultiFactorInfo(response);\n    } catch (e) {// Ignore error.\n    }\n\n    return multiFactorInfo;\n  };\n  /** @return The plain object representation. */\n\n\n  MultiFactorInfo.prototype.toJSON = function () {\n    return {\n      uid: this.uid,\n      displayName: this.displayName,\n      factorId: this.factorId,\n      enrollmentTime: this.enrollmentTime\n    };\n  };\n  /**\n   * Initializes the MultiFactorInfo object using the provided server response.\n   *\n   * @param response The server side response.\n   */\n\n\n  MultiFactorInfo.prototype.initFromServerResponse = function (response) {\n    var factorId = response && this.getFactorId(response);\n\n    if (!factorId || !response || !response.mfaEnrollmentId) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor info response');\n    }\n\n    utils.addReadonlyGetter(this, 'uid', response.mfaEnrollmentId);\n    utils.addReadonlyGetter(this, 'factorId', factorId);\n    utils.addReadonlyGetter(this, 'displayName', response.displayName); // Encoded using [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format.\n    // For example, \"2017-01-15T01:30:15.01Z\".\n    // This can be parsed directly via Date constructor.\n    // This can be computed using Data.prototype.toISOString.\n\n    if (response.enrolledAt) {\n      utils.addReadonlyGetter(this, 'enrollmentTime', new Date(response.enrolledAt).toUTCString());\n    } else {\n      utils.addReadonlyGetter(this, 'enrollmentTime', null);\n    }\n  };\n\n  return MultiFactorInfo;\n}();\n\nexports.MultiFactorInfo = MultiFactorInfo;\n/** Class representing a phone MultiFactorInfo object. */\n\nvar PhoneMultiFactorInfo =\n/** @class */\nfunction (_super) {\n  __extends(PhoneMultiFactorInfo, _super);\n  /**\n   * Initializes the PhoneMultiFactorInfo object using the server side response.\n   *\n   * @param response The server side response.\n   * @constructor\n   */\n\n\n  function PhoneMultiFactorInfo(response) {\n    var _this = _super.call(this, response) || this;\n\n    utils.addReadonlyGetter(_this, 'phoneNumber', response.phoneInfo);\n    return _this;\n  }\n  /** @return The plain object representation. */\n\n\n  PhoneMultiFactorInfo.prototype.toJSON = function () {\n    return Object.assign(_super.prototype.toJSON.call(this), {\n      phoneNumber: this.phoneNumber\n    });\n  };\n  /**\n   * Returns the factor ID based on the response provided.\n   *\n   * @param response The server side response.\n   * @return The multi-factor ID associated with the provided response. If the response is\n   *     not associated with any known multi-factor ID, null is returned.\n   */\n\n\n  PhoneMultiFactorInfo.prototype.getFactorId = function (response) {\n    return response && response.phoneInfo ? MultiFactorId.Phone : null;\n  };\n\n  return PhoneMultiFactorInfo;\n}(MultiFactorInfo);\n\nexports.PhoneMultiFactorInfo = PhoneMultiFactorInfo;\n/** Class representing multi-factor related properties of a user. */\n\nvar MultiFactor =\n/** @class */\nfunction () {\n  /**\n   * Initializes the MultiFactor object using the server side or JWT format response.\n   *\n   * @param response The server side response.\n   * @constructor\n   */\n  function MultiFactor(response) {\n    var parsedEnrolledFactors = [];\n\n    if (!validator_1.isNonNullObject(response)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor response');\n    } else if (response.mfaInfo) {\n      response.mfaInfo.forEach(function (factorResponse) {\n        var multiFactorInfo = MultiFactorInfo.initMultiFactorInfo(factorResponse);\n\n        if (multiFactorInfo) {\n          parsedEnrolledFactors.push(multiFactorInfo);\n        }\n      });\n    } // Make enrolled factors immutable.\n\n\n    utils.addReadonlyGetter(this, 'enrolledFactors', Object.freeze(parsedEnrolledFactors));\n  }\n  /** @return The plain object representation. */\n\n\n  MultiFactor.prototype.toJSON = function () {\n    return {\n      enrolledFactors: this.enrolledFactors.map(function (info) {\n        return info.toJSON();\n      })\n    };\n  };\n\n  return MultiFactor;\n}();\n\nexports.MultiFactor = MultiFactor;\n/**\n * User metadata class that provides metadata information like user account creation\n * and last sign in time.\n *\n * @param response The server side response returned from the getAccountInfo\n *     endpoint.\n * @constructor\n */\n\nvar UserMetadata =\n/** @class */\nfunction () {\n  function UserMetadata(response) {\n    // Creation date should always be available but due to some backend bugs there\n    // were cases in the past where users did not have creation date properly set.\n    // This included legacy Firebase migrating project users and some anonymous users.\n    // These bugs have already been addressed since then.\n    utils.addReadonlyGetter(this, 'creationTime', parseDate(response.createdAt));\n    utils.addReadonlyGetter(this, 'lastSignInTime', parseDate(response.lastLoginAt));\n    var lastRefreshAt = response.lastRefreshAt ? new Date(response.lastRefreshAt).toUTCString() : null;\n    utils.addReadonlyGetter(this, 'lastRefreshTime', lastRefreshAt);\n  }\n  /** @return The plain object representation of the user's metadata. */\n\n\n  UserMetadata.prototype.toJSON = function () {\n    return {\n      lastSignInTime: this.lastSignInTime,\n      creationTime: this.creationTime\n    };\n  };\n\n  return UserMetadata;\n}();\n\nexports.UserMetadata = UserMetadata;\n/**\n * User info class that provides provider user information for different\n * Firebase providers like google.com, facebook.com, password, etc.\n *\n * @param response The server side response returned from the getAccountInfo\n *     endpoint.\n * @constructor\n */\n\nvar UserInfo =\n/** @class */\nfunction () {\n  function UserInfo(response) {\n    // Provider user id and provider id are required.\n    if (!response.rawId || !response.providerId) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid user info response');\n    }\n\n    utils.addReadonlyGetter(this, 'uid', response.rawId);\n    utils.addReadonlyGetter(this, 'displayName', response.displayName);\n    utils.addReadonlyGetter(this, 'email', response.email);\n    utils.addReadonlyGetter(this, 'photoURL', response.photoUrl);\n    utils.addReadonlyGetter(this, 'providerId', response.providerId);\n    utils.addReadonlyGetter(this, 'phoneNumber', response.phoneNumber);\n  }\n  /** @return The plain object representation of the current provider data. */\n\n\n  UserInfo.prototype.toJSON = function () {\n    return {\n      uid: this.uid,\n      displayName: this.displayName,\n      email: this.email,\n      photoURL: this.photoURL,\n      providerId: this.providerId,\n      phoneNumber: this.phoneNumber\n    };\n  };\n\n  return UserInfo;\n}();\n\nexports.UserInfo = UserInfo;\n/**\n * User record class that defines the Firebase user object populated from\n * the Firebase Auth getAccountInfo response.\n *\n * @param response The server side response returned from the getAccountInfo\n *     endpoint.\n * @constructor\n */\n\nvar UserRecord =\n/** @class */\nfunction () {\n  function UserRecord(response) {\n    // The Firebase user id is required.\n    if (!response.localId) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid user response');\n    }\n\n    utils.addReadonlyGetter(this, 'uid', response.localId);\n    utils.addReadonlyGetter(this, 'email', response.email);\n    utils.addReadonlyGetter(this, 'emailVerified', !!response.emailVerified);\n    utils.addReadonlyGetter(this, 'displayName', response.displayName);\n    utils.addReadonlyGetter(this, 'photoURL', response.photoUrl);\n    utils.addReadonlyGetter(this, 'phoneNumber', response.phoneNumber); // If disabled is not provided, the account is enabled by default.\n\n    utils.addReadonlyGetter(this, 'disabled', response.disabled || false);\n    utils.addReadonlyGetter(this, 'metadata', new UserMetadata(response));\n    var providerData = [];\n\n    for (var _i = 0, _a = response.providerUserInfo || []; _i < _a.length; _i++) {\n      var entry = _a[_i];\n      providerData.push(new UserInfo(entry));\n    }\n\n    utils.addReadonlyGetter(this, 'providerData', providerData); // If the password hash is redacted (probably due to missing permissions)\n    // then clear it out, similar to how the salt is returned. (Otherwise, it\n    // *looks* like a b64-encoded hash is present, which is confusing.)\n\n    if (response.passwordHash === B64_REDACTED) {\n      utils.addReadonlyGetter(this, 'passwordHash', undefined);\n    } else {\n      utils.addReadonlyGetter(this, 'passwordHash', response.passwordHash);\n    }\n\n    utils.addReadonlyGetter(this, 'passwordSalt', response.salt);\n\n    if (response.customAttributes) {\n      utils.addReadonlyGetter(this, 'customClaims', JSON.parse(response.customAttributes));\n    }\n\n    var validAfterTime = null; // Convert validSince first to UTC milliseconds and then to UTC date string.\n\n    if (typeof response.validSince !== 'undefined') {\n      validAfterTime = parseDate(parseInt(response.validSince, 10) * 1000);\n    }\n\n    utils.addReadonlyGetter(this, 'tokensValidAfterTime', validAfterTime || undefined);\n    utils.addReadonlyGetter(this, 'tenantId', response.tenantId);\n    var multiFactor = new MultiFactor(response);\n\n    if (multiFactor.enrolledFactors.length > 0) {\n      utils.addReadonlyGetter(this, 'multiFactor', multiFactor);\n    }\n  }\n  /** @return The plain object representation of the user record. */\n\n\n  UserRecord.prototype.toJSON = function () {\n    var json = {\n      uid: this.uid,\n      email: this.email,\n      emailVerified: this.emailVerified,\n      displayName: this.displayName,\n      photoURL: this.photoURL,\n      phoneNumber: this.phoneNumber,\n      disabled: this.disabled,\n      // Convert metadata to json.\n      metadata: this.metadata.toJSON(),\n      passwordHash: this.passwordHash,\n      passwordSalt: this.passwordSalt,\n      customClaims: deep_copy_1.deepCopy(this.customClaims),\n      tokensValidAfterTime: this.tokensValidAfterTime,\n      tenantId: this.tenantId\n    };\n\n    if (this.multiFactor) {\n      json.multiFactor = this.multiFactor.toJSON();\n    }\n\n    json.providerData = [];\n\n    for (var _i = 0, _a = this.providerData; _i < _a.length; _i++) {\n      var entry = _a[_i]; // Convert each provider data to json.\n\n      json.providerData.push(entry.toJSON());\n    }\n\n    return json;\n  };\n\n  return UserRecord;\n}();\n\nexports.UserRecord = UserRecord;","map":null,"metadata":{},"sourceType":"script"}