{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _toConsumableArray = require(\"C:\\\\Users\\\\Smit\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Smit\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Smit\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Task = exports.deepCopyForResponse = void 0;\n\nvar status_1 = require(\"../status\");\n\nvar googleError_1 = require(\"../googleError\");\n/**\n * Creates a deep copy of the object with the consideration of subresponse\n * fields for bundling.\n *\n * @param {Object} obj - The source object.\n * @param {Object?} subresponseInfo - The information to copy the subset of\n *   the field for the response. Do nothing if it's null.\n * @param {String} subresponseInfo.field - The field name.\n * @param {number} subresponseInfo.start - The offset where the copying\n *   element should starts with.\n * @param {number} subresponseInfo.end - The ending index where the copying\n *   region of the elements ends.\n * @return {Object} The copied object.\n * @private\n */\n\n\nfunction deepCopyForResponse( // eslint-disable-next-line @typescript-eslint/no-explicit-any\nobj, subresponseInfo) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  var result;\n\n  if (obj === null) {\n    return null;\n  }\n\n  if (obj === undefined) {\n    return undefined;\n  }\n\n  if (Array.isArray(obj)) {\n    result = [];\n    obj.forEach(function (element) {\n      result.push(deepCopyForResponse(element, null));\n    });\n    return result;\n  } // Some objects (such as ByteBuffer) have copy method.\n\n\n  if (obj.copy !== undefined) {\n    return obj.copy();\n  } // ArrayBuffer should be copied through slice().\n\n\n  if (obj instanceof ArrayBuffer) {\n    return obj.slice(0);\n  }\n\n  if (typeof obj === 'object') {\n    result = {};\n    Object.keys(obj).forEach(function (key) {\n      if (subresponseInfo && key === subresponseInfo.field && Array.isArray(obj[key])) {\n        // Note that subresponses are not deep-copied. This is safe because\n        // those subresponses are not shared among callbacks.\n        result[key] = obj[key].slice(subresponseInfo.start, subresponseInfo.end);\n      } else {\n        result[key] = deepCopyForResponse(obj[key], null);\n      }\n    });\n    return result;\n  }\n\n  return obj;\n}\n\nexports.deepCopyForResponse = deepCopyForResponse;\n\nvar Task = /*#__PURE__*/function () {\n  /**\n   * A task coordinates the execution of a single bundle.\n   *\n   * @param {function} apiCall - The function to conduct calling API.\n   * @param {Object} bundlingRequest - The base request object to be used\n   *   for the actual API call.\n   * @param {string} bundledField - The name of the field in bundlingRequest\n   *   to be bundled.\n   * @param {string=} subresponseField - The name of the field in the response\n   *   to be passed to the callback.\n   * @constructor\n   * @private\n   */\n  function Task(apiCall, bundlingRequest, bundledField, subresponseField) {\n    _classCallCheck(this, Task);\n\n    this._apiCall = apiCall;\n    this._request = bundlingRequest;\n    this._bundledField = bundledField;\n    this._subresponseField = subresponseField;\n    this._data = [];\n  }\n  /**\n   * Returns the number of elements in a task.\n   * @return {number} The number of elements.\n   */\n\n\n  _createClass(Task, [{\n    key: \"getElementCount\",\n    value: function getElementCount() {\n      var count = 0;\n\n      for (var i = 0; i < this._data.length; ++i) {\n        count += this._data[i].elements.length;\n      }\n\n      return count;\n    }\n    /**\n     * Returns the total byte size of the elements in a task.\n     * @return {number} The byte size.\n     */\n\n  }, {\n    key: \"getRequestByteSize\",\n    value: function getRequestByteSize() {\n      var size = 0;\n\n      for (var i = 0; i < this._data.length; ++i) {\n        size += this._data[i].bytes;\n      }\n\n      return size;\n    }\n    /**\n     * Invokes the actual API call with current elements.\n     * @return {string[]} - the list of ids for invocations to be run.\n     */\n\n  }, {\n    key: \"run\",\n    value: function run() {\n      if (this._data.length === 0) {\n        return [];\n      }\n\n      var request = this._request;\n      var elements = [];\n      var ids = [];\n\n      for (var i = 0; i < this._data.length; ++i) {\n        elements.push.apply(elements, _toConsumableArray(this._data[i].elements));\n        ids.push(this._data[i].callback.id);\n      }\n\n      request[this._bundledField] = elements; // eslint-disable-next-line @typescript-eslint/no-this-alias\n\n      var self = this;\n      this.callCanceller = this._apiCall(request, function (err, response) {\n        var responses = [];\n\n        if (err) {\n          self._data.forEach(function () {\n            responses.push(undefined);\n          });\n        } else {\n          var subresponseInfo = null;\n\n          if (self._subresponseField) {\n            subresponseInfo = {\n              field: self._subresponseField,\n              start: 0\n            };\n          }\n\n          self._data.forEach(function (data) {\n            if (subresponseInfo) {\n              subresponseInfo.end = subresponseInfo.start + data.elements.length;\n            }\n\n            responses.push(deepCopyForResponse(response, subresponseInfo));\n\n            if (subresponseInfo) {\n              subresponseInfo.start = subresponseInfo.end;\n            }\n          });\n        }\n\n        for (var _i = 0; _i < self._data.length; ++_i) {\n          if (self._data[_i].cancelled) {\n            var error = new googleError_1.GoogleError('cancelled');\n            error.code = status_1.Status.CANCELLED;\n\n            self._data[_i].callback(error);\n          } else {\n            self._data[_i].callback(err, responses[_i]);\n          }\n        }\n      });\n      return ids;\n    }\n    /**\n     * Appends the list of elements into the task.\n     * @param {Object[]} elements - the new list of elements.\n     * @param {number} bytes - the byte size required to encode elements in the API.\n     * @param {APICallback} callback - the callback of the method call.\n     */\n\n  }, {\n    key: \"extend\",\n    value: function extend(elements, bytes, callback) {\n      this._data.push({\n        elements: elements,\n        bytes: bytes,\n        callback: callback\n      });\n    }\n    /**\n     * Cancels a part of elements.\n     * @param {string} id - The identifier of the part of elements.\n     * @return {boolean} Whether the entire task will be canceled or not.\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function cancel(id) {\n      if (this.callCanceller) {\n        var allCancelled = true;\n\n        this._data.forEach(function (d) {\n          if (d.callback.id === id) {\n            d.cancelled = true;\n          }\n\n          if (!d.cancelled) {\n            allCancelled = false;\n          }\n        });\n\n        if (allCancelled) {\n          this.callCanceller.cancel();\n        }\n\n        return allCancelled;\n      }\n\n      for (var i = 0; i < this._data.length; ++i) {\n        if (this._data[i].callback.id === id) {\n          var error = new googleError_1.GoogleError('cancelled');\n          error.code = status_1.Status.CANCELLED;\n\n          this._data[i].callback(error);\n\n          this._data.splice(i, 1);\n\n          break;\n        }\n      }\n\n      return this._data.length === 0;\n    }\n  }]);\n\n  return Task;\n}();\n\nexports.Task = Task;","map":null,"metadata":{},"sourceType":"script"}