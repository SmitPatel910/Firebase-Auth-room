{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar validate_1 = require(\"./validate\");\n/*!\n * @module firestore/convert\n * @private\n * @internal\n *\n * This module contains utility functions to convert\n * `firestore.v1.Documents` from Proto3 JSON to their equivalent\n * representation in Protobuf JS. Protobuf JS is the only encoding supported by\n * this client, and dependencies that use Proto3 JSON (such as the Google Cloud\n * Functions SDK) are supported through this conversion and its usage in\n * {@see Firestore#snapshot_}.\n */\n\n/**\n * Converts an ISO 8601 or google.protobuf.Timestamp proto into Protobuf JS.\n *\n * @private\n * @internal\n * @param timestampValue The value to convert.\n * @param argumentName The argument name to use in the error message if the\n * conversion fails. If omitted, 'timestampValue' is used.\n * @return The value as expected by Protobuf JS or undefined if no input was\n * provided.\n */\n\n\nfunction timestampFromJson(timestampValue, argumentName) {\n  var timestampProto = {};\n\n  if (typeof timestampValue === 'string') {\n    var date = new Date(timestampValue);\n    var seconds = Math.floor(date.getTime() / 1000);\n    var nanos = 0;\n\n    if (timestampValue.length > 20) {\n      var nanoString = timestampValue.substring(20, timestampValue.length - 1);\n      var trailingZeroes = 9 - nanoString.length;\n      nanos = Number(nanoString) * Math.pow(10, trailingZeroes);\n    }\n\n    if (isNaN(seconds) || isNaN(nanos)) {\n      argumentName = argumentName || 'timestampValue';\n      throw new Error(\"Specify a valid ISO 8601 timestamp for \\\"\".concat(argumentName, \"\\\".\"));\n    }\n\n    timestampProto = {\n      seconds: seconds || undefined,\n      nanos: nanos || undefined\n    };\n  } else if (timestampValue !== undefined) {\n    validate_1.validateObject('timestampValue', timestampValue);\n    timestampProto = {\n      seconds: timestampValue.seconds || undefined,\n      nanos: timestampValue.nanos || undefined\n    };\n  }\n\n  return timestampProto;\n}\n\nexports.timestampFromJson = timestampFromJson;\n/**\n * Converts a Proto3 JSON 'bytesValue' field into Protobuf JS.\n *\n * @private\n * @internal\n * @param bytesValue The value to convert.\n * @return The value as expected by Protobuf JS.\n */\n\nfunction bytesFromJson(bytesValue) {\n  if (typeof bytesValue === 'string') {\n    return Buffer.from(bytesValue, 'base64');\n  } else {\n    return bytesValue;\n  }\n}\n/**\n * Detects 'valueType' from a Proto3 JSON `firestore.v1.Value` proto.\n *\n * @private\n * @internal\n * @param proto The `firestore.v1.Value` proto.\n * @return The string value for 'valueType'.\n */\n\n\nfunction detectValueType(proto) {\n  if (proto.valueType) {\n    return proto.valueType;\n  }\n\n  var detectedValues = [];\n\n  if (proto.stringValue !== undefined) {\n    detectedValues.push('stringValue');\n  }\n\n  if (proto.booleanValue !== undefined) {\n    detectedValues.push('booleanValue');\n  }\n\n  if (proto.integerValue !== undefined) {\n    detectedValues.push('integerValue');\n  }\n\n  if (proto.doubleValue !== undefined) {\n    detectedValues.push('doubleValue');\n  }\n\n  if (proto.timestampValue !== undefined) {\n    detectedValues.push('timestampValue');\n  }\n\n  if (proto.referenceValue !== undefined) {\n    detectedValues.push('referenceValue');\n  }\n\n  if (proto.arrayValue !== undefined) {\n    detectedValues.push('arrayValue');\n  }\n\n  if (proto.nullValue !== undefined) {\n    detectedValues.push('nullValue');\n  }\n\n  if (proto.mapValue !== undefined) {\n    detectedValues.push('mapValue');\n  }\n\n  if (proto.geoPointValue !== undefined) {\n    detectedValues.push('geoPointValue');\n  }\n\n  if (proto.bytesValue !== undefined) {\n    detectedValues.push('bytesValue');\n  }\n\n  if (detectedValues.length !== 1) {\n    throw new Error(\"Unable to infer type value fom '\".concat(JSON.stringify(proto), \"'.\"));\n  }\n\n  return detectedValues[0];\n}\n\nexports.detectValueType = detectValueType;\n/**\n * Converts a `firestore.v1.Value` in Proto3 JSON encoding into the\n * Protobuf JS format expected by this client.\n *\n * @private\n * @internal\n * @param fieldValue The `firestore.v1.Value` in Proto3 JSON format.\n * @return The `firestore.v1.Value` in Protobuf JS format.\n */\n\nfunction valueFromJson(fieldValue) {\n  var valueType = detectValueType(fieldValue);\n\n  switch (valueType) {\n    case 'timestampValue':\n      return {\n        timestampValue: timestampFromJson(fieldValue.timestampValue)\n      };\n\n    case 'bytesValue':\n      return {\n        bytesValue: bytesFromJson(fieldValue.bytesValue)\n      };\n\n    case 'doubleValue':\n      return {\n        doubleValue: Number(fieldValue.doubleValue)\n      };\n\n    case 'arrayValue':\n      {\n        var arrayValue = [];\n\n        if (Array.isArray(fieldValue.arrayValue.values)) {\n          var _iterator = _createForOfIteratorHelper(fieldValue.arrayValue.values),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var value = _step.value;\n              arrayValue.push(valueFromJson(value));\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n\n        return {\n          arrayValue: {\n            values: arrayValue\n          }\n        };\n      }\n\n    case 'mapValue':\n      {\n        var mapValue = {};\n        var fields = fieldValue.mapValue.fields;\n\n        if (fields) {\n          for (var _i = 0, _Object$keys = Object.keys(fields); _i < _Object$keys.length; _i++) {\n            var prop = _Object$keys[_i];\n            mapValue[prop] = valueFromJson(fieldValue.mapValue.fields[prop]);\n          }\n        }\n\n        return {\n          mapValue: {\n            fields: mapValue\n          }\n        };\n      }\n\n    default:\n      return fieldValue;\n  }\n}\n\nexports.valueFromJson = valueFromJson;\n/**\n * Converts a map of IValues in Proto3 JSON encoding into the Protobuf JS format\n * expected by this client. This conversion creates a copy of the underlying\n * fields.\n *\n * @private\n * @internal\n * @param document An object with IValues in Proto3 JSON format.\n * @return The object in Protobuf JS format.\n */\n\nfunction fieldsFromJson(document) {\n  var result = {};\n\n  for (var _i2 = 0, _Object$keys2 = Object.keys(document); _i2 < _Object$keys2.length; _i2++) {\n    var prop = _Object$keys2[_i2];\n    result[prop] = valueFromJson(document[prop]);\n  }\n\n  return result;\n}\n\nexports.fieldsFromJson = fieldsFromJson;","map":null,"metadata":{},"sourceType":"script"}