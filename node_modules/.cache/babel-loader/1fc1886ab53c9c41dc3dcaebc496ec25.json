{"ast":null,"code":"\"use strict\"; // Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromProto3JSON = exports.fromProto3JSONToInternalRepresentation = void 0;\n\nvar assert = require(\"assert\");\n\nvar any_1 = require(\"./any\");\n\nvar bytes_1 = require(\"./bytes\");\n\nvar enum_1 = require(\"./enum\");\n\nvar value_1 = require(\"./value\");\n\nvar util_1 = require(\"./util\");\n\nvar duration_1 = require(\"./duration\");\n\nvar timestamp_1 = require(\"./timestamp\");\n\nvar wrappers_1 = require(\"./wrappers\");\n\nvar fieldmask_1 = require(\"./fieldmask\");\n\nfunction fromProto3JSONToInternalRepresentation(type, json) {\n  var fullyQualifiedTypeName = typeof type === 'string' ? type : util_1.getFullyQualifiedTypeName(type);\n\n  if (typeof type !== 'string' && 'values' in type) {\n    // type is an Enum\n    if (fullyQualifiedTypeName === '.google.protobuf.NullValue') {\n      return 'NULL_VALUE';\n    }\n\n    return enum_1.resolveEnumValueToString(type, json);\n  }\n\n  if (typeof type !== 'string') {\n    type.resolveAll();\n  }\n\n  if (typeof type === 'string') {\n    return json;\n  } // Types that require special handling according to\n  // https://developers.google.com/protocol-buffers/docs/proto3#json\n  // Types that can have meaningful \"null\" value\n\n\n  if (fullyQualifiedTypeName === '.google.protobuf.Value') {\n    return value_1.googleProtobufValueFromProto3JSON(json);\n  }\n\n  if (util_1.wrapperTypes.has(fullyQualifiedTypeName)) {\n    if (json !== null && typeof json === 'object' || Array.isArray(json)) {\n      throw new Error(\"fromProto3JSONToInternalRepresentation: JSON representation for \".concat(fullyQualifiedTypeName, \" expects a string, a number, or a boolean, but got \").concat(typeof json));\n    }\n\n    return wrappers_1.wrapperFromProto3JSON(fullyQualifiedTypeName, json);\n  }\n\n  if (json === null) {\n    return null;\n  } // Types that cannot be \"null\"\n\n\n  if (fullyQualifiedTypeName === '.google.protobuf.Any') {\n    return any_1.googleProtobufAnyFromProto3JSON(type.root, json);\n  }\n\n  if (fullyQualifiedTypeName === '.google.protobuf.Struct') {\n    if (typeof json !== 'object') {\n      throw new Error(\"fromProto3JSONToInternalRepresentation: google.protobuf.Struct must be an object but got \".concat(typeof json));\n    }\n\n    if (Array.isArray(json)) {\n      throw new Error('fromProto3JSONToInternalRepresentation: google.protobuf.Struct must be an object but got an array');\n    }\n\n    return value_1.googleProtobufStructFromProto3JSON(json);\n  }\n\n  if (fullyQualifiedTypeName === '.google.protobuf.ListValue') {\n    if (!Array.isArray(json)) {\n      throw new Error(\"fromProto3JSONToInternalRepresentation: google.protobuf.ListValue must be an array but got \".concat(typeof json));\n    }\n\n    return value_1.googleProtobufListValueFromProto3JSON(json);\n  }\n\n  if (fullyQualifiedTypeName === '.google.protobuf.Duration') {\n    if (typeof json !== 'string') {\n      throw new Error(\"fromProto3JSONToInternalRepresentation: google.protobuf.Duration must be a string but got \".concat(typeof json));\n    }\n\n    return duration_1.googleProtobufDurationFromProto3JSON(json);\n  }\n\n  if (fullyQualifiedTypeName === '.google.protobuf.Timestamp') {\n    if (typeof json !== 'string') {\n      throw new Error(\"fromProto3JSONToInternalRepresentation: google.protobuf.Timestamp must be a string but got \".concat(typeof json));\n    }\n\n    return timestamp_1.googleProtobufTimestampFromProto3JSON(json);\n  }\n\n  if (fullyQualifiedTypeName === '.google.protobuf.FieldMask') {\n    if (typeof json !== 'string') {\n      throw new Error(\"fromProto3JSONToInternalRepresentation: google.protobuf.FieldMask must be a string but got \".concat(typeof json));\n    }\n\n    return fieldmask_1.googleProtobufFieldMaskFromProto3JSON(json);\n  }\n\n  var result = {};\n\n  var _loop = function _loop() {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n        key = _Object$entries$_i[0],\n        value = _Object$entries$_i[1];\n\n    var field = type.fields[key];\n\n    if (!field) {\n      return \"continue\";\n    }\n\n    var resolvedType = field.resolvedType;\n    var fieldType = field.type;\n\n    if (field.repeated) {\n      if (!Array.isArray(value)) {\n        throw new Error(\"fromProto3JSONToInternalRepresentation: expected an array for field \".concat(key));\n      }\n\n      result[key] = value.map(function (element) {\n        return fromProto3JSONToInternalRepresentation(resolvedType || fieldType, element);\n      });\n    } else if (field.map) {\n      var map = {};\n\n      for (var _i2 = 0, _Object$entries2 = Object.entries(value); _i2 < _Object$entries2.length; _i2++) {\n        var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),\n            mapKey = _Object$entries2$_i[0],\n            mapValue = _Object$entries2$_i[1];\n\n        map[mapKey] = fromProto3JSONToInternalRepresentation(resolvedType || fieldType, mapValue);\n      }\n\n      result[key] = map;\n    } else if (fieldType.match(/^(?:(?:(?:u?int|fixed)(?:32|64))|float|double)$/)) {\n      if (typeof value !== 'number' && typeof value !== 'string') {\n        throw new Error(\"fromProto3JSONToInternalRepresentation: field \".concat(key, \" of type \").concat(field.type, \" cannot contain value \").concat(value));\n      }\n\n      result[key] = value;\n    } else if (fieldType === 'string') {\n      if (typeof value !== 'string') {\n        throw new Error(\"fromProto3JSONToInternalRepresentation: field \".concat(key, \" of type \").concat(field.type, \" cannot contain value \").concat(value));\n      }\n\n      result[key] = value;\n    } else if (fieldType === 'bool') {\n      if (typeof value !== 'boolean') {\n        throw new Error(\"fromProto3JSONToInternalRepresentation: field \".concat(key, \" of type \").concat(field.type, \" cannot contain value \").concat(value));\n      }\n\n      result[key] = value;\n    } else if (fieldType === 'bytes') {\n      if (typeof value !== 'string') {\n        throw new Error(\"fromProto3JSONToInternalRepresentation: field \".concat(key, \" of type \").concat(field.type, \" cannot contain value \").concat(value));\n      }\n\n      result[key] = bytes_1.bytesFromProto3JSON(value);\n    } else {\n      // Message type\n      assert(resolvedType, \"Expected to be able to resolve type for field \".concat(field.name));\n      var deserializedValue = fromProto3JSONToInternalRepresentation(resolvedType, value);\n      result[key] = deserializedValue;\n    }\n  };\n\n  for (var _i = 0, _Object$entries = Object.entries(json); _i < _Object$entries.length; _i++) {\n    var _ret = _loop();\n\n    if (_ret === \"continue\") continue;\n  }\n\n  return result;\n}\n\nexports.fromProto3JSONToInternalRepresentation = fromProto3JSONToInternalRepresentation;\n\nfunction fromProto3JSON(type, json) {\n  var internalRepr = fromProto3JSONToInternalRepresentation(type, json);\n\n  if (internalRepr === null) {\n    return null;\n  } // We only expect a real object here sine all special cases should be already resolved. Everything else is an internal error\n\n\n  assert(typeof internalRepr === 'object' && !Array.isArray(internalRepr), \"fromProto3JSON: expected an object, not \".concat(json));\n  return type.fromObject(internalRepr);\n}\n\nexports.fromProto3JSON = fromProto3JSON;","map":null,"metadata":{},"sourceType":"script"}