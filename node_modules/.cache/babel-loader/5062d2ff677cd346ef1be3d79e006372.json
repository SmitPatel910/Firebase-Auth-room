{"ast":null,"code":"var _construct = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/construct\");\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _toConsumableArray = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar _require = require('util'),\n    inspect = _require.inspect;\n\nvar isObject = require('../help/is_object');\n\nvar _require2 = require('../jwk/generate'),\n    _generate = _require2.generate,\n    _generateSync = _require2.generateSync;\n\nvar _require3 = require('../help/consts'),\n    USES_MAPPING = _require3.USES_MAPPING;\n\nvar _require4 = require('../jwk'),\n    isKey = _require4.isKey,\n    importKey = _require4.asKey;\n\nvar keyscore = function keyscore(key, _ref) {\n  var alg = _ref.alg,\n      use = _ref.use,\n      ops = _ref.ops;\n  var score = 0;\n\n  if (alg && key.alg) {\n    score++;\n  }\n\n  if (use && key.use) {\n    score++;\n  }\n\n  if (ops && key.key_ops) {\n    score++;\n  }\n\n  return score;\n};\n\nvar KeyStore = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function KeyStore() {\n    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {\n      keys[_key] = arguments[_key];\n    }\n\n    _classCallCheck(this, KeyStore);\n\n    while (keys.some(Array.isArray)) {\n      keys = keys.flat ? keys.flat() : keys.reduce(function (acc, val) {\n        if (Array.isArray(val)) {\n          return [].concat(_toConsumableArray(acc), _toConsumableArray(val));\n        }\n\n        acc.push(val);\n        return acc;\n      }, []);\n    }\n\n    if (keys.some(function (k) {\n      return !isKey(k) || !k.kty;\n    })) {\n      throw new TypeError('all keys must be instances of a key instantiated by JWK.asKey');\n    }\n\n    this._keys = new Set(keys);\n  }\n\n  _createClass(KeyStore, [{\n    key: \"all\",\n    value: function all() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          alg = _ref2.alg,\n          kid = _ref2.kid,\n          thumbprint = _ref2.thumbprint,\n          use = _ref2.use,\n          kty = _ref2.kty,\n          ops = _ref2.key_ops,\n          x5t = _ref2.x5t,\n          x5t256 = _ref2['x5t#S256'],\n          crv = _ref2.crv;\n\n      if (ops !== undefined && (!Array.isArray(ops) || !ops.length || ops.some(function (x) {\n        return typeof x !== 'string';\n      }))) {\n        throw new TypeError('`key_ops` must be a non-empty array of strings');\n      }\n\n      var search = {\n        alg: alg,\n        use: use,\n        ops: ops\n      };\n      return _toConsumableArray(this._keys).filter(function (key) {\n        var candidate = true;\n\n        if (candidate && kid !== undefined && key.kid !== kid) {\n          candidate = false;\n        }\n\n        if (candidate && thumbprint !== undefined && key.thumbprint !== thumbprint) {\n          candidate = false;\n        }\n\n        if (candidate && x5t !== undefined && key.x5t !== x5t) {\n          candidate = false;\n        }\n\n        if (candidate && x5t256 !== undefined && key['x5t#S256'] !== x5t256) {\n          candidate = false;\n        }\n\n        if (candidate && kty !== undefined && key.kty !== kty) {\n          candidate = false;\n        }\n\n        if (candidate && crv !== undefined && key.crv !== crv) {\n          candidate = false;\n        }\n\n        if (alg !== undefined && !key.algorithms().has(alg)) {\n          candidate = false;\n        }\n\n        if (candidate && use !== undefined && key.use !== undefined && key.use !== use) {\n          candidate = false;\n        } // TODO:\n\n\n        if (candidate && ops !== undefined && (key.key_ops !== undefined || key.use !== undefined)) {\n          var keyOps;\n\n          if (key.key_ops) {\n            keyOps = new Set(key.key_ops);\n          } else {\n            keyOps = USES_MAPPING[key.use];\n          }\n\n          if (ops.some(function (x) {\n            return !keyOps.has(x);\n          })) {\n            candidate = false;\n          }\n        }\n\n        return candidate;\n      }).sort(function (first, second) {\n        return keyscore(second, search) - keyscore(first, search);\n      });\n    }\n  }, {\n    key: \"get\",\n    value: function get() {\n      return this.all.apply(this, arguments)[0];\n    }\n  }, {\n    key: \"add\",\n    value: function add(key) {\n      if (!isKey(key) || !key.kty) {\n        throw new TypeError('key must be an instance of a key instantiated by JWK.asKey');\n      }\n\n      this._keys.add(key);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(key) {\n      if (!isKey(key)) {\n        throw new TypeError('key must be an instance of a key instantiated by JWK.asKey');\n      }\n\n      this._keys.delete(key);\n    }\n  }, {\n    key: \"toJWKS\",\n    value: function toJWKS() {\n      var priv = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return {\n        keys: _toConsumableArray(this._keys.values()).map(function (key) {\n          return key.toJWK(priv && (key.private || key.secret && key.k));\n        })\n      };\n    }\n  }, {\n    key: \"generate\",\n    value: function () {\n      var _generate2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.t0 = this._keys;\n                _context.next = 3;\n                return _generate.apply(void 0, _args);\n\n              case 3:\n                _context.t1 = _context.sent;\n\n                _context.t0.add.call(_context.t0, _context.t1);\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function generate() {\n        return _generate2.apply(this, arguments);\n      }\n\n      return generate;\n    }()\n  }, {\n    key: \"generateSync\",\n    value: function generateSync() {\n      this._keys.add(_generateSync.apply(void 0, arguments));\n    }\n  }, {\n    key: inspect.custom,\n\n    /* c8 ignore next 8 */\n    value: function value() {\n      return \"\".concat(this.constructor.name, \" \").concat(inspect(this.toJWKS(false), {\n        depth: Infinity,\n        colors: process.stdout.isTTY,\n        compact: false,\n        sorted: true\n      }));\n    }\n  }, {\n    key: Symbol.iterator,\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function value() {\n      var _iterator, _step, key;\n\n      return _regeneratorRuntime.wrap(function value$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _iterator = _createForOfIteratorHelper(this._keys);\n              _context2.prev = 1;\n\n              _iterator.s();\n\n            case 3:\n              if ((_step = _iterator.n()).done) {\n                _context2.next = 9;\n                break;\n              }\n\n              key = _step.value;\n              _context2.next = 7;\n              return key;\n\n            case 7:\n              _context2.next = 3;\n              break;\n\n            case 9:\n              _context2.next = 14;\n              break;\n\n            case 11:\n              _context2.prev = 11;\n              _context2.t0 = _context2[\"catch\"](1);\n\n              _iterator.e(_context2.t0);\n\n            case 14:\n              _context2.prev = 14;\n\n              _iterator.f();\n\n              return _context2.finish(14);\n\n            case 17:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, value, this, [[1, 11, 14, 17]]);\n    })\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._keys.size;\n    }\n  }]);\n\n  return KeyStore;\n}();\n\nfunction asKeyStore(jwks) {\n  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref3$ignoreErrors = _ref3.ignoreErrors,\n      ignoreErrors = _ref3$ignoreErrors === void 0 ? false : _ref3$ignoreErrors,\n      _ref3$calculateMissin = _ref3.calculateMissingRSAPrimes,\n      calculateMissingRSAPrimes = _ref3$calculateMissin === void 0 ? false : _ref3$calculateMissin;\n\n  if (!isObject(jwks) || !Array.isArray(jwks.keys) || jwks.keys.some(function (k) {\n    return !isObject(k) || !('kty' in k);\n  })) {\n    throw new TypeError('jwks must be a JSON Web Key Set formatted object');\n  }\n\n  var keys = jwks.keys.map(function (jwk) {\n    try {\n      return importKey(jwk, {\n        calculateMissingRSAPrimes: calculateMissingRSAPrimes\n      });\n    } catch (err) {\n      if (!ignoreErrors) {\n        throw err;\n      }\n\n      return undefined;\n    }\n  }).filter(Boolean);\n  return _construct(KeyStore, _toConsumableArray(keys));\n}\n\nmodule.exports = {\n  KeyStore: KeyStore,\n  asKeyStore: asKeyStore\n};","map":null,"metadata":{},"sourceType":"script"}