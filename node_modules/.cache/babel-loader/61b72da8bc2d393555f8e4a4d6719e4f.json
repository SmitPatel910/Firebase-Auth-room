{"ast":null,"code":"\"use strict\";\n\nmodule.exports = ReflectionObject;\nReflectionObject.className = \"ReflectionObject\";\n\nvar util = require(\"./util\");\n\nvar Root; // cyclic\n\n/**\n * Constructs a new reflection object instance.\n * @classdesc Base class of all reflection objects.\n * @constructor\n * @param {string} name Object name\n * @param {Object.<string,*>} [options] Declared options\n * @abstract\n */\n\nfunction ReflectionObject(name, options) {\n  if (!util.isString(name)) throw TypeError(\"name must be a string\");\n  if (options && !util.isObject(options)) throw TypeError(\"options must be an object\");\n  /**\n   * Options.\n   * @type {Object.<string,*>|undefined}\n   */\n\n  this.options = options; // toJSON\n\n  /**\n   * Parsed Options.\n   * @type {Array.<Object.<string,*>>|undefined}\n   */\n\n  this.parsedOptions = null;\n  /**\n   * Unique name within its namespace.\n   * @type {string}\n   */\n\n  this.name = name;\n  /**\n   * Parent namespace.\n   * @type {Namespace|null}\n   */\n\n  this.parent = null;\n  /**\n   * Whether already resolved or not.\n   * @type {boolean}\n   */\n\n  this.resolved = false;\n  /**\n   * Comment text, if any.\n   * @type {string|null}\n   */\n\n  this.comment = null;\n  /**\n   * Defining file name.\n   * @type {string|null}\n   */\n\n  this.filename = null;\n}\n\nObject.defineProperties(ReflectionObject.prototype, {\n  /**\n   * Reference to the root namespace.\n   * @name ReflectionObject#root\n   * @type {Root}\n   * @readonly\n   */\n  root: {\n    get: function get() {\n      var ptr = this;\n\n      while (ptr.parent !== null) {\n        ptr = ptr.parent;\n      }\n\n      return ptr;\n    }\n  },\n\n  /**\n   * Full name including leading dot.\n   * @name ReflectionObject#fullName\n   * @type {string}\n   * @readonly\n   */\n  fullName: {\n    get: function get() {\n      var path = [this.name],\n          ptr = this.parent;\n\n      while (ptr) {\n        path.unshift(ptr.name);\n        ptr = ptr.parent;\n      }\n\n      return path.join(\".\");\n    }\n  }\n});\n/**\n * Converts this reflection object to its descriptor representation.\n * @returns {Object.<string,*>} Descriptor\n * @abstract\n */\n\nReflectionObject.prototype.toJSON =\n/* istanbul ignore next */\nfunction toJSON() {\n  throw Error(); // not implemented, shouldn't happen\n};\n/**\n * Called when this object is added to a parent.\n * @param {ReflectionObject} parent Parent added to\n * @returns {undefined}\n */\n\n\nReflectionObject.prototype.onAdd = function onAdd(parent) {\n  if (this.parent && this.parent !== parent) this.parent.remove(this);\n  this.parent = parent;\n  this.resolved = false;\n  var root = parent.root;\n  if (root instanceof Root) root._handleAdd(this);\n};\n/**\n * Called when this object is removed from a parent.\n * @param {ReflectionObject} parent Parent removed from\n * @returns {undefined}\n */\n\n\nReflectionObject.prototype.onRemove = function onRemove(parent) {\n  var root = parent.root;\n  if (root instanceof Root) root._handleRemove(this);\n  this.parent = null;\n  this.resolved = false;\n};\n/**\n * Resolves this objects type references.\n * @returns {ReflectionObject} `this`\n */\n\n\nReflectionObject.prototype.resolve = function resolve() {\n  if (this.resolved) return this;\n  if (this.root instanceof Root) this.resolved = true; // only if part of a root\n\n  return this;\n};\n/**\n * Gets an option value.\n * @param {string} name Option name\n * @returns {*} Option value or `undefined` if not set\n */\n\n\nReflectionObject.prototype.getOption = function getOption(name) {\n  if (this.options) return this.options[name];\n  return undefined;\n};\n/**\n * Sets an option.\n * @param {string} name Option name\n * @param {*} value Option value\n * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set\n * @returns {ReflectionObject} `this`\n */\n\n\nReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {\n  if (!ifNotSet || !this.options || this.options[name] === undefined) (this.options || (this.options = {}))[name] = value;\n  return this;\n};\n/**\n * Sets a parsed option.\n * @param {string} name parsed Option name\n * @param {*} value Option value\n * @param {string} propName dot '.' delimited full path of property within the option to set. if undefined\\empty, will add a new option with that value\n * @returns {ReflectionObject} `this`\n */\n\n\nReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {\n  if (!this.parsedOptions) {\n    this.parsedOptions = [];\n  }\n\n  var parsedOptions = this.parsedOptions;\n\n  if (propName) {\n    // If setting a sub property of an option then try to merge it\n    // with an existing option\n    var opt = parsedOptions.find(function (opt) {\n      return Object.prototype.hasOwnProperty.call(opt, name);\n    });\n\n    if (opt) {\n      // If we found an existing option - just merge the property value\n      var newValue = opt[name];\n      util.setProperty(newValue, propName, value);\n    } else {\n      // otherwise, create a new option, set it's property and add it to the list\n      opt = {};\n      opt[name] = util.setProperty({}, propName, value);\n      parsedOptions.push(opt);\n    }\n  } else {\n    // Always create a new option when setting the value of the option itself\n    var newOpt = {};\n    newOpt[name] = value;\n    parsedOptions.push(newOpt);\n  }\n\n  return this;\n};\n/**\n * Sets multiple options.\n * @param {Object.<string,*>} options Options to set\n * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set\n * @returns {ReflectionObject} `this`\n */\n\n\nReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {\n  if (options) for (var keys = Object.keys(options), i = 0; i < keys.length; ++i) {\n    this.setOption(keys[i], options[keys[i]], ifNotSet);\n  }\n  return this;\n};\n/**\n * Converts this instance to its string representation.\n * @returns {string} Class name[, space, full name]\n */\n\n\nReflectionObject.prototype.toString = function toString() {\n  var className = this.constructor.className,\n      fullName = this.fullName;\n  if (fullName.length) return className + \" \" + fullName;\n  return className;\n}; // Sets up cyclic dependencies (called in index-light)\n\n\nReflectionObject._configure = function (Root_) {\n  Root = Root_;\n};","map":null,"metadata":{},"sourceType":"script"}