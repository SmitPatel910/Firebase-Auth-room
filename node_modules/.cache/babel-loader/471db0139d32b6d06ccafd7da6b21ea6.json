{"ast":null,"code":"var _require = require('util'),\n    inherits = _require.inherits;\n\nvar _require2 = require('../base/reporter'),\n    Reporter = _require2.Reporter;\n\nfunction DecoderBuffer(base, options) {\n  Reporter.call(this, options);\n\n  if (!Buffer.isBuffer(base)) {\n    this.error('Input not Buffer');\n    return;\n  }\n\n  this.base = base;\n  this.offset = 0;\n  this.length = base.length;\n}\n\ninherits(DecoderBuffer, Reporter);\n\nDecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {\n  if (data instanceof DecoderBuffer) {\n    return true;\n  } // Or accept compatible API\n\n\n  var isCompatible = typeof data === 'object' && Buffer.isBuffer(data.base) && data.constructor.name === 'DecoderBuffer' && typeof data.offset === 'number' && typeof data.length === 'number' && typeof data.save === 'function' && typeof data.restore === 'function' && typeof data.isEmpty === 'function' && typeof data.readUInt8 === 'function' && typeof data.skip === 'function' && typeof data.raw === 'function';\n  return isCompatible;\n};\n\nDecoderBuffer.prototype.save = function save() {\n  return {\n    offset: this.offset,\n    reporter: Reporter.prototype.save.call(this)\n  };\n};\n\nDecoderBuffer.prototype.restore = function restore(save) {\n  // Return skipped data\n  var res = new DecoderBuffer(this.base);\n  res.offset = save.offset;\n  res.length = this.offset;\n  this.offset = save.offset;\n  Reporter.prototype.restore.call(this, save.reporter);\n  return res;\n};\n\nDecoderBuffer.prototype.isEmpty = function isEmpty() {\n  return this.offset === this.length;\n};\n\nDecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {\n  if (this.offset + 1 <= this.length) {\n    return this.base.readUInt8(this.offset++, true);\n  } else {\n    return this.error(fail || 'DecoderBuffer overrun');\n  }\n};\n\nDecoderBuffer.prototype.skip = function skip(bytes, fail) {\n  if (!(this.offset + bytes <= this.length)) {\n    return this.error(fail || 'DecoderBuffer overrun');\n  }\n\n  var res = new DecoderBuffer(this.base); // Share reporter state\n\n  res._reporterState = this._reporterState;\n  res.offset = this.offset;\n  res.length = this.offset + bytes;\n  this.offset += bytes;\n  return res;\n};\n\nDecoderBuffer.prototype.raw = function raw(save) {\n  return this.base.slice(save ? save.offset : this.offset, this.length);\n};\n\nfunction EncoderBuffer(value, reporter) {\n  if (Array.isArray(value)) {\n    this.length = 0;\n    this.value = value.map(function (item) {\n      if (!EncoderBuffer.isEncoderBuffer(item)) {\n        item = new EncoderBuffer(item, reporter);\n      }\n\n      this.length += item.length;\n      return item;\n    }, this);\n  } else if (typeof value === 'number') {\n    if (!(value >= 0 && value <= 0xff)) {\n      return reporter.error('non-byte EncoderBuffer value');\n    }\n\n    this.value = value;\n    this.length = 1;\n  } else if (typeof value === 'string') {\n    this.value = value;\n    this.length = Buffer.byteLength(value);\n  } else if (Buffer.isBuffer(value)) {\n    this.value = value;\n    this.length = value.length;\n  } else {\n    return reporter.error(\"Unsupported type: \".concat(typeof value));\n  }\n}\n\nEncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {\n  if (data instanceof EncoderBuffer) {\n    return true;\n  } // Or accept compatible API\n\n\n  var isCompatible = typeof data === 'object' && data.constructor.name === 'EncoderBuffer' && typeof data.length === 'number' && typeof data.join === 'function';\n  return isCompatible;\n};\n\nEncoderBuffer.prototype.join = function join(out, offset) {\n  if (!out) {\n    out = Buffer.alloc(this.length);\n  }\n\n  if (!offset) {\n    offset = 0;\n  }\n\n  if (this.length === 0) {\n    return out;\n  }\n\n  if (Array.isArray(this.value)) {\n    this.value.forEach(function (item) {\n      item.join(out, offset);\n      offset += item.length;\n    });\n  } else {\n    if (typeof this.value === 'number') {\n      out[offset] = this.value;\n    } else if (typeof this.value === 'string') {\n      out.write(this.value, offset);\n    } else if (Buffer.isBuffer(this.value)) {\n      this.value.copy(out, offset);\n    }\n\n    offset += this.length;\n  }\n\n  return out;\n};\n\nmodule.exports = {\n  DecoderBuffer: DecoderBuffer,\n  EncoderBuffer: EncoderBuffer\n};","map":null,"metadata":{},"sourceType":"script"}