{"ast":null,"code":"/*! firebase-admin v9.11.0 */\n\"use strict\";\n/*!\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UserImportBuilder = exports.convertMultiFactorInfoToServerFormat = void 0;\n\nvar deep_copy_1 = require(\"../utils/deep-copy\");\n\nvar utils = require(\"../utils\");\n\nvar validator = require(\"../utils/validator\");\n\nvar error_1 = require(\"../utils/error\");\n/**\n * Converts a client format second factor object to server format.\n * @param multiFactorInfo The client format second factor.\n * @return The corresponding AuthFactorInfo server request format.\n */\n\n\nfunction convertMultiFactorInfoToServerFormat(multiFactorInfo) {\n  var enrolledAt;\n\n  if (typeof multiFactorInfo.enrollmentTime !== 'undefined') {\n    if (validator.isUTCDateString(multiFactorInfo.enrollmentTime)) {\n      // Convert from UTC date string (client side format) to ISO date string (server side format).\n      enrolledAt = new Date(multiFactorInfo.enrollmentTime).toISOString();\n    } else {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLMENT_TIME, \"The second factor \\\"enrollmentTime\\\" for \\\"\" + multiFactorInfo.uid + \"\\\" must be a valid \" + 'UTC date string.');\n    }\n  } // Currently only phone second factors are supported.\n\n\n  if (isPhoneFactor(multiFactorInfo)) {\n    // If any required field is missing or invalid, validation will still fail later.\n    var authFactorInfo = {\n      mfaEnrollmentId: multiFactorInfo.uid,\n      displayName: multiFactorInfo.displayName,\n      // Required for all phone second factors.\n      phoneInfo: multiFactorInfo.phoneNumber,\n      enrolledAt: enrolledAt\n    };\n\n    for (var objKey in authFactorInfo) {\n      if (typeof authFactorInfo[objKey] === 'undefined') {\n        delete authFactorInfo[objKey];\n      }\n    }\n\n    return authFactorInfo;\n  } else {\n    // Unsupported second factor.\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.UNSUPPORTED_SECOND_FACTOR, \"Unsupported second factor \\\"\" + JSON.stringify(multiFactorInfo) + \"\\\" provided.\");\n  }\n}\n\nexports.convertMultiFactorInfoToServerFormat = convertMultiFactorInfoToServerFormat;\n\nfunction isPhoneFactor(multiFactorInfo) {\n  return multiFactorInfo.factorId === 'phone';\n}\n/**\n * @param {any} obj The object to check for number field within.\n * @param {string} key The entry key.\n * @return {number} The corresponding number if available. Otherwise, NaN.\n */\n\n\nfunction getNumberField(obj, key) {\n  if (typeof obj[key] !== 'undefined' && obj[key] !== null) {\n    return parseInt(obj[key].toString(), 10);\n  }\n\n  return NaN;\n}\n/**\n * Converts a UserImportRecord to a UploadAccountUser object. Throws an error when invalid\n * fields are provided.\n * @param {UserImportRecord} user The UserImportRecord to conver to UploadAccountUser.\n * @param {ValidatorFunction=} userValidator The user validator function.\n * @return {UploadAccountUser} The corresponding UploadAccountUser to return.\n */\n\n\nfunction populateUploadAccountUser(user, userValidator) {\n  var result = {\n    localId: user.uid,\n    email: user.email,\n    emailVerified: user.emailVerified,\n    displayName: user.displayName,\n    disabled: user.disabled,\n    photoUrl: user.photoURL,\n    phoneNumber: user.phoneNumber,\n    providerUserInfo: [],\n    mfaInfo: [],\n    tenantId: user.tenantId,\n    customAttributes: user.customClaims && JSON.stringify(user.customClaims)\n  };\n\n  if (typeof user.passwordHash !== 'undefined') {\n    if (!validator.isBuffer(user.passwordHash)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_HASH);\n    }\n\n    result.passwordHash = utils.toWebSafeBase64(user.passwordHash);\n  }\n\n  if (typeof user.passwordSalt !== 'undefined') {\n    if (!validator.isBuffer(user.passwordSalt)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_SALT);\n    }\n\n    result.salt = utils.toWebSafeBase64(user.passwordSalt);\n  }\n\n  if (validator.isNonNullObject(user.metadata)) {\n    if (validator.isNonEmptyString(user.metadata.creationTime)) {\n      result.createdAt = new Date(user.metadata.creationTime).getTime();\n    }\n\n    if (validator.isNonEmptyString(user.metadata.lastSignInTime)) {\n      result.lastLoginAt = new Date(user.metadata.lastSignInTime).getTime();\n    }\n  }\n\n  if (validator.isArray(user.providerData)) {\n    user.providerData.forEach(function (providerData) {\n      result.providerUserInfo.push({\n        providerId: providerData.providerId,\n        rawId: providerData.uid,\n        email: providerData.email,\n        displayName: providerData.displayName,\n        photoUrl: providerData.photoURL\n      });\n    });\n  } // Convert user.multiFactor.enrolledFactors to server format.\n\n\n  if (validator.isNonNullObject(user.multiFactor) && validator.isNonEmptyArray(user.multiFactor.enrolledFactors)) {\n    user.multiFactor.enrolledFactors.forEach(function (multiFactorInfo) {\n      result.mfaInfo.push(convertMultiFactorInfoToServerFormat(multiFactorInfo));\n    });\n  } // Remove blank fields.\n\n\n  var key;\n\n  for (key in result) {\n    if (typeof result[key] === 'undefined') {\n      delete result[key];\n    }\n  }\n\n  if (result.providerUserInfo.length === 0) {\n    delete result.providerUserInfo;\n  }\n\n  if (result.mfaInfo.length === 0) {\n    delete result.mfaInfo;\n  } // Validate the constructured user individual request. This will throw if an error\n  // is detected.\n\n\n  if (typeof userValidator === 'function') {\n    userValidator(result);\n  }\n\n  return result;\n}\n/**\n * Class that provides a helper for building/validating uploadAccount requests and\n * UserImportResult responses.\n */\n\n\nvar UserImportBuilder =\n/** @class */\nfunction () {\n  /**\n   * @param {UserImportRecord[]} users The list of user records to import.\n   * @param {UserImportOptions=} options The import options which includes hashing\n   *     algorithm details.\n   * @param {ValidatorFunction=} userRequestValidator The user request validator function.\n   * @constructor\n   */\n  function UserImportBuilder(users, options, userRequestValidator) {\n    this.requiresHashOptions = false;\n    this.validatedUsers = [];\n    this.userImportResultErrors = [];\n    this.indexMap = {};\n    this.validatedUsers = this.populateUsers(users, userRequestValidator);\n    this.validatedOptions = this.populateOptions(options, this.requiresHashOptions);\n  }\n  /**\n   * Returns the corresponding constructed uploadAccount request.\n   * @return {UploadAccountRequest} The constructed uploadAccount request.\n   */\n\n\n  UserImportBuilder.prototype.buildRequest = function () {\n    var users = this.validatedUsers.map(function (user) {\n      return deep_copy_1.deepCopy(user);\n    });\n    return deep_copy_1.deepExtend({\n      users: users\n    }, deep_copy_1.deepCopy(this.validatedOptions));\n  };\n  /**\n   * Populates the UserImportResult using the client side detected errors and the server\n   * side returned errors.\n   * @return {UserImportResult} The user import result based on the returned failed\n   *     uploadAccount response.\n   */\n\n\n  UserImportBuilder.prototype.buildResponse = function (failedUploads) {\n    var _this = this; // Initialize user import result.\n\n\n    var importResult = {\n      successCount: this.validatedUsers.length,\n      failureCount: this.userImportResultErrors.length,\n      errors: deep_copy_1.deepCopy(this.userImportResultErrors)\n    };\n    importResult.failureCount += failedUploads.length;\n    importResult.successCount -= failedUploads.length;\n    failedUploads.forEach(function (failedUpload) {\n      importResult.errors.push({\n        // Map backend request index to original developer provided array index.\n        index: _this.indexMap[failedUpload.index],\n        error: new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_USER_IMPORT, failedUpload.message)\n      });\n    }); // Sort errors by index.\n\n    importResult.errors.sort(function (a, b) {\n      return a.index - b.index;\n    }); // Return sorted result.\n\n    return importResult;\n  };\n  /**\n   * Validates and returns the hashing options of the uploadAccount request.\n   * Throws an error whenever an invalid or missing options is detected.\n   * @param {UserImportOptions} options The UserImportOptions.\n   * @param {boolean} requiresHashOptions Whether to require hash options.\n   * @return {UploadAccountOptions} The populated UploadAccount options.\n   */\n\n\n  UserImportBuilder.prototype.populateOptions = function (options, requiresHashOptions) {\n    var populatedOptions;\n\n    if (!requiresHashOptions) {\n      return {};\n    }\n\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"UserImportOptions\" are required when importing users with passwords.');\n    }\n\n    if (!validator.isNonNullObject(options.hash)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_HASH_ALGORITHM, '\"hash.algorithm\" is missing from the provided \"UserImportOptions\".');\n    }\n\n    if (typeof options.hash.algorithm === 'undefined' || !validator.isNonEmptyString(options.hash.algorithm)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ALGORITHM, '\"hash.algorithm\" must be a string matching the list of supported algorithms.');\n    }\n\n    var rounds;\n\n    switch (options.hash.algorithm) {\n      case 'HMAC_SHA512':\n      case 'HMAC_SHA256':\n      case 'HMAC_SHA1':\n      case 'HMAC_MD5':\n        if (!validator.isBuffer(options.hash.key)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_KEY, 'A non-empty \"hash.key\" byte buffer must be provided for ' + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n        }\n\n        populatedOptions = {\n          hashAlgorithm: options.hash.algorithm,\n          signerKey: utils.toWebSafeBase64(options.hash.key)\n        };\n        break;\n\n      case 'MD5':\n      case 'SHA1':\n      case 'SHA256':\n      case 'SHA512':\n        {\n          // MD5 is [0,8192] but SHA1, SHA256, and SHA512 are [1,8192]\n          rounds = getNumberField(options.hash, 'rounds');\n          var minRounds = options.hash.algorithm === 'MD5' ? 0 : 1;\n\n          if (isNaN(rounds) || rounds < minRounds || rounds > 8192) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, \"A valid \\\"hash.rounds\\\" number between \" + minRounds + \" and 8192 must be provided for \" + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n          }\n\n          populatedOptions = {\n            hashAlgorithm: options.hash.algorithm,\n            rounds: rounds\n          };\n          break;\n        }\n\n      case 'PBKDF_SHA1':\n      case 'PBKDF2_SHA256':\n        rounds = getNumberField(options.hash, 'rounds');\n\n        if (isNaN(rounds) || rounds < 0 || rounds > 120000) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, 'A valid \"hash.rounds\" number between 0 and 120000 must be provided for ' + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n        }\n\n        populatedOptions = {\n          hashAlgorithm: options.hash.algorithm,\n          rounds: rounds\n        };\n        break;\n\n      case 'SCRYPT':\n        {\n          if (!validator.isBuffer(options.hash.key)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_KEY, 'A \"hash.key\" byte buffer must be provided for ' + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n          }\n\n          rounds = getNumberField(options.hash, 'rounds');\n\n          if (isNaN(rounds) || rounds <= 0 || rounds > 8) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, 'A valid \"hash.rounds\" number between 1 and 8 must be provided for ' + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n          }\n\n          var memoryCost = getNumberField(options.hash, 'memoryCost');\n\n          if (isNaN(memoryCost) || memoryCost <= 0 || memoryCost > 14) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_MEMORY_COST, 'A valid \"hash.memoryCost\" number between 1 and 14 must be provided for ' + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n          }\n\n          if (typeof options.hash.saltSeparator !== 'undefined' && !validator.isBuffer(options.hash.saltSeparator)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_SALT_SEPARATOR, '\"hash.saltSeparator\" must be a byte buffer.');\n          }\n\n          populatedOptions = {\n            hashAlgorithm: options.hash.algorithm,\n            signerKey: utils.toWebSafeBase64(options.hash.key),\n            rounds: rounds,\n            memoryCost: memoryCost,\n            saltSeparator: utils.toWebSafeBase64(options.hash.saltSeparator || Buffer.from(''))\n          };\n          break;\n        }\n\n      case 'BCRYPT':\n        populatedOptions = {\n          hashAlgorithm: options.hash.algorithm\n        };\n        break;\n\n      case 'STANDARD_SCRYPT':\n        {\n          var cpuMemCost = getNumberField(options.hash, 'memoryCost');\n\n          if (isNaN(cpuMemCost)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_MEMORY_COST, 'A valid \"hash.memoryCost\" number must be provided for ' + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n          }\n\n          var parallelization = getNumberField(options.hash, 'parallelization');\n\n          if (isNaN(parallelization)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_PARALLELIZATION, 'A valid \"hash.parallelization\" number must be provided for ' + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n          }\n\n          var blockSize = getNumberField(options.hash, 'blockSize');\n\n          if (isNaN(blockSize)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_BLOCK_SIZE, 'A valid \"hash.blockSize\" number must be provided for ' + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n          }\n\n          var dkLen = getNumberField(options.hash, 'derivedKeyLength');\n\n          if (isNaN(dkLen)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_DERIVED_KEY_LENGTH, 'A valid \"hash.derivedKeyLength\" number must be provided for ' + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n          }\n\n          populatedOptions = {\n            hashAlgorithm: options.hash.algorithm,\n            cpuMemCost: cpuMemCost,\n            parallelization: parallelization,\n            blockSize: blockSize,\n            dkLen: dkLen\n          };\n          break;\n        }\n\n      default:\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ALGORITHM, \"Unsupported hash algorithm provider \\\"\" + options.hash.algorithm + \"\\\".\");\n    }\n\n    return populatedOptions;\n  };\n  /**\n   * Validates and returns the users list of the uploadAccount request.\n   * Whenever a user with an error is detected, the error is cached and will later be\n   * merged into the user import result. This allows the processing of valid users without\n   * failing early on the first error detected.\n   * @param {UserImportRecord[]} users The UserImportRecords to convert to UnploadAccountUser\n   *     objects.\n   * @param {ValidatorFunction=} userValidator The user validator function.\n   * @return {UploadAccountUser[]} The populated uploadAccount users.\n   */\n\n\n  UserImportBuilder.prototype.populateUsers = function (users, userValidator) {\n    var _this = this;\n\n    var populatedUsers = [];\n    users.forEach(function (user, index) {\n      try {\n        var result = populateUploadAccountUser(user, userValidator);\n\n        if (typeof result.passwordHash !== 'undefined') {\n          _this.requiresHashOptions = true;\n        } // Only users that pass client screening will be passed to backend for processing.\n\n\n        populatedUsers.push(result); // Map user's index (the one to be sent to backend) to original developer provided array.\n\n        _this.indexMap[populatedUsers.length - 1] = index;\n      } catch (error) {\n        // Save the client side error with respect to the developer provided array.\n        _this.userImportResultErrors.push({\n          index: index,\n          error: error\n        });\n      }\n    });\n    return populatedUsers;\n  };\n\n  return UserImportBuilder;\n}();\n\nexports.UserImportBuilder = UserImportBuilder;","map":null,"metadata":{},"sourceType":"script"}