{"ast":null,"code":"\"use strict\";\n/* eslint-disable prefer-rest-params */\n\nvar _toConsumableArray = require(\"C:\\\\Users\\\\Smit\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.callbackifyAll = exports.callbackify = exports.promisifyAll = exports.promisify = void 0;\n/**\n * Wraps a callback style function to conditionally return a promise.\n *\n * @param {function} originalMethod - The method to promisify.\n * @param {object=} options - Promise options.\n * @param {boolean} options.singular - Resolve the promise with single arg instead of an array.\n * @return {function} wrapped\n */\n\nfunction promisify(originalMethod, options) {\n  if (originalMethod.promisified_) {\n    return originalMethod;\n  }\n\n  options = options || {};\n  var slice = Array.prototype.slice; // tslint:disable-next-line:no-any\n\n  var wrapper = function wrapper() {\n    var _this = this;\n\n    var last;\n\n    for (last = arguments.length - 1; last >= 0; last--) {\n      var arg = arguments[last];\n\n      if (typeof arg === 'undefined') {\n        continue; // skip trailing undefined.\n      }\n\n      if (typeof arg !== 'function') {\n        break; // non-callback last argument found.\n      }\n\n      return originalMethod.apply(this, arguments);\n    } // peel trailing undefined.\n\n\n    var args = slice.call(arguments, 0, last + 1); // tslint:disable-next-line:variable-name\n\n    var PromiseCtor = Promise; // Because dedupe will likely create a single install of\n    // @google-cloud/common to be shared amongst all modules, we need to\n    // localize it at the Service level.\n\n    if (this && this.Promise) {\n      PromiseCtor = this.Promise;\n    }\n\n    return new PromiseCtor(function (resolve, reject) {\n      // tslint:disable-next-line:no-any\n      args.push(function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        var callbackArgs = slice.call(args);\n        var err = callbackArgs.shift();\n\n        if (err) {\n          return reject(err);\n        }\n\n        if (options.singular && callbackArgs.length === 1) {\n          resolve(callbackArgs[0]);\n        } else {\n          resolve(callbackArgs);\n        }\n      });\n      originalMethod.apply(_this, args);\n    });\n  };\n\n  wrapper.promisified_ = true;\n  return wrapper;\n}\n\nexports.promisify = promisify;\n/**\n * Promisifies certain Class methods. This will not promisify private or\n * streaming methods.\n *\n * @param {module:common/service} Class - Service class.\n * @param {object=} options - Configuration object.\n */\n// tslint:disable-next-line:variable-name\n\nfunction promisifyAll(Class, options) {\n  var exclude = options && options.exclude || [];\n  var ownPropertyNames = Object.getOwnPropertyNames(Class.prototype);\n  var methods = ownPropertyNames.filter(function (methodName) {\n    // clang-format off\n    return !exclude.includes(methodName) && typeof Class.prototype[methodName] === 'function' && // is it a function?\n    !/(^_|(Stream|_)|promise$)|^constructor$/.test(methodName) // is it promisable?\n    ; // clang-format on\n  });\n  methods.forEach(function (methodName) {\n    var originalMethod = Class.prototype[methodName];\n\n    if (!originalMethod.promisified_) {\n      Class.prototype[methodName] = exports.promisify(originalMethod, options);\n    }\n  });\n}\n\nexports.promisifyAll = promisifyAll;\n/**\n * Wraps a promisy type function to conditionally call a callback function.\n *\n * @param {function} originalMethod - The method to callbackify.\n * @param {object=} options - Callback options.\n * @param {boolean} options.singular - Pass to the callback a single arg instead of an array.\n * @return {function} wrapped\n */\n\nfunction callbackify(originalMethod) {\n  if (originalMethod.callbackified_) {\n    return originalMethod;\n  } // tslint:disable-next-line:no-any\n\n\n  var wrapper = function wrapper() {\n    if (typeof arguments[arguments.length - 1] !== 'function') {\n      return originalMethod.apply(this, arguments);\n    }\n\n    var cb = Array.prototype.pop.call(arguments);\n    originalMethod.apply(this, arguments).then( // tslint:disable-next-line:no-any\n    function (res) {\n      res = Array.isArray(res) ? res : [res];\n      cb.apply(void 0, [null].concat(_toConsumableArray(res)));\n    }, function (err) {\n      return cb(err);\n    });\n  };\n\n  wrapper.callbackified_ = true;\n  return wrapper;\n}\n\nexports.callbackify = callbackify;\n/**\n * Callbackifies certain Class methods. This will not callbackify private or\n * streaming methods.\n *\n * @param {module:common/service} Class - Service class.\n * @param {object=} options - Configuration object.\n */\n\nfunction callbackifyAll( // tslint:disable-next-line:variable-name\nClass, options) {\n  var exclude = options && options.exclude || [];\n  var ownPropertyNames = Object.getOwnPropertyNames(Class.prototype);\n  var methods = ownPropertyNames.filter(function (methodName) {\n    // clang-format off\n    return !exclude.includes(methodName) && typeof Class.prototype[methodName] === 'function' && // is it a function?\n    !/^_|(Stream|_)|^constructor$/.test(methodName) // is it callbackifyable?\n    ; // clang-format on\n  });\n  methods.forEach(function (methodName) {\n    var originalMethod = Class.prototype[methodName];\n\n    if (!originalMethod.callbackified_) {\n      Class.prototype[methodName] = exports.callbackify(originalMethod);\n    }\n  });\n}\n\nexports.callbackifyAll = callbackifyAll;","map":null,"metadata":{},"sourceType":"script"}