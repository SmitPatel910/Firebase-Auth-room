{"ast":null,"code":"/*! firebase-admin v9.11.0 */\n\"use strict\";\n/*!\n * Copyright 2020 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FirebaseRemoteConfigError = exports.RemoteConfigApiClient = void 0;\n\nvar api_request_1 = require(\"../utils/api-request\");\n\nvar error_1 = require(\"../utils/error\");\n\nvar utils = require(\"../utils/index\");\n\nvar validator = require(\"../utils/validator\");\n\nvar deep_copy_1 = require(\"../utils/deep-copy\"); // Remote Config backend constants\n\n\nvar FIREBASE_REMOTE_CONFIG_V1_API = 'https://firebaseremoteconfig.googleapis.com/v1';\nvar FIREBASE_REMOTE_CONFIG_HEADERS = {\n  'X-Firebase-Client': \"fire-admin-node/\" + utils.getSdkVersion(),\n  // There is a known issue in which the ETag is not properly returned in cases where the request\n  // does not specify a compression type. Currently, it is required to include the header\n  // `Accept-Encoding: gzip` or equivalent in all requests.\n  // https://firebase.google.com/docs/remote-config/use-config-rest#etag_usage_and_forced_updates\n  'Accept-Encoding': 'gzip'\n};\n/**\n * Class that facilitates sending requests to the Firebase Remote Config backend API.\n *\n * @private\n */\n\nvar RemoteConfigApiClient =\n/** @class */\nfunction () {\n  function RemoteConfigApiClient(app) {\n    this.app = app;\n\n    if (!validator.isNonNullObject(app) || !('options' in app)) {\n      throw new FirebaseRemoteConfigError('invalid-argument', 'First argument passed to admin.remoteConfig() must be a valid Firebase app instance.');\n    }\n\n    this.httpClient = new api_request_1.AuthorizedHttpClient(app);\n  }\n\n  RemoteConfigApiClient.prototype.getTemplate = function () {\n    var _this = this;\n\n    return this.getUrl().then(function (url) {\n      var request = {\n        method: 'GET',\n        url: url + \"/remoteConfig\",\n        headers: FIREBASE_REMOTE_CONFIG_HEADERS\n      };\n      return _this.httpClient.send(request);\n    }).then(function (resp) {\n      return _this.toRemoteConfigTemplate(resp);\n    }).catch(function (err) {\n      throw _this.toFirebaseError(err);\n    });\n  };\n\n  RemoteConfigApiClient.prototype.getTemplateAtVersion = function (versionNumber) {\n    var _this = this;\n\n    var data = {\n      versionNumber: this.validateVersionNumber(versionNumber)\n    };\n    return this.getUrl().then(function (url) {\n      var request = {\n        method: 'GET',\n        url: url + \"/remoteConfig\",\n        headers: FIREBASE_REMOTE_CONFIG_HEADERS,\n        data: data\n      };\n      return _this.httpClient.send(request);\n    }).then(function (resp) {\n      return _this.toRemoteConfigTemplate(resp);\n    }).catch(function (err) {\n      throw _this.toFirebaseError(err);\n    });\n  };\n\n  RemoteConfigApiClient.prototype.validateTemplate = function (template) {\n    var _this = this;\n\n    template = this.validateInputRemoteConfigTemplate(template);\n    return this.sendPutRequest(template, template.etag, true).then(function (resp) {\n      // validating a template returns an etag with the suffix -0 means that your update\n      // was successfully validated. We set the etag back to the original etag of the template\n      // to allow future operations.\n      _this.validateEtag(resp.headers['etag']);\n\n      return _this.toRemoteConfigTemplate(resp, template.etag);\n    }).catch(function (err) {\n      throw _this.toFirebaseError(err);\n    });\n  };\n\n  RemoteConfigApiClient.prototype.publishTemplate = function (template, options) {\n    var _this = this;\n\n    template = this.validateInputRemoteConfigTemplate(template);\n    var ifMatch = template.etag;\n\n    if (options && options.force == true) {\n      // setting `If-Match: *` forces the Remote Config template to be updated\n      // and circumvent the ETag, and the protection from that it provides.\n      ifMatch = '*';\n    }\n\n    return this.sendPutRequest(template, ifMatch).then(function (resp) {\n      return _this.toRemoteConfigTemplate(resp);\n    }).catch(function (err) {\n      throw _this.toFirebaseError(err);\n    });\n  };\n\n  RemoteConfigApiClient.prototype.rollback = function (versionNumber) {\n    var _this = this;\n\n    var data = {\n      versionNumber: this.validateVersionNumber(versionNumber)\n    };\n    return this.getUrl().then(function (url) {\n      var request = {\n        method: 'POST',\n        url: url + \"/remoteConfig:rollback\",\n        headers: FIREBASE_REMOTE_CONFIG_HEADERS,\n        data: data\n      };\n      return _this.httpClient.send(request);\n    }).then(function (resp) {\n      return _this.toRemoteConfigTemplate(resp);\n    }).catch(function (err) {\n      throw _this.toFirebaseError(err);\n    });\n  };\n\n  RemoteConfigApiClient.prototype.listVersions = function (options) {\n    var _this = this;\n\n    if (typeof options !== 'undefined') {\n      options = this.validateListVersionsOptions(options);\n    }\n\n    return this.getUrl().then(function (url) {\n      var request = {\n        method: 'GET',\n        url: url + \"/remoteConfig:listVersions\",\n        headers: FIREBASE_REMOTE_CONFIG_HEADERS,\n        data: options\n      };\n      return _this.httpClient.send(request);\n    }).then(function (resp) {\n      return resp.data;\n    }).catch(function (err) {\n      throw _this.toFirebaseError(err);\n    });\n  };\n\n  RemoteConfigApiClient.prototype.sendPutRequest = function (template, etag, validateOnly) {\n    var _this = this;\n\n    var path = 'remoteConfig';\n\n    if (validateOnly) {\n      path += '?validate_only=true';\n    }\n\n    return this.getUrl().then(function (url) {\n      var request = {\n        method: 'PUT',\n        url: url + \"/\" + path,\n        headers: __assign(__assign({}, FIREBASE_REMOTE_CONFIG_HEADERS), {\n          'If-Match': etag\n        }),\n        data: {\n          conditions: template.conditions,\n          parameters: template.parameters,\n          parameterGroups: template.parameterGroups,\n          version: template.version\n        }\n      };\n      return _this.httpClient.send(request);\n    });\n  };\n\n  RemoteConfigApiClient.prototype.getUrl = function () {\n    return this.getProjectIdPrefix().then(function (projectIdPrefix) {\n      return FIREBASE_REMOTE_CONFIG_V1_API + \"/\" + projectIdPrefix;\n    });\n  };\n\n  RemoteConfigApiClient.prototype.getProjectIdPrefix = function () {\n    var _this = this;\n\n    if (this.projectIdPrefix) {\n      return Promise.resolve(this.projectIdPrefix);\n    }\n\n    return utils.findProjectId(this.app).then(function (projectId) {\n      if (!validator.isNonEmptyString(projectId)) {\n        throw new FirebaseRemoteConfigError('unknown-error', 'Failed to determine project ID. Initialize the SDK with service account credentials, or ' + 'set project ID as an app option. Alternatively, set the GOOGLE_CLOUD_PROJECT ' + 'environment variable.');\n      }\n\n      _this.projectIdPrefix = \"projects/\" + projectId;\n      return _this.projectIdPrefix;\n    });\n  };\n\n  RemoteConfigApiClient.prototype.toFirebaseError = function (err) {\n    if (err instanceof error_1.PrefixedFirebaseError) {\n      return err;\n    }\n\n    var response = err.response;\n\n    if (!response.isJson()) {\n      return new FirebaseRemoteConfigError('unknown-error', \"Unexpected response with status: \" + response.status + \" and body: \" + response.text);\n    }\n\n    var error = response.data.error || {};\n    var code = 'unknown-error';\n\n    if (error.status && error.status in ERROR_CODE_MAPPING) {\n      code = ERROR_CODE_MAPPING[error.status];\n    }\n\n    var message = error.message || \"Unknown server error: \" + response.text;\n    return new FirebaseRemoteConfigError(code, message);\n  };\n  /**\n   * Creates a RemoteConfigTemplate from the API response.\n   * If provided, customEtag is used instead of the etag returned in the API response.\n   *\n   * @param {HttpResponse} resp API response object.\n   * @param {string} customEtag A custom etag to replace the etag fom the API response (Optional).\n   */\n\n\n  RemoteConfigApiClient.prototype.toRemoteConfigTemplate = function (resp, customEtag) {\n    var etag = typeof customEtag == 'undefined' ? resp.headers['etag'] : customEtag;\n    this.validateEtag(etag);\n    return {\n      conditions: resp.data.conditions,\n      parameters: resp.data.parameters,\n      parameterGroups: resp.data.parameterGroups,\n      etag: etag,\n      version: resp.data.version\n    };\n  };\n  /**\n   * Checks if the given RemoteConfigTemplate object is valid.\n   * The object must have valid parameters, parameter groups, conditions, and an etag.\n   * Removes output only properties from version metadata.\n   *\n   * @param {RemoteConfigTemplate} template A RemoteConfigTemplate object to be validated.\n   *\n   * @returns {RemoteConfigTemplate} The validated RemoteConfigTemplate object.\n   */\n\n\n  RemoteConfigApiClient.prototype.validateInputRemoteConfigTemplate = function (template) {\n    var templateCopy = deep_copy_1.deepCopy(template);\n\n    if (!validator.isNonNullObject(templateCopy)) {\n      throw new FirebaseRemoteConfigError('invalid-argument', \"Invalid Remote Config template: \" + JSON.stringify(templateCopy));\n    }\n\n    if (!validator.isNonEmptyString(templateCopy.etag)) {\n      throw new FirebaseRemoteConfigError('invalid-argument', 'ETag must be a non-empty string.');\n    }\n\n    if (!validator.isNonNullObject(templateCopy.parameters)) {\n      throw new FirebaseRemoteConfigError('invalid-argument', 'Remote Config parameters must be a non-null object');\n    }\n\n    if (!validator.isNonNullObject(templateCopy.parameterGroups)) {\n      throw new FirebaseRemoteConfigError('invalid-argument', 'Remote Config parameter groups must be a non-null object');\n    }\n\n    if (!validator.isArray(templateCopy.conditions)) {\n      throw new FirebaseRemoteConfigError('invalid-argument', 'Remote Config conditions must be an array');\n    }\n\n    if (typeof templateCopy.version !== 'undefined') {\n      // exclude output only properties and keep the only input property: description\n      templateCopy.version = {\n        description: templateCopy.version.description\n      };\n    }\n\n    return templateCopy;\n  };\n  /**\n   * Checks if a given version number is valid.\n   * A version number must be an integer or a string in int64 format.\n   * If valid, returns the string representation of the provided version number.\n   *\n   * @param {string|number} versionNumber A version number to be validated.\n   *\n   * @returns {string} The validated version number as a string.\n   */\n\n\n  RemoteConfigApiClient.prototype.validateVersionNumber = function (versionNumber, propertyName) {\n    if (propertyName === void 0) {\n      propertyName = 'versionNumber';\n    }\n\n    if (!validator.isNonEmptyString(versionNumber) && !validator.isNumber(versionNumber)) {\n      throw new FirebaseRemoteConfigError('invalid-argument', propertyName + \" must be a non-empty string in int64 format or a number\");\n    }\n\n    if (!Number.isInteger(Number(versionNumber))) {\n      throw new FirebaseRemoteConfigError('invalid-argument', propertyName + \" must be an integer or a string in int64 format\");\n    }\n\n    return versionNumber.toString();\n  };\n\n  RemoteConfigApiClient.prototype.validateEtag = function (etag) {\n    if (!validator.isNonEmptyString(etag)) {\n      throw new FirebaseRemoteConfigError('invalid-argument', 'ETag header is not present in the server response.');\n    }\n  };\n  /**\n   * Checks if a given `ListVersionsOptions` object is valid. If successful, creates a copy of the\n   * options object and convert `startTime` and `endTime` to RFC3339 UTC \"Zulu\" format, if present.\n   *\n   * @param {ListVersionsOptions} options An options object to be validated.\n   *\n   * @return {ListVersionsOptions} A copy of the provided options object with timestamps converted\n   * to UTC Zulu format.\n   */\n\n\n  RemoteConfigApiClient.prototype.validateListVersionsOptions = function (options) {\n    var optionsCopy = deep_copy_1.deepCopy(options);\n\n    if (!validator.isNonNullObject(optionsCopy)) {\n      throw new FirebaseRemoteConfigError('invalid-argument', 'ListVersionsOptions must be a non-null object.');\n    }\n\n    if (typeof optionsCopy.pageSize !== 'undefined') {\n      if (!validator.isNumber(optionsCopy.pageSize)) {\n        throw new FirebaseRemoteConfigError('invalid-argument', 'pageSize must be a number.');\n      }\n\n      if (optionsCopy.pageSize < 1 || optionsCopy.pageSize > 300) {\n        throw new FirebaseRemoteConfigError('invalid-argument', 'pageSize must be a number between 1 and 300 (inclusive).');\n      }\n    }\n\n    if (typeof optionsCopy.pageToken !== 'undefined' && !validator.isNonEmptyString(optionsCopy.pageToken)) {\n      throw new FirebaseRemoteConfigError('invalid-argument', 'pageToken must be a string value.');\n    }\n\n    if (typeof optionsCopy.endVersionNumber !== 'undefined') {\n      optionsCopy.endVersionNumber = this.validateVersionNumber(optionsCopy.endVersionNumber, 'endVersionNumber');\n    }\n\n    if (typeof optionsCopy.startTime !== 'undefined') {\n      if (!(optionsCopy.startTime instanceof Date) && !validator.isUTCDateString(optionsCopy.startTime)) {\n        throw new FirebaseRemoteConfigError('invalid-argument', 'startTime must be a valid Date object or a UTC date string.');\n      } // Convert startTime to RFC3339 UTC \"Zulu\" format.\n\n\n      if (optionsCopy.startTime instanceof Date) {\n        optionsCopy.startTime = optionsCopy.startTime.toISOString();\n      } else {\n        optionsCopy.startTime = new Date(optionsCopy.startTime).toISOString();\n      }\n    }\n\n    if (typeof optionsCopy.endTime !== 'undefined') {\n      if (!(optionsCopy.endTime instanceof Date) && !validator.isUTCDateString(optionsCopy.endTime)) {\n        throw new FirebaseRemoteConfigError('invalid-argument', 'endTime must be a valid Date object or a UTC date string.');\n      } // Convert endTime to RFC3339 UTC \"Zulu\" format.\n\n\n      if (optionsCopy.endTime instanceof Date) {\n        optionsCopy.endTime = optionsCopy.endTime.toISOString();\n      } else {\n        optionsCopy.endTime = new Date(optionsCopy.endTime).toISOString();\n      }\n    } // Remove undefined fields from optionsCopy\n\n\n    Object.keys(optionsCopy).forEach(function (key) {\n      return typeof optionsCopy[key] === 'undefined' && delete optionsCopy[key];\n    });\n    return optionsCopy;\n  };\n\n  return RemoteConfigApiClient;\n}();\n\nexports.RemoteConfigApiClient = RemoteConfigApiClient;\nvar ERROR_CODE_MAPPING = {\n  ABORTED: 'aborted',\n  ALREADY_EXISTS: 'already-exists',\n  INVALID_ARGUMENT: 'invalid-argument',\n  INTERNAL: 'internal-error',\n  FAILED_PRECONDITION: 'failed-precondition',\n  NOT_FOUND: 'not-found',\n  OUT_OF_RANGE: 'out-of-range',\n  PERMISSION_DENIED: 'permission-denied',\n  RESOURCE_EXHAUSTED: 'resource-exhausted',\n  UNAUTHENTICATED: 'unauthenticated',\n  UNKNOWN: 'unknown-error'\n};\n/**\n * Firebase Remote Config error code structure. This extends PrefixedFirebaseError.\n *\n * @param {RemoteConfigErrorCode} code The error code.\n * @param {string} message The error message.\n * @constructor\n */\n\nvar FirebaseRemoteConfigError =\n/** @class */\nfunction (_super) {\n  __extends(FirebaseRemoteConfigError, _super);\n\n  function FirebaseRemoteConfigError(code, message) {\n    return _super.call(this, 'remote-config', code, message) || this;\n  }\n\n  return FirebaseRemoteConfigError;\n}(error_1.PrefixedFirebaseError);\n\nexports.FirebaseRemoteConfigError = FirebaseRemoteConfigError;","map":null,"metadata":{},"sourceType":"script"}