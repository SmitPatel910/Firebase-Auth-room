{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spread = this && this.__spread || function () {\n  for (var ar = [], i = 0; i < arguments.length; i++) {\n    ar = ar.concat(__read(arguments[i]));\n  }\n\n  return ar;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar lru_cache_1 = __importDefault(require(\"lru-cache\"));\n\nvar events_1 = require(\"events\");\n\nvar lodash_clonedeep_1 = __importDefault(require(\"lodash.clonedeep\"));\n\nvar freeze_1 = require(\"./freeze\");\n\nfunction syncMemoizer(options) {\n  var cache = new lru_cache_1.default(options);\n  var load = options.load;\n  var hash = options.hash;\n  var bypass = options.bypass;\n  var itemMaxAge = options.itemMaxAge;\n  var freeze = options.freeze;\n  var clone = options.clone;\n  var emitter = new events_1.EventEmitter();\n  var defaultResult = Object.assign({\n    del: del,\n    reset: function reset() {\n      return cache.reset();\n    },\n    keys: cache.keys.bind(cache),\n    on: emitter.on.bind(emitter),\n    once: emitter.once.bind(emitter)\n  }, options);\n\n  if (options.disable) {\n    return Object.assign(load, defaultResult);\n  }\n\n  function del() {\n    var key = hash.apply(void 0, __spread(arguments));\n    cache.del(key);\n  }\n\n  function emit(event) {\n    var parameters = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      parameters[_i - 1] = arguments[_i];\n    }\n\n    emitter.emit.apply(emitter, __spread([event], parameters));\n  }\n\n  function isPromise(result) {\n    // detect native, bluebird, A+ promises\n    return result && result.then && typeof result.then === 'function';\n  }\n\n  function processResult(result) {\n    var res = result;\n\n    if (clone) {\n      if (isPromise(res)) {\n        res = res.then(lodash_clonedeep_1.default);\n      } else {\n        res = lodash_clonedeep_1.default(res);\n      }\n    }\n\n    if (freeze) {\n      if (isPromise(res)) {\n        res = res.then(freeze_1.deepFreeze);\n      } else {\n        freeze_1.deepFreeze(res);\n      }\n    }\n\n    return res;\n  }\n\n  var result = function result() {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    if (bypass && bypass.apply(void 0, __spread(args))) {\n      emit.apply(void 0, __spread(['miss'], args));\n      return load.apply(void 0, __spread(args));\n    }\n\n    var key = hash.apply(void 0, __spread(args));\n    var fromCache = cache.get(key);\n\n    if (fromCache) {\n      emit.apply(void 0, __spread(['hit'], args));\n      return processResult(fromCache);\n    }\n\n    emit.apply(void 0, __spread(['miss'], args));\n    var result = load.apply(void 0, __spread(args));\n\n    if (itemMaxAge) {\n      // @ts-ignore\n      cache.set(key, result, itemMaxAge.apply(void 0, __spread(args.concat([result]))));\n    } else {\n      cache.set(key, result);\n    }\n\n    return processResult(result);\n  };\n\n  return Object.assign(result, defaultResult);\n}\n\nexports.syncMemoizer = syncMemoizer;","map":null,"metadata":{},"sourceType":"script"}