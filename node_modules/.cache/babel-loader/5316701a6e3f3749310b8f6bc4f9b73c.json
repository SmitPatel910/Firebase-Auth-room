{"ast":null,"code":"/*! firebase-admin v9.11.0 */\n\"use strict\";\n/*!\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Auth = exports.TenantAwareAuth = exports.BaseAuth = void 0;\n\nvar deep_copy_1 = require(\"../utils/deep-copy\");\n\nvar user_record_1 = require(\"./user-record\");\n\nvar identifier_1 = require(\"./identifier\");\n\nvar token_generator_1 = require(\"./token-generator\");\n\nvar auth_api_request_1 = require(\"./auth-api-request\");\n\nvar error_1 = require(\"../utils/error\");\n\nvar utils = require(\"../utils/index\");\n\nvar validator = require(\"../utils/validator\");\n\nvar token_verifier_1 = require(\"./token-verifier\");\n\nvar auth_config_1 = require(\"./auth-config\");\n\nvar tenant_manager_1 = require(\"./tenant-manager\");\n\nvar crypto_signer_1 = require(\"../utils/crypto-signer\");\n/**\n * Base Auth class. Mainly used for user management APIs.\n */\n\n\nvar BaseAuth =\n/** @class */\nfunction () {\n  /**\n   * The BaseAuth class constructor.\n   *\n   * @param app The FirebaseApp to associate with this Auth instance.\n   * @param authRequestHandler The RPC request handler for this instance.\n   * @param tokenGenerator Optional token generator. If not specified, a\n   *     (non-tenant-aware) instance will be created. Use this paramter to\n   *     specify a tenant-aware tokenGenerator.\n   * @constructor\n   */\n  function BaseAuth(app, authRequestHandler, tokenGenerator) {\n    this.authRequestHandler = authRequestHandler;\n\n    if (tokenGenerator) {\n      this.tokenGenerator = tokenGenerator;\n    } else {\n      this.tokenGenerator = createFirebaseTokenGenerator(app);\n    }\n\n    this.sessionCookieVerifier = token_verifier_1.createSessionCookieVerifier(app);\n    this.idTokenVerifier = token_verifier_1.createIdTokenVerifier(app);\n  }\n  /**\n   * Creates a new custom token that can be sent back to a client to use with\n   * signInWithCustomToken().\n   *\n   * @param {string} uid The uid to use as the JWT subject.\n   * @param {object=} developerClaims Optional additional claims to include in the JWT payload.\n   *\n   * @return {Promise<string>} A JWT for the provided payload.\n   */\n\n\n  BaseAuth.prototype.createCustomToken = function (uid, developerClaims) {\n    return this.tokenGenerator.createCustomToken(uid, developerClaims);\n  };\n  /**\n   * Verifies a JWT auth token. Returns a Promise with the tokens claims. Rejects\n   * the promise if the token could not be verified. If checkRevoked is set to true,\n   * verifies if the session corresponding to the ID token was revoked. If the corresponding\n   * user's session was invalidated, an auth/id-token-revoked error is thrown. If not specified\n   * the check is not applied.\n   *\n   * @param {string} idToken The JWT to verify.\n   * @param {boolean=} checkRevoked Whether to check if the ID token is revoked.\n   * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\n   *     verification.\n   */\n\n\n  BaseAuth.prototype.verifyIdToken = function (idToken, checkRevoked) {\n    var _this = this;\n\n    if (checkRevoked === void 0) {\n      checkRevoked = false;\n    }\n\n    var isEmulator = auth_api_request_1.useEmulator();\n    return this.idTokenVerifier.verifyJWT(idToken, isEmulator).then(function (decodedIdToken) {\n      // Whether to check if the token was revoked.\n      if (checkRevoked || isEmulator) {\n        return _this.verifyDecodedJWTNotRevoked(decodedIdToken, error_1.AuthClientErrorCode.ID_TOKEN_REVOKED);\n      }\n\n      return decodedIdToken;\n    });\n  };\n  /**\n   * Looks up the user identified by the provided user id and returns a promise that is\n   * fulfilled with a user record for the given user if that user is found.\n   *\n   * @param {string} uid The uid of the user to look up.\n   * @return {Promise<UserRecord>} A promise that resolves with the corresponding user record.\n   */\n\n\n  BaseAuth.prototype.getUser = function (uid) {\n    return this.authRequestHandler.getAccountInfoByUid(uid).then(function (response) {\n      // Returns the user record populated with server response.\n      return new user_record_1.UserRecord(response.users[0]);\n    });\n  };\n  /**\n   * Looks up the user identified by the provided email and returns a promise that is\n   * fulfilled with a user record for the given user if that user is found.\n   *\n   * @param {string} email The email of the user to look up.\n   * @return {Promise<UserRecord>} A promise that resolves with the corresponding user record.\n   */\n\n\n  BaseAuth.prototype.getUserByEmail = function (email) {\n    return this.authRequestHandler.getAccountInfoByEmail(email).then(function (response) {\n      // Returns the user record populated with server response.\n      return new user_record_1.UserRecord(response.users[0]);\n    });\n  };\n  /**\n   * Looks up the user identified by the provided phone number and returns a promise that is\n   * fulfilled with a user record for the given user if that user is found.\n   *\n   * @param {string} phoneNumber The phone number of the user to look up.\n   * @return {Promise<UserRecord>} A promise that resolves with the corresponding user record.\n   */\n\n\n  BaseAuth.prototype.getUserByPhoneNumber = function (phoneNumber) {\n    return this.authRequestHandler.getAccountInfoByPhoneNumber(phoneNumber).then(function (response) {\n      // Returns the user record populated with server response.\n      return new user_record_1.UserRecord(response.users[0]);\n    });\n  };\n  /**\n   * Gets the user data for the user corresponding to a given provider id.\n   *\n   * See [Retrieve user data](/docs/auth/admin/manage-users#retrieve_user_data)\n   * for code samples and detailed documentation.\n   *\n   * @param providerId The provider ID, for example, \"google.com\" for the\n   *   Google provider.\n   * @param uid The user identifier for the given provider.\n   *\n   * @return A promise fulfilled with the user data corresponding to the\n   *   given provider id.\n   */\n\n\n  BaseAuth.prototype.getUserByProviderUid = function (providerId, uid) {\n    // Although we don't really advertise it, we want to also handle\n    // non-federated idps with this call. So if we detect one of them, we'll\n    // reroute this request appropriately.\n    if (providerId === 'phone') {\n      return this.getUserByPhoneNumber(uid);\n    } else if (providerId === 'email') {\n      return this.getUserByEmail(uid);\n    }\n\n    return this.authRequestHandler.getAccountInfoByFederatedUid(providerId, uid).then(function (response) {\n      // Returns the user record populated with server response.\n      return new user_record_1.UserRecord(response.users[0]);\n    });\n  };\n  /**\n   * Gets the user data corresponding to the specified identifiers.\n   *\n   * There are no ordering guarantees; in particular, the nth entry in the result list is not\n   * guaranteed to correspond to the nth entry in the input parameters list.\n   *\n   * Only a maximum of 100 identifiers may be supplied. If more than 100 identifiers are supplied,\n   * this method will immediately throw a FirebaseAuthError.\n   *\n   * @param identifiers The identifiers used to indicate which user records should be returned. Must\n   *     have <= 100 entries.\n   * @return {Promise<GetUsersResult>} A promise that resolves to the corresponding user records.\n   * @throws FirebaseAuthError If any of the identifiers are invalid or if more than 100\n   *     identifiers are specified.\n   */\n\n\n  BaseAuth.prototype.getUsers = function (identifiers) {\n    if (!validator.isArray(identifiers)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '`identifiers` parameter must be an array');\n    }\n\n    return this.authRequestHandler.getAccountInfoByIdentifiers(identifiers).then(function (response) {\n      /**\n       * Checks if the specified identifier is within the list of\n       * UserRecords.\n       */\n      var isUserFound = function isUserFound(id, userRecords) {\n        return !!userRecords.find(function (userRecord) {\n          if (identifier_1.isUidIdentifier(id)) {\n            return id.uid === userRecord.uid;\n          } else if (identifier_1.isEmailIdentifier(id)) {\n            return id.email === userRecord.email;\n          } else if (identifier_1.isPhoneIdentifier(id)) {\n            return id.phoneNumber === userRecord.phoneNumber;\n          } else if (identifier_1.isProviderIdentifier(id)) {\n            var matchingUserInfo = userRecord.providerData.find(function (userInfo) {\n              return id.providerId === userInfo.providerId;\n            });\n            return !!matchingUserInfo && id.providerUid === matchingUserInfo.uid;\n          } else {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Unhandled identifier type');\n          }\n        });\n      };\n\n      var users = response.users ? response.users.map(function (user) {\n        return new user_record_1.UserRecord(user);\n      }) : [];\n      var notFound = identifiers.filter(function (id) {\n        return !isUserFound(id, users);\n      });\n      return {\n        users: users,\n        notFound: notFound\n      };\n    });\n  };\n  /**\n   * Exports a batch of user accounts. Batch size is determined by the maxResults argument.\n   * Starting point of the batch is determined by the pageToken argument.\n   *\n   * @param {number=} maxResults The page size, 1000 if undefined. This is also the maximum\n   *     allowed limit.\n   * @param {string=} pageToken The next page token. If not specified, returns users starting\n   *     without any offset.\n   * @return {Promise<{users: UserRecord[], pageToken?: string}>} A promise that resolves with\n   *     the current batch of downloaded users and the next page token. For the last page, an\n   *     empty list of users and no page token are returned.\n   */\n\n\n  BaseAuth.prototype.listUsers = function (maxResults, pageToken) {\n    return this.authRequestHandler.downloadAccount(maxResults, pageToken).then(function (response) {\n      // List of users to return.\n      var users = []; // Convert each user response to a UserRecord.\n\n      response.users.forEach(function (userResponse) {\n        users.push(new user_record_1.UserRecord(userResponse));\n      }); // Return list of user records and the next page token if available.\n\n      var result = {\n        users: users,\n        pageToken: response.nextPageToken\n      }; // Delete result.pageToken if undefined.\n\n      if (typeof result.pageToken === 'undefined') {\n        delete result.pageToken;\n      }\n\n      return result;\n    });\n  };\n  /**\n   * Creates a new user with the properties provided.\n   *\n   * @param {CreateRequest} properties The properties to set on the new user record to be created.\n   * @return {Promise<UserRecord>} A promise that resolves with the newly created user record.\n   */\n\n\n  BaseAuth.prototype.createUser = function (properties) {\n    var _this = this;\n\n    return this.authRequestHandler.createNewAccount(properties).then(function (uid) {\n      // Return the corresponding user record.\n      return _this.getUser(uid);\n    }).catch(function (error) {\n      if (error.code === 'auth/user-not-found') {\n        // Something must have happened after creating the user and then retrieving it.\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Unable to create the user record provided.');\n      }\n\n      throw error;\n    });\n  };\n  /**\n   * Deletes the user identified by the provided user id and returns a promise that is\n   * fulfilled when the user is found and successfully deleted.\n   *\n   * @param {string} uid The uid of the user to delete.\n   * @return {Promise<void>} A promise that resolves when the user is successfully deleted.\n   */\n\n\n  BaseAuth.prototype.deleteUser = function (uid) {\n    return this.authRequestHandler.deleteAccount(uid).then(function () {// Return nothing on success.\n    });\n  };\n\n  BaseAuth.prototype.deleteUsers = function (uids) {\n    if (!validator.isArray(uids)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '`uids` parameter must be an array');\n    }\n\n    return this.authRequestHandler.deleteAccounts(uids,\n    /*force=*/\n    true).then(function (batchDeleteAccountsResponse) {\n      var result = {\n        failureCount: 0,\n        successCount: uids.length,\n        errors: []\n      };\n\n      if (!validator.isNonEmptyArray(batchDeleteAccountsResponse.errors)) {\n        return result;\n      }\n\n      result.failureCount = batchDeleteAccountsResponse.errors.length;\n      result.successCount = uids.length - batchDeleteAccountsResponse.errors.length;\n      result.errors = batchDeleteAccountsResponse.errors.map(function (batchDeleteErrorInfo) {\n        if (batchDeleteErrorInfo.index === undefined) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Corrupt BatchDeleteAccountsResponse detected');\n        }\n\n        var errMsgToError = function errMsgToError(msg) {\n          // We unconditionally set force=true, so the 'NOT_DISABLED' error\n          // should not be possible.\n          var code = msg && msg.startsWith('NOT_DISABLED') ? error_1.AuthClientErrorCode.USER_NOT_DISABLED : error_1.AuthClientErrorCode.INTERNAL_ERROR;\n          return new error_1.FirebaseAuthError(code, batchDeleteErrorInfo.message);\n        };\n\n        return {\n          index: batchDeleteErrorInfo.index,\n          error: errMsgToError(batchDeleteErrorInfo.message)\n        };\n      });\n      return result;\n    });\n  };\n  /**\n   * Updates an existing user with the properties provided.\n   *\n   * @param {string} uid The uid identifier of the user to update.\n   * @param {UpdateRequest} properties The properties to update on the existing user.\n   * @return {Promise<UserRecord>} A promise that resolves with the modified user record.\n   */\n\n\n  BaseAuth.prototype.updateUser = function (uid, properties) {\n    var _this = this; // Although we don't really advertise it, we want to also handle linking of\n    // non-federated idps with this call. So if we detect one of them, we'll\n    // adjust the properties parameter appropriately. This *does* imply that a\n    // conflict could arise, e.g. if the user provides a phoneNumber property,\n    // but also provides a providerToLink with a 'phone' provider id. In that\n    // case, we'll throw an error.\n\n\n    properties = deep_copy_1.deepCopy(properties);\n\n    if (properties === null || properties === void 0 ? void 0 : properties.providerToLink) {\n      if (properties.providerToLink.providerId === 'email') {\n        if (typeof properties.email !== 'undefined') {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Both UpdateRequest.email and UpdateRequest.providerToLink.providerId='email' were set. To \" + 'link to the email/password provider, only specify the UpdateRequest.email field.');\n        }\n\n        properties.email = properties.providerToLink.uid;\n        delete properties.providerToLink;\n      } else if (properties.providerToLink.providerId === 'phone') {\n        if (typeof properties.phoneNumber !== 'undefined') {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Both UpdateRequest.phoneNumber and UpdateRequest.providerToLink.providerId='phone' were set. To \" + 'link to a phone provider, only specify the UpdateRequest.phoneNumber field.');\n        }\n\n        properties.phoneNumber = properties.providerToLink.uid;\n        delete properties.providerToLink;\n      }\n    }\n\n    if (properties === null || properties === void 0 ? void 0 : properties.providersToUnlink) {\n      if (properties.providersToUnlink.indexOf('phone') !== -1) {\n        // If we've been told to unlink the phone provider both via setting\n        // phoneNumber to null *and* by setting providersToUnlink to include\n        // 'phone', then we'll reject that. Though it might also be reasonable\n        // to relax this restriction and just unlink it.\n        if (properties.phoneNumber === null) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Both UpdateRequest.phoneNumber=null and UpdateRequest.providersToUnlink=['phone'] were set. To \" + 'unlink from a phone provider, only specify the UpdateRequest.phoneNumber=null field.');\n        }\n      }\n    }\n\n    return this.authRequestHandler.updateExistingAccount(uid, properties).then(function (existingUid) {\n      // Return the corresponding user record.\n      return _this.getUser(existingUid);\n    });\n  };\n  /**\n   * Sets additional developer claims on an existing user identified by the provided UID.\n   *\n   * @param {string} uid The user to edit.\n   * @param {object} customUserClaims The developer claims to set.\n   * @return {Promise<void>} A promise that resolves when the operation completes\n   *     successfully.\n   */\n\n\n  BaseAuth.prototype.setCustomUserClaims = function (uid, customUserClaims) {\n    return this.authRequestHandler.setCustomUserClaims(uid, customUserClaims).then(function () {// Return nothing on success.\n    });\n  };\n  /**\n   * Revokes all refresh tokens for the specified user identified by the provided UID.\n   * In addition to revoking all refresh tokens for a user, all ID tokens issued before\n   * revocation will also be revoked on the Auth backend. Any request with an ID token\n   * generated before revocation will be rejected with a token expired error.\n   *\n   * @param {string} uid The user whose tokens are to be revoked.\n   * @return {Promise<void>} A promise that resolves when the operation completes\n   *     successfully.\n   */\n\n\n  BaseAuth.prototype.revokeRefreshTokens = function (uid) {\n    return this.authRequestHandler.revokeRefreshTokens(uid).then(function () {// Return nothing on success.\n    });\n  };\n  /**\n   * Imports the list of users provided to Firebase Auth. This is useful when\n   * migrating from an external authentication system without having to use the Firebase CLI SDK.\n   * At most, 1000 users are allowed to be imported one at a time.\n   * When importing a list of password users, UserImportOptions are required to be specified.\n   *\n   * @param {UserImportRecord[]} users The list of user records to import to Firebase Auth.\n   * @param {UserImportOptions=} options The user import options, required when the users provided\n   *     include password credentials.\n   * @return {Promise<UserImportResult>} A promise that resolves when the operation completes\n   *     with the result of the import. This includes the number of successful imports, the number\n   *     of failed uploads and their corresponding errors.\n   */\n\n\n  BaseAuth.prototype.importUsers = function (users, options) {\n    return this.authRequestHandler.uploadAccount(users, options);\n  };\n  /**\n   * Creates a new Firebase session cookie with the specified options that can be used for\n   * session management (set as a server side session cookie with custom cookie policy).\n   * The session cookie JWT will have the same payload claims as the provided ID token.\n   *\n   * @param {string} idToken The Firebase ID token to exchange for a session cookie.\n   * @param {SessionCookieOptions} sessionCookieOptions The session cookie options which includes\n   *     custom session duration.\n   *\n   * @return {Promise<string>} A promise that resolves on success with the created session cookie.\n   */\n\n\n  BaseAuth.prototype.createSessionCookie = function (idToken, sessionCookieOptions) {\n    // Return rejected promise if expiresIn is not available.\n    if (!validator.isNonNullObject(sessionCookieOptions) || !validator.isNumber(sessionCookieOptions.expiresIn)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION));\n    }\n\n    return this.authRequestHandler.createSessionCookie(idToken, sessionCookieOptions.expiresIn);\n  };\n  /**\n   * Verifies a Firebase session cookie. Returns a Promise with the tokens claims. Rejects\n   * the promise if the token could not be verified. If checkRevoked is set to true,\n   * verifies if the session corresponding to the session cookie was revoked. If the corresponding\n   * user's session was invalidated, an auth/session-cookie-revoked error is thrown. If not\n   * specified the check is not performed.\n   *\n   * @param {string} sessionCookie The session cookie to verify.\n   * @param {boolean=} checkRevoked Whether to check if the session cookie is revoked.\n   * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\n   *     verification.\n   */\n\n\n  BaseAuth.prototype.verifySessionCookie = function (sessionCookie, checkRevoked) {\n    var _this = this;\n\n    if (checkRevoked === void 0) {\n      checkRevoked = false;\n    }\n\n    var isEmulator = auth_api_request_1.useEmulator();\n    return this.sessionCookieVerifier.verifyJWT(sessionCookie, isEmulator).then(function (decodedIdToken) {\n      // Whether to check if the token was revoked.\n      if (checkRevoked || isEmulator) {\n        return _this.verifyDecodedJWTNotRevoked(decodedIdToken, error_1.AuthClientErrorCode.SESSION_COOKIE_REVOKED);\n      }\n\n      return decodedIdToken;\n    });\n  };\n  /**\n   * Generates the out of band email action link for password reset flows for the\n   * email specified using the action code settings provided.\n   * Returns a promise that resolves with the generated link.\n   *\n   * @param {string} email The email of the user whose password is to be reset.\n   * @param {ActionCodeSettings=} actionCodeSettings The optional action code setings which defines whether\n   *     the link is to be handled by a mobile app and the additional state information to be passed in the\n   *     deep link, etc.\n   * @return {Promise<string>} A promise that resolves with the password reset link.\n   */\n\n\n  BaseAuth.prototype.generatePasswordResetLink = function (email, actionCodeSettings) {\n    return this.authRequestHandler.getEmailActionLink('PASSWORD_RESET', email, actionCodeSettings);\n  };\n  /**\n   * Generates the out of band email action link for email verification flows for the\n   * email specified using the action code settings provided.\n   * Returns a promise that resolves with the generated link.\n   *\n   * @param {string} email The email of the user to be verified.\n   * @param {ActionCodeSettings=} actionCodeSettings The optional action code setings which defines whether\n   *     the link is to be handled by a mobile app and the additional state information to be passed in the\n   *     deep link, etc.\n   * @return {Promise<string>} A promise that resolves with the email verification link.\n   */\n\n\n  BaseAuth.prototype.generateEmailVerificationLink = function (email, actionCodeSettings) {\n    return this.authRequestHandler.getEmailActionLink('VERIFY_EMAIL', email, actionCodeSettings);\n  };\n  /**\n   * Generates the out of band email action link for email link sign-in flows for the\n   * email specified using the action code settings provided.\n   * Returns a promise that resolves with the generated link.\n   *\n   * @param {string} email The email of the user signing in.\n   * @param {ActionCodeSettings} actionCodeSettings The required action code setings which defines whether\n   *     the link is to be handled by a mobile app and the additional state information to be passed in the\n   *     deep link, etc.\n   * @return {Promise<string>} A promise that resolves with the email sign-in link.\n   */\n\n\n  BaseAuth.prototype.generateSignInWithEmailLink = function (email, actionCodeSettings) {\n    return this.authRequestHandler.getEmailActionLink('EMAIL_SIGNIN', email, actionCodeSettings);\n  };\n  /**\n   * Returns the list of existing provider configuation matching the filter provided.\n   * At most, 100 provider configs are allowed to be imported at a time.\n   *\n   * @param {AuthProviderConfigFilter} options The provider config filter to apply.\n   * @return {Promise<ListProviderConfigResults>} A promise that resolves with the list of provider configs\n   *     meeting the filter requirements.\n   */\n\n\n  BaseAuth.prototype.listProviderConfigs = function (options) {\n    var processResponse = function processResponse(response, providerConfigs) {\n      // Return list of provider configuration and the next page token if available.\n      var result = {\n        providerConfigs: providerConfigs\n      }; // Delete result.pageToken if undefined.\n\n      if (Object.prototype.hasOwnProperty.call(response, 'nextPageToken')) {\n        result.pageToken = response.nextPageToken;\n      }\n\n      return result;\n    };\n\n    if (options && options.type === 'oidc') {\n      return this.authRequestHandler.listOAuthIdpConfigs(options.maxResults, options.pageToken).then(function (response) {\n        // List of provider configurations to return.\n        var providerConfigs = []; // Convert each provider config response to a OIDCConfig.\n\n        response.oauthIdpConfigs.forEach(function (configResponse) {\n          providerConfigs.push(new auth_config_1.OIDCConfig(configResponse));\n        }); // Return list of provider configuration and the next page token if available.\n\n        return processResponse(response, providerConfigs);\n      });\n    } else if (options && options.type === 'saml') {\n      return this.authRequestHandler.listInboundSamlConfigs(options.maxResults, options.pageToken).then(function (response) {\n        // List of provider configurations to return.\n        var providerConfigs = []; // Convert each provider config response to a SAMLConfig.\n\n        response.inboundSamlConfigs.forEach(function (configResponse) {\n          providerConfigs.push(new auth_config_1.SAMLConfig(configResponse));\n        }); // Return list of provider configuration and the next page token if available.\n\n        return processResponse(response, providerConfigs);\n      });\n    }\n\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"AuthProviderConfigFilter.type\" must be either \"saml\" or \"oidc\"'));\n  };\n  /**\n   * Looks up an Auth provider configuration by ID.\n   * Returns a promise that resolves with the provider configuration corresponding to the provider ID specified.\n   *\n   * @param {string} providerId  The provider ID corresponding to the provider config to return.\n   * @return {Promise<AuthProviderConfig>}\n   */\n\n\n  BaseAuth.prototype.getProviderConfig = function (providerId) {\n    if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.getOAuthIdpConfig(providerId).then(function (response) {\n        return new auth_config_1.OIDCConfig(response);\n      });\n    } else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.getInboundSamlConfig(providerId).then(function (response) {\n        return new auth_config_1.SAMLConfig(response);\n      });\n    }\n\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n  };\n  /**\n   * Deletes the provider configuration corresponding to the provider ID passed.\n   *\n   * @param {string} providerId The provider ID corresponding to the provider config to delete.\n   * @return {Promise<void>} A promise that resolves on completion.\n   */\n\n\n  BaseAuth.prototype.deleteProviderConfig = function (providerId) {\n    if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.deleteOAuthIdpConfig(providerId);\n    } else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.deleteInboundSamlConfig(providerId);\n    }\n\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n  };\n  /**\n   * Returns a promise that resolves with the updated AuthProviderConfig when the provider configuration corresponding\n   * to the provider ID specified is updated with the specified configuration.\n   *\n   * @param {string} providerId The provider ID corresponding to the provider config to update.\n   * @param {UpdateAuthProviderRequest} updatedConfig The updated configuration.\n   * @return {Promise<AuthProviderConfig>} A promise that resolves with the updated provider configuration.\n   */\n\n\n  BaseAuth.prototype.updateProviderConfig = function (providerId, updatedConfig) {\n    if (!validator.isNonNullObject(updatedConfig)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing \"UpdateAuthProviderRequest\" configuration.'));\n    }\n\n    if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.updateOAuthIdpConfig(providerId, updatedConfig).then(function (response) {\n        return new auth_config_1.OIDCConfig(response);\n      });\n    } else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.updateInboundSamlConfig(providerId, updatedConfig).then(function (response) {\n        return new auth_config_1.SAMLConfig(response);\n      });\n    }\n\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n  };\n  /**\n   * Returns a promise that resolves with the newly created AuthProviderConfig when the new provider configuration is\n   * created.\n   * @param {AuthProviderConfig} config The provider configuration to create.\n   * @return {Promise<AuthProviderConfig>} A promise that resolves with the created provider configuration.\n   */\n\n\n  BaseAuth.prototype.createProviderConfig = function (config) {\n    if (!validator.isNonNullObject(config)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing \"AuthProviderConfig\" configuration.'));\n    }\n\n    if (auth_config_1.OIDCConfig.isProviderId(config.providerId)) {\n      return this.authRequestHandler.createOAuthIdpConfig(config).then(function (response) {\n        return new auth_config_1.OIDCConfig(response);\n      });\n    } else if (auth_config_1.SAMLConfig.isProviderId(config.providerId)) {\n      return this.authRequestHandler.createInboundSamlConfig(config).then(function (response) {\n        return new auth_config_1.SAMLConfig(response);\n      });\n    }\n\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n  };\n  /**\n   * Verifies the decoded Firebase issued JWT is not revoked. Returns a promise that resolves\n   * with the decoded claims on success. Rejects the promise with revocation error if revoked.\n   *\n   * @param {DecodedIdToken} decodedIdToken The JWT's decoded claims.\n   * @param {ErrorInfo} revocationErrorInfo The revocation error info to throw on revocation\n   *     detection.\n   * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\n   *     verification.\n   */\n\n\n  BaseAuth.prototype.verifyDecodedJWTNotRevoked = function (decodedIdToken, revocationErrorInfo) {\n    // Get tokens valid after time for the corresponding user.\n    return this.getUser(decodedIdToken.sub).then(function (user) {\n      // If no tokens valid after time available, token is not revoked.\n      if (user.tokensValidAfterTime) {\n        // Get the ID token authentication time and convert to milliseconds UTC.\n        var authTimeUtc = decodedIdToken.auth_time * 1000; // Get user tokens valid after time in milliseconds UTC.\n\n        var validSinceUtc = new Date(user.tokensValidAfterTime).getTime(); // Check if authentication time is older than valid since time.\n\n        if (authTimeUtc < validSinceUtc) {\n          throw new error_1.FirebaseAuthError(revocationErrorInfo);\n        }\n      } // All checks above passed. Return the decoded token.\n\n\n      return decodedIdToken;\n    });\n  };\n\n  return BaseAuth;\n}();\n\nexports.BaseAuth = BaseAuth;\n/**\n * The tenant aware Auth class.\n */\n\nvar TenantAwareAuth =\n/** @class */\nfunction (_super) {\n  __extends(TenantAwareAuth, _super);\n  /**\n   * The TenantAwareAuth class constructor.\n   *\n   * @param {object} app The app that created this tenant.\n   * @param tenantId The corresponding tenant ID.\n   * @constructor\n   */\n\n\n  function TenantAwareAuth(app, tenantId) {\n    var _this = _super.call(this, app, new auth_api_request_1.TenantAwareAuthRequestHandler(app, tenantId), createFirebaseTokenGenerator(app, tenantId)) || this;\n\n    utils.addReadonlyGetter(_this, 'tenantId', tenantId);\n    return _this;\n  }\n  /**\n   * Verifies a JWT auth token. Returns a Promise with the tokens claims. Rejects\n   * the promise if the token could not be verified. If checkRevoked is set to true,\n   * verifies if the session corresponding to the ID token was revoked. If the corresponding\n   * user's session was invalidated, an auth/id-token-revoked error is thrown. If not specified\n   * the check is not applied.\n   *\n   * @param {string} idToken The JWT to verify.\n   * @param {boolean=} checkRevoked Whether to check if the ID token is revoked.\n   * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\n   *     verification.\n   */\n\n\n  TenantAwareAuth.prototype.verifyIdToken = function (idToken, checkRevoked) {\n    var _this = this;\n\n    if (checkRevoked === void 0) {\n      checkRevoked = false;\n    }\n\n    return _super.prototype.verifyIdToken.call(this, idToken, checkRevoked).then(function (decodedClaims) {\n      // Validate tenant ID.\n      if (decodedClaims.firebase.tenant !== _this.tenantId) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID);\n      }\n\n      return decodedClaims;\n    });\n  };\n  /**\n   * Creates a new Firebase session cookie with the specified options that can be used for\n   * session management (set as a server side session cookie with custom cookie policy).\n   * The session cookie JWT will have the same payload claims as the provided ID token.\n   *\n   * @param {string} idToken The Firebase ID token to exchange for a session cookie.\n   * @param {SessionCookieOptions} sessionCookieOptions The session cookie options which includes\n   *     custom session duration.\n   *\n   * @return {Promise<string>} A promise that resolves on success with the created session cookie.\n   */\n\n\n  TenantAwareAuth.prototype.createSessionCookie = function (idToken, sessionCookieOptions) {\n    var _this = this; // Validate arguments before processing.\n\n\n    if (!validator.isNonEmptyString(idToken)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ID_TOKEN));\n    }\n\n    if (!validator.isNonNullObject(sessionCookieOptions) || !validator.isNumber(sessionCookieOptions.expiresIn)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION));\n    } // This will verify the ID token and then match the tenant ID before creating the session cookie.\n\n\n    return this.verifyIdToken(idToken).then(function () {\n      return _super.prototype.createSessionCookie.call(_this, idToken, sessionCookieOptions);\n    });\n  };\n  /**\n   * Verifies a Firebase session cookie. Returns a Promise with the tokens claims. Rejects\n   * the promise if the token could not be verified. If checkRevoked is set to true,\n   * verifies if the session corresponding to the session cookie was revoked. If the corresponding\n   * user's session was invalidated, an auth/session-cookie-revoked error is thrown. If not\n   * specified the check is not performed.\n   *\n   * @param {string} sessionCookie The session cookie to verify.\n   * @param {boolean=} checkRevoked Whether to check if the session cookie is revoked.\n   * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\n   *     verification.\n   */\n\n\n  TenantAwareAuth.prototype.verifySessionCookie = function (sessionCookie, checkRevoked) {\n    var _this = this;\n\n    if (checkRevoked === void 0) {\n      checkRevoked = false;\n    }\n\n    return _super.prototype.verifySessionCookie.call(this, sessionCookie, checkRevoked).then(function (decodedClaims) {\n      if (decodedClaims.firebase.tenant !== _this.tenantId) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID);\n      }\n\n      return decodedClaims;\n    });\n  };\n\n  return TenantAwareAuth;\n}(BaseAuth);\n\nexports.TenantAwareAuth = TenantAwareAuth;\n/**\n * Auth service bound to the provided app.\n * An Auth instance can have multiple tenants.\n */\n\nvar Auth =\n/** @class */\nfunction (_super) {\n  __extends(Auth, _super);\n  /**\n   * @param {object} app The app for this Auth service.\n   * @constructor\n   */\n\n\n  function Auth(app) {\n    var _this = _super.call(this, app, new auth_api_request_1.AuthRequestHandler(app)) || this;\n\n    _this.app_ = app;\n    _this.tenantManager_ = new tenant_manager_1.TenantManager(app);\n    return _this;\n  }\n\n  Object.defineProperty(Auth.prototype, \"app\", {\n    /**\n     * Returns the app associated with this Auth instance.\n     *\n     * @return {FirebaseApp} The app associated with this Auth instance.\n     */\n    get: function get() {\n      return this.app_;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @return The current Auth instance's tenant manager. */\n\n  Auth.prototype.tenantManager = function () {\n    return this.tenantManager_;\n  };\n\n  return Auth;\n}(BaseAuth);\n\nexports.Auth = Auth;\n\nfunction createFirebaseTokenGenerator(app, tenantId) {\n  try {\n    var signer = auth_api_request_1.useEmulator() ? new token_generator_1.EmulatedSigner() : crypto_signer_1.cryptoSignerFromApp(app);\n    return new token_generator_1.FirebaseTokenGenerator(signer, tenantId);\n  } catch (err) {\n    throw token_generator_1.handleCryptoSignerError(err);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}