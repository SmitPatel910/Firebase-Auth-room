{"ast":null,"code":"/*! firebase-admin v9.11.0 */\n\"use strict\";\n/*!\n * Copyright 2021 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JwtErrorCode = exports.JwtError = exports.decodeJwt = exports.verifyJwtSignature = exports.EmulatorSignatureVerifier = exports.PublicKeySignatureVerifier = exports.UrlKeyFetcher = exports.JwksFetcher = exports.ALGORITHM_RS256 = void 0;\n\nvar validator = require(\"./validator\");\n\nvar jwt = require(\"jsonwebtoken\");\n\nvar jwks = require(\"jwks-rsa\");\n\nvar api_request_1 = require(\"../utils/api-request\");\n\nexports.ALGORITHM_RS256 = 'RS256'; // `jsonwebtoken` converts errors from the `getKey` callback to its own `JsonWebTokenError` type\n// and prefixes the error message with the following. Use the prefix to identify errors thrown\n// from the key provider callback.\n// https://github.com/auth0/node-jsonwebtoken/blob/d71e383862fc735991fd2e759181480f066bf138/verify.js#L96\n\nvar JWT_CALLBACK_ERROR_PREFIX = 'error in secret or public key callback: ';\nvar NO_MATCHING_KID_ERROR_MESSAGE = 'no-matching-kid-error';\nvar NO_KID_IN_HEADER_ERROR_MESSAGE = 'no-kid-in-header-error';\nvar ONE_DAY_IN_SECONDS = 24 * 3600;\n\nvar JwksFetcher =\n/** @class */\nfunction () {\n  function JwksFetcher(jwksUrl) {\n    this.publicKeysExpireAt = 0;\n\n    if (!validator.isURL(jwksUrl)) {\n      throw new Error('The provided JWKS URL is not a valid URL.');\n    }\n\n    this.client = jwks({\n      jwksUri: jwksUrl,\n      cache: false\n    });\n  }\n\n  JwksFetcher.prototype.fetchPublicKeys = function () {\n    if (this.shouldRefresh()) {\n      return this.refresh();\n    }\n\n    return Promise.resolve(this.publicKeys);\n  };\n\n  JwksFetcher.prototype.shouldRefresh = function () {\n    return !this.publicKeys || this.publicKeysExpireAt <= Date.now();\n  };\n\n  JwksFetcher.prototype.refresh = function () {\n    var _this = this;\n\n    return this.client.getSigningKeys().then(function (signingKeys) {\n      // reset expire at from previous set of keys.\n      _this.publicKeysExpireAt = 0;\n      var newKeys = signingKeys.reduce(function (map, signingKey) {\n        map[signingKey.kid] = signingKey.getPublicKey();\n        return map;\n      }, {});\n      _this.publicKeysExpireAt = Date.now() + ONE_DAY_IN_SECONDS * 1000;\n      _this.publicKeys = newKeys;\n      return newKeys;\n    }).catch(function (err) {\n      throw new Error(\"Error fetching Json Web Keys: \" + err.message);\n    });\n  };\n\n  return JwksFetcher;\n}();\n\nexports.JwksFetcher = JwksFetcher;\n/**\n * Class to fetch public keys from a client certificates URL.\n */\n\nvar UrlKeyFetcher =\n/** @class */\nfunction () {\n  function UrlKeyFetcher(clientCertUrl, httpAgent) {\n    this.clientCertUrl = clientCertUrl;\n    this.httpAgent = httpAgent;\n    this.publicKeysExpireAt = 0;\n\n    if (!validator.isURL(clientCertUrl)) {\n      throw new Error('The provided public client certificate URL is not a valid URL.');\n    }\n  }\n  /**\n   * Fetches the public keys for the Google certs.\n   *\n   * @return A promise fulfilled with public keys for the Google certs.\n   */\n\n\n  UrlKeyFetcher.prototype.fetchPublicKeys = function () {\n    if (this.shouldRefresh()) {\n      return this.refresh();\n    }\n\n    return Promise.resolve(this.publicKeys);\n  };\n  /**\n   * Checks if the cached public keys need to be refreshed.\n   *\n   * @returns Whether the keys should be fetched from the client certs url or not.\n   */\n\n\n  UrlKeyFetcher.prototype.shouldRefresh = function () {\n    return !this.publicKeys || this.publicKeysExpireAt <= Date.now();\n  };\n\n  UrlKeyFetcher.prototype.refresh = function () {\n    var _this = this;\n\n    var client = new api_request_1.HttpClient();\n    var request = {\n      method: 'GET',\n      url: this.clientCertUrl,\n      httpAgent: this.httpAgent\n    };\n    return client.send(request).then(function (resp) {\n      if (!resp.isJson() || resp.data.error) {\n        // Treat all non-json messages and messages with an 'error' field as\n        // error responses.\n        throw new api_request_1.HttpError(resp);\n      } // reset expire at from previous set of keys.\n\n\n      _this.publicKeysExpireAt = 0;\n\n      if (Object.prototype.hasOwnProperty.call(resp.headers, 'cache-control')) {\n        var cacheControlHeader = resp.headers['cache-control'];\n        var parts = cacheControlHeader.split(',');\n        parts.forEach(function (part) {\n          var subParts = part.trim().split('=');\n\n          if (subParts[0] === 'max-age') {\n            var maxAge = +subParts[1];\n            _this.publicKeysExpireAt = Date.now() + maxAge * 1000;\n          }\n        });\n      }\n\n      _this.publicKeys = resp.data;\n      return resp.data;\n    }).catch(function (err) {\n      if (err instanceof api_request_1.HttpError) {\n        var errorMessage = 'Error fetching public keys for Google certs: ';\n        var resp = err.response;\n\n        if (resp.isJson() && resp.data.error) {\n          errorMessage += \"\" + resp.data.error;\n\n          if (resp.data.error_description) {\n            errorMessage += ' (' + resp.data.error_description + ')';\n          }\n        } else {\n          errorMessage += \"\" + resp.text;\n        }\n\n        throw new Error(errorMessage);\n      }\n\n      throw err;\n    });\n  };\n\n  return UrlKeyFetcher;\n}();\n\nexports.UrlKeyFetcher = UrlKeyFetcher;\n/**\n * Class for verifing JWT signature with a public key.\n */\n\nvar PublicKeySignatureVerifier =\n/** @class */\nfunction () {\n  function PublicKeySignatureVerifier(keyFetcher) {\n    this.keyFetcher = keyFetcher;\n\n    if (!validator.isNonNullObject(keyFetcher)) {\n      throw new Error('The provided key fetcher is not an object or null.');\n    }\n  }\n\n  PublicKeySignatureVerifier.withCertificateUrl = function (clientCertUrl, httpAgent) {\n    return new PublicKeySignatureVerifier(new UrlKeyFetcher(clientCertUrl, httpAgent));\n  };\n\n  PublicKeySignatureVerifier.withJwksUrl = function (jwksUrl) {\n    return new PublicKeySignatureVerifier(new JwksFetcher(jwksUrl));\n  };\n\n  PublicKeySignatureVerifier.prototype.verify = function (token) {\n    var _this = this;\n\n    if (!validator.isString(token)) {\n      return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, 'The provided token must be a string.'));\n    }\n\n    return verifyJwtSignature(token, getKeyCallback(this.keyFetcher), {\n      algorithms: [exports.ALGORITHM_RS256]\n    }).catch(function (error) {\n      if (error.code === JwtErrorCode.NO_KID_IN_HEADER) {\n        // No kid in JWT header. Try with all the public keys.\n        return _this.verifyWithoutKid(token);\n      }\n\n      throw error;\n    });\n  };\n\n  PublicKeySignatureVerifier.prototype.verifyWithoutKid = function (token) {\n    var _this = this;\n\n    return this.keyFetcher.fetchPublicKeys().then(function (publicKeys) {\n      return _this.verifyWithAllKeys(token, publicKeys);\n    });\n  };\n\n  PublicKeySignatureVerifier.prototype.verifyWithAllKeys = function (token, keys) {\n    var promises = [];\n    Object.values(keys).forEach(function (key) {\n      var result = verifyJwtSignature(token, key).then(function () {\n        return true;\n      }).catch(function (error) {\n        if (error.code === JwtErrorCode.TOKEN_EXPIRED) {\n          throw error;\n        }\n\n        return false;\n      });\n      promises.push(result);\n    });\n    return Promise.all(promises).then(function (result) {\n      if (result.every(function (r) {\n        return r === false;\n      })) {\n        throw new JwtError(JwtErrorCode.INVALID_SIGNATURE, 'Invalid token signature.');\n      }\n    });\n  };\n\n  return PublicKeySignatureVerifier;\n}();\n\nexports.PublicKeySignatureVerifier = PublicKeySignatureVerifier;\n/**\n * Class for verifing unsigned (emulator) JWTs.\n */\n\nvar EmulatorSignatureVerifier =\n/** @class */\nfunction () {\n  function EmulatorSignatureVerifier() {}\n\n  EmulatorSignatureVerifier.prototype.verify = function (token) {\n    // Signature checks skipped for emulator; no need to fetch public keys.\n    return verifyJwtSignature(token, '');\n  };\n\n  return EmulatorSignatureVerifier;\n}();\n\nexports.EmulatorSignatureVerifier = EmulatorSignatureVerifier;\n/**\n * Provides a callback to fetch public keys.\n *\n * @param fetcher KeyFetcher to fetch the keys from.\n * @returns A callback function that can be used to get keys in `jsonwebtoken`.\n */\n\nfunction getKeyCallback(fetcher) {\n  return function (header, callback) {\n    if (!header.kid) {\n      callback(new Error(NO_KID_IN_HEADER_ERROR_MESSAGE));\n    }\n\n    var kid = header.kid || '';\n    fetcher.fetchPublicKeys().then(function (publicKeys) {\n      if (!Object.prototype.hasOwnProperty.call(publicKeys, kid)) {\n        callback(new Error(NO_MATCHING_KID_ERROR_MESSAGE));\n      } else {\n        callback(null, publicKeys[kid]);\n      }\n    }).catch(function (error) {\n      callback(error);\n    });\n  };\n}\n/**\n * Verifies the signature of a JWT using the provided secret or a function to fetch\n * the secret or public key.\n *\n * @param token The JWT to be verfied.\n * @param secretOrPublicKey The secret or a function to fetch the secret or public key.\n * @param options JWT verification options.\n * @returns A Promise resolving for a token with a valid signature.\n */\n\n\nfunction verifyJwtSignature(token, secretOrPublicKey, options) {\n  if (!validator.isString(token)) {\n    return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, 'The provided token must be a string.'));\n  }\n\n  return new Promise(function (resolve, reject) {\n    jwt.verify(token, secretOrPublicKey, options, function (error) {\n      if (!error) {\n        return resolve();\n      }\n\n      if (error.name === 'TokenExpiredError') {\n        return reject(new JwtError(JwtErrorCode.TOKEN_EXPIRED, 'The provided token has expired. Get a fresh token from your ' + 'client app and try again.'));\n      } else if (error.name === 'JsonWebTokenError') {\n        if (error.message && error.message.includes(JWT_CALLBACK_ERROR_PREFIX)) {\n          var message = error.message.split(JWT_CALLBACK_ERROR_PREFIX).pop() || 'Error fetching public keys.';\n          var code = JwtErrorCode.KEY_FETCH_ERROR;\n\n          if (message === NO_MATCHING_KID_ERROR_MESSAGE) {\n            code = JwtErrorCode.NO_MATCHING_KID;\n          } else if (message === NO_KID_IN_HEADER_ERROR_MESSAGE) {\n            code = JwtErrorCode.NO_KID_IN_HEADER;\n          }\n\n          return reject(new JwtError(code, message));\n        }\n      }\n\n      return reject(new JwtError(JwtErrorCode.INVALID_SIGNATURE, error.message));\n    });\n  });\n}\n\nexports.verifyJwtSignature = verifyJwtSignature;\n/**\n * Decodes general purpose Firebase JWTs.\n *\n * @param jwtToken JWT token to be decoded.\n * @returns Decoded token containing the header and payload.\n */\n\nfunction decodeJwt(jwtToken) {\n  if (!validator.isString(jwtToken)) {\n    return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, 'The provided token must be a string.'));\n  }\n\n  var fullDecodedToken = jwt.decode(jwtToken, {\n    complete: true\n  });\n\n  if (!fullDecodedToken) {\n    return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, 'Decoding token failed.'));\n  }\n\n  var header = fullDecodedToken === null || fullDecodedToken === void 0 ? void 0 : fullDecodedToken.header;\n  var payload = fullDecodedToken === null || fullDecodedToken === void 0 ? void 0 : fullDecodedToken.payload;\n  return Promise.resolve({\n    header: header,\n    payload: payload\n  });\n}\n\nexports.decodeJwt = decodeJwt;\n/**\n * Jwt error code structure.\n *\n * @param code The error code.\n * @param message The error message.\n * @constructor\n */\n\nvar JwtError =\n/** @class */\nfunction (_super) {\n  __extends(JwtError, _super);\n\n  function JwtError(code, message) {\n    var _this = _super.call(this, message) || this;\n\n    _this.code = code;\n    _this.message = message;\n    _this.__proto__ = JwtError.prototype;\n    return _this;\n  }\n\n  return JwtError;\n}(Error);\n\nexports.JwtError = JwtError;\n/**\n * JWT error codes.\n */\n\nvar JwtErrorCode;\n\n(function (JwtErrorCode) {\n  JwtErrorCode[\"INVALID_ARGUMENT\"] = \"invalid-argument\";\n  JwtErrorCode[\"INVALID_CREDENTIAL\"] = \"invalid-credential\";\n  JwtErrorCode[\"TOKEN_EXPIRED\"] = \"token-expired\";\n  JwtErrorCode[\"INVALID_SIGNATURE\"] = \"invalid-token\";\n  JwtErrorCode[\"NO_MATCHING_KID\"] = \"no-matching-kid-error\";\n  JwtErrorCode[\"NO_KID_IN_HEADER\"] = \"no-kid-error\";\n  JwtErrorCode[\"KEY_FETCH_ERROR\"] = \"key-fetch-error\";\n})(JwtErrorCode = exports.JwtErrorCode || (exports.JwtErrorCode = {}));","map":null,"metadata":{},"sourceType":"script"}