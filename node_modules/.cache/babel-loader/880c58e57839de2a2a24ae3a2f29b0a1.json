{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar net_1 = __importDefault(require(\"net\"));\n\nvar tls_1 = __importDefault(require(\"tls\"));\n\nvar url_1 = __importDefault(require(\"url\"));\n\nvar assert_1 = __importDefault(require(\"assert\"));\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar agent_base_1 = require(\"agent-base\");\n\nvar parse_proxy_response_1 = __importDefault(require(\"./parse-proxy-response\"));\n\nvar debug = debug_1.default('https-proxy-agent:agent');\n/**\n * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to\n * the specified \"HTTP(s) proxy server\" in order to proxy HTTPS requests.\n *\n * Outgoing HTTP requests are first tunneled through the proxy server using the\n * `CONNECT` HTTP request method to establish a connection to the proxy server,\n * and then the proxy server connects to the destination target and issues the\n * HTTP request from the proxy server.\n *\n * `https:` requests have their socket connection upgraded to TLS once\n * the connection to the proxy server has been established.\n *\n * @api public\n */\n\nvar HttpsProxyAgent = /*#__PURE__*/function (_agent_base_1$Agent) {\n  _inherits(HttpsProxyAgent, _agent_base_1$Agent);\n\n  function HttpsProxyAgent(_opts) {\n    var _this;\n\n    _classCallCheck(this, HttpsProxyAgent);\n\n    var opts;\n\n    if (typeof _opts === 'string') {\n      opts = url_1.default.parse(_opts);\n    } else {\n      opts = _opts;\n    }\n\n    if (!opts) {\n      throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!');\n    }\n\n    debug('creating new HttpsProxyAgent instance: %o', opts);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(HttpsProxyAgent).call(this, opts));\n    var proxy = Object.assign({}, opts); // If `true`, then connect to the proxy server over TLS.\n    // Defaults to `false`.\n\n    _this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol); // Prefer `hostname` over `host`, and set the `port` if needed.\n\n    proxy.host = proxy.hostname || proxy.host;\n\n    if (typeof proxy.port === 'string') {\n      proxy.port = parseInt(proxy.port, 10);\n    }\n\n    if (!proxy.port && proxy.host) {\n      proxy.port = _this.secureProxy ? 443 : 80;\n    } // ALPN is supported by Node.js >= v5.\n    // attempt to negotiate http/1.1 for proxy servers that support http/2\n\n\n    if (_this.secureProxy && !('ALPNProtocols' in proxy)) {\n      proxy.ALPNProtocols = ['http 1.1'];\n    }\n\n    if (proxy.host && proxy.path) {\n      // If both a `host` and `path` are specified then it's most likely\n      // the result of a `url.parse()` call... we need to remove the\n      // `path` portion so that `net.connect()` doesn't attempt to open\n      // that as a Unix socket file.\n      delete proxy.path;\n      delete proxy.pathname;\n    }\n\n    _this.proxy = proxy;\n    return _this;\n  }\n  /**\n   * Called when the node-core HTTP client library is creating a\n   * new HTTP request.\n   *\n   * @api protected\n   */\n\n\n  _createClass(HttpsProxyAgent, [{\n    key: \"callback\",\n    value: function callback(req, opts) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var proxy, secureProxy, socket, headers, hostname, payload, host, port, secureEndpoint, _i, _Object$keys, name, proxyResponsePromise, _yield$proxyResponseP, statusCode, buffered, servername, fakeSocket;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                proxy = this.proxy, secureProxy = this.secureProxy; // Create a socket connection to the proxy server.\n\n                if (secureProxy) {\n                  debug('Creating `tls.Socket`: %o', proxy);\n                  socket = tls_1.default.connect(proxy);\n                } else {\n                  debug('Creating `net.Socket`: %o', proxy);\n                  socket = net_1.default.connect(proxy);\n                }\n\n                headers = Object.assign({}, proxy.headers);\n                hostname = \"\".concat(opts.host, \":\").concat(opts.port);\n                payload = \"CONNECT \".concat(hostname, \" HTTP/1.1\\r\\n\"); // Inject the `Proxy-Authorization` header if necessary.\n\n                if (proxy.auth) {\n                  headers['Proxy-Authorization'] = \"Basic \".concat(Buffer.from(proxy.auth).toString('base64'));\n                } // The `Host` header should only include the port\n                // number when it is not the default port.\n\n\n                host = opts.host, port = opts.port, secureEndpoint = opts.secureEndpoint;\n\n                if (!isDefaultPort(port, secureEndpoint)) {\n                  host += \":\".concat(port);\n                }\n\n                headers.Host = host;\n                headers.Connection = 'close';\n\n                for (_i = 0, _Object$keys = Object.keys(headers); _i < _Object$keys.length; _i++) {\n                  name = _Object$keys[_i];\n                  payload += \"\".concat(name, \": \").concat(headers[name], \"\\r\\n\");\n                }\n\n                proxyResponsePromise = parse_proxy_response_1.default(socket);\n                socket.write(\"\".concat(payload, \"\\r\\n\"));\n                _context.next = 15;\n                return proxyResponsePromise;\n\n              case 15:\n                _yield$proxyResponseP = _context.sent;\n                statusCode = _yield$proxyResponseP.statusCode;\n                buffered = _yield$proxyResponseP.buffered;\n\n                if (!(statusCode === 200)) {\n                  _context.next = 27;\n                  break;\n                }\n\n                req.once('socket', resume);\n\n                if (!opts.secureEndpoint) {\n                  _context.next = 26;\n                  break;\n                }\n\n                servername = opts.servername || opts.host;\n\n                if (servername) {\n                  _context.next = 24;\n                  break;\n                }\n\n                throw new Error('Could not determine \"servername\"');\n\n              case 24:\n                // The proxy is connecting to a TLS server, so upgrade\n                // this socket connection to a TLS connection.\n                debug('Upgrading socket connection to TLS');\n                return _context.abrupt(\"return\", tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, 'host', 'hostname', 'path', 'port')), {\n                  socket: socket,\n                  servername: servername\n                })));\n\n              case 26:\n                return _context.abrupt(\"return\", socket);\n\n              case 27:\n                // Some other status code that's not 200... need to re-play the HTTP\n                // header \"data\" events onto the socket once the HTTP machinery is\n                // attached so that the node core `http` can parse and handle the\n                // error status code.\n                // Close the original socket, and a new \"fake\" socket is returned\n                // instead, so that the proxy doesn't get the HTTP request\n                // written to it (which may contain `Authorization` headers or other\n                // sensitive data).\n                //\n                // See: https://hackerone.com/reports/541502\n                socket.destroy();\n                fakeSocket = new net_1.default.Socket();\n                fakeSocket.readable = true; // Need to wait for the \"socket\" event to re-play the \"data\" events.\n\n                req.once('socket', function (s) {\n                  debug('replaying proxy buffer for failed request');\n                  assert_1.default(s.listenerCount('data') > 0); // Replay the \"buffered\" Buffer onto the fake `socket`, since at\n                  // this point the HTTP module machinery has been hooked up for\n                  // the user.\n\n                  s.push(buffered);\n                  s.push(null);\n                });\n                return _context.abrupt(\"return\", fakeSocket);\n\n              case 32:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }]);\n\n  return HttpsProxyAgent;\n}(agent_base_1.Agent);\n\nexports.default = HttpsProxyAgent;\n\nfunction resume(socket) {\n  socket.resume();\n}\n\nfunction isDefaultPort(port, secure) {\n  return Boolean(!secure && port === 80 || secure && port === 443);\n}\n\nfunction isHTTPS(protocol) {\n  return typeof protocol === 'string' ? /^https:?$/i.test(protocol) : false;\n}\n\nfunction omit(obj) {\n  var ret = {};\n  var key;\n\n  for (var _len = arguments.length, keys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    keys[_key - 1] = arguments[_key];\n  }\n\n  for (key in obj) {\n    if (!keys.includes(key)) {\n      ret[key] = obj[key];\n    }\n  }\n\n  return ret;\n}","map":null,"metadata":{},"sourceType":"script"}