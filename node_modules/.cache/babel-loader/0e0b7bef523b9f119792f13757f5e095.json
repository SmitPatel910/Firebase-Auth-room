{"ast":null,"code":"var _toConsumableArray = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\n/* global BigInt */\nvar _require = require('util'),\n    inherits = _require.inherits;\n\nvar Node = require('../base/node');\n\nvar der = require('../constants/der');\n\nfunction DEREncoder(entity) {\n  this.enc = 'der';\n  this.name = entity.name;\n  this.entity = entity; // Construct base tree\n\n  this.tree = new DERNode();\n\n  this.tree._init(entity.body);\n}\n\nDEREncoder.prototype.encode = function encode(data, reporter) {\n  return this.tree._encode(data, reporter).join();\n}; // Tree methods\n\n\nfunction DERNode(parent) {\n  Node.call(this, 'der', parent);\n}\n\ninherits(DERNode, Node);\n\nDERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {\n  var encodedTag = encodeTag(tag, primitive, cls, this.reporter); // Short form\n\n  if (content.length < 0x80) {\n    var _header = Buffer.alloc(2);\n\n    _header[0] = encodedTag;\n    _header[1] = content.length;\n    return this._createEncoderBuffer([_header, content]);\n  } // Long form\n  // Count octets required to store length\n\n\n  var lenOctets = 1;\n\n  for (var i = content.length; i >= 0x100; i >>= 8) {\n    lenOctets++;\n  }\n\n  var header = Buffer.alloc(1 + 1 + lenOctets);\n  header[0] = encodedTag;\n  header[1] = 0x80 | lenOctets;\n\n  for (var _i = 1 + lenOctets, j = content.length; j > 0; _i--, j >>= 8) {\n    header[_i] = j & 0xff;\n  }\n\n  return this._createEncoderBuffer([header, content]);\n};\n\nDERNode.prototype._encodeStr = function encodeStr(str, tag) {\n  if (tag === 'bitstr') {\n    return this._createEncoderBuffer([str.unused | 0, str.data]);\n  } else if (tag === 'bmpstr') {\n    var buf = Buffer.alloc(str.length * 2);\n\n    for (var i = 0; i < str.length; i++) {\n      buf.writeUInt16BE(str.charCodeAt(i), i * 2);\n    }\n\n    return this._createEncoderBuffer(buf);\n  } else if (tag === 'numstr') {\n    if (!this._isNumstr(str)) {\n      return this.reporter.error('Encoding of string type: numstr supports only digits and space');\n    }\n\n    return this._createEncoderBuffer(str);\n  } else if (tag === 'printstr') {\n    if (!this._isPrintstr(str)) {\n      return this.reporter.error('Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark');\n    }\n\n    return this._createEncoderBuffer(str);\n  } else if (/str$/.test(tag)) {\n    return this._createEncoderBuffer(str);\n  } else if (tag === 'objDesc') {\n    return this._createEncoderBuffer(str);\n  } else {\n    return this.reporter.error(\"Encoding of string type: \".concat(tag, \" unsupported\"));\n  }\n};\n\nDERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {\n  if (typeof id === 'string') {\n    if (!values) {\n      return this.reporter.error('string objid given, but no values map found');\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(values, id)) {\n      return this.reporter.error('objid not found in values map');\n    }\n\n    id = values[id].split(/[\\s.]+/g);\n\n    for (var i = 0; i < id.length; i++) {\n      id[i] |= 0;\n    }\n  } else if (Array.isArray(id)) {\n    id = id.slice();\n\n    for (var _i2 = 0; _i2 < id.length; _i2++) {\n      id[_i2] |= 0;\n    }\n  }\n\n  if (!Array.isArray(id)) {\n    return this.reporter.error(\"objid() should be either array or string, got: \".concat(JSON.stringify(id)));\n  }\n\n  if (!relative) {\n    if (id[1] >= 40) {\n      return this.reporter.error('Second objid identifier OOB');\n    }\n\n    id.splice(0, 2, id[0] * 40 + id[1]);\n  } // Count number of octets\n\n\n  var size = 0;\n\n  for (var _i3 = 0; _i3 < id.length; _i3++) {\n    var ident = id[_i3];\n\n    for (size++; ident >= 0x80; ident >>= 7) {\n      size++;\n    }\n  }\n\n  var objid = Buffer.alloc(size);\n  var offset = objid.length - 1;\n\n  for (var _i4 = id.length - 1; _i4 >= 0; _i4--) {\n    var _ident = id[_i4];\n    objid[offset--] = _ident & 0x7f;\n\n    while ((_ident >>= 7) > 0) {\n      objid[offset--] = 0x80 | _ident & 0x7f;\n    }\n  }\n\n  return this._createEncoderBuffer(objid);\n};\n\nfunction two(num) {\n  if (num < 10) {\n    return \"0\".concat(num);\n  } else {\n    return num;\n  }\n}\n\nDERNode.prototype._encodeTime = function encodeTime(time, tag) {\n  var str;\n  var date = new Date(time);\n\n  if (tag === 'gentime') {\n    str = [two(date.getUTCFullYear()), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), 'Z'].join('');\n  } else if (tag === 'utctime') {\n    str = [two(date.getUTCFullYear() % 100), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), 'Z'].join('');\n  } else {\n    this.reporter.error(\"Encoding \".concat(tag, \" time is not supported yet\"));\n  }\n\n  return this._encodeStr(str, 'octstr');\n};\n\nDERNode.prototype._encodeNull = function encodeNull() {\n  return this._createEncoderBuffer('');\n};\n\nfunction bnToBuf(bn) {\n  var hex = BigInt(bn).toString(16);\n\n  if (hex.length % 2) {\n    hex = '0' + hex;\n  }\n\n  var len = hex.length / 2;\n  var u8 = new Uint8Array(len);\n  var i = 0;\n  var j = 0;\n\n  while (i < len) {\n    u8[i] = parseInt(hex.slice(j, j + 2), 16);\n    i += 1;\n    j += 2;\n  }\n\n  return u8;\n}\n\nDERNode.prototype._encodeInt = function encodeInt(num, values) {\n  if (typeof num === 'string') {\n    if (!values) {\n      return this.reporter.error('String int or enum given, but no values map');\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(values, num)) {\n      return this.reporter.error(\"Values map doesn't contain: \".concat(JSON.stringify(num)));\n    }\n\n    num = values[num];\n  }\n\n  if (typeof num === 'bigint') {\n    var numArray = _toConsumableArray(bnToBuf(num));\n\n    if (numArray[0] & 0x80) {\n      numArray.unshift(0);\n    }\n\n    num = Buffer.from(numArray);\n  }\n\n  if (Buffer.isBuffer(num)) {\n    var _size = num.length;\n\n    if (num.length === 0) {\n      _size++;\n    }\n\n    var _out = Buffer.alloc(_size);\n\n    num.copy(_out);\n\n    if (num.length === 0) {\n      _out[0] = 0;\n    }\n\n    return this._createEncoderBuffer(_out);\n  }\n\n  if (num < 0x80) {\n    return this._createEncoderBuffer(num);\n  }\n\n  if (num < 0x100) {\n    return this._createEncoderBuffer([0, num]);\n  }\n\n  var size = 1;\n\n  for (var i = num; i >= 0x100; i >>= 8) {\n    size++;\n  }\n\n  var out = new Array(size);\n\n  for (var _i5 = out.length - 1; _i5 >= 0; _i5--) {\n    out[_i5] = num & 0xff;\n    num >>= 8;\n  }\n\n  if (out[0] & 0x80) {\n    out.unshift(0);\n  }\n\n  return this._createEncoderBuffer(Buffer.from(out));\n};\n\nDERNode.prototype._encodeBool = function encodeBool(value) {\n  return this._createEncoderBuffer(value ? 0xff : 0);\n};\n\nDERNode.prototype._use = function use(entity, obj) {\n  if (typeof entity === 'function') {\n    entity = entity(obj);\n  }\n\n  return entity._getEncoder('der').tree;\n};\n\nDERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {\n  var state = this._baseState;\n  var i;\n\n  if (state.default === null) {\n    return false;\n  }\n\n  var data = dataBuffer.join();\n\n  if (state.defaultBuffer === undefined) {\n    state.defaultBuffer = this._encodeValue(state.default, reporter, parent).join();\n  }\n\n  if (data.length !== state.defaultBuffer.length) {\n    return false;\n  }\n\n  for (i = 0; i < data.length; i++) {\n    if (data[i] !== state.defaultBuffer[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}; // Utility methods\n\n\nfunction encodeTag(tag, primitive, cls, reporter) {\n  var res;\n\n  if (tag === 'seqof') {\n    tag = 'seq';\n  } else if (tag === 'setof') {\n    tag = 'set';\n  }\n\n  if (Object.prototype.hasOwnProperty.call(der.tagByName, tag)) {\n    res = der.tagByName[tag];\n  } else if (typeof tag === 'number' && (tag | 0) === tag) {\n    res = tag;\n  } else {\n    return reporter.error(\"Unknown tag: \".concat(tag));\n  }\n\n  if (res >= 0x1f) {\n    return reporter.error('Multi-octet tag encoding unsupported');\n  }\n\n  if (!primitive) {\n    res |= 0x20;\n  }\n\n  res |= der.tagClassByName[cls || 'universal'] << 6;\n  return res;\n}\n\nmodule.exports = DEREncoder;","map":null,"metadata":{},"sourceType":"script"}