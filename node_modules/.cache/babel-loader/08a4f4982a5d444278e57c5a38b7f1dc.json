{"ast":null,"code":"var EventEmitter = require('events').EventEmitter,\n    inherits = require('util').inherits;\n\nvar StreamSearch = require('streamsearch');\n\nvar B_DCRLF = Buffer.from('\\r\\n\\r\\n'),\n    RE_CRLF = /\\r\\n/g,\n    RE_HDR = /^([^:]+):[ \\t]?([\\x00-\\xFF]+)?$/,\n    MAX_HEADER_PAIRS = 2000,\n    // from node's http.js\nMAX_HEADER_SIZE = 80 * 1024; // from node's http_parser\n\nfunction HeaderParser(cfg) {\n  EventEmitter.call(this);\n  var self = this;\n  this.nread = 0;\n  this.maxed = false;\n  this.npairs = 0;\n  this.maxHeaderPairs = cfg && typeof cfg.maxHeaderPairs === 'number' ? cfg.maxHeaderPairs : MAX_HEADER_PAIRS;\n  this.buffer = '';\n  this.header = {};\n  this.finished = false;\n  this.ss = new StreamSearch(B_DCRLF);\n  this.ss.on('info', function (isMatch, data, start, end) {\n    if (data && !self.maxed) {\n      if (self.nread + (end - start) > MAX_HEADER_SIZE) {\n        end = MAX_HEADER_SIZE - self.nread;\n        self.nread = MAX_HEADER_SIZE;\n      } else self.nread += end - start;\n\n      if (self.nread === MAX_HEADER_SIZE) self.maxed = true;\n      self.buffer += data.toString('binary', start, end);\n    }\n\n    if (isMatch) self._finish();\n  });\n}\n\ninherits(HeaderParser, EventEmitter);\n\nHeaderParser.prototype.push = function (data) {\n  var r = this.ss.push(data);\n  if (this.finished) return r;\n};\n\nHeaderParser.prototype.reset = function () {\n  this.finished = false;\n  this.buffer = '';\n  this.header = {};\n  this.ss.reset();\n};\n\nHeaderParser.prototype._finish = function () {\n  if (this.buffer) this._parseHeader();\n  this.ss.matches = this.ss.maxMatches;\n  var header = this.header;\n  this.header = {};\n  this.buffer = '';\n  this.finished = true;\n  this.nread = this.npairs = 0;\n  this.maxed = false;\n  this.emit('header', header);\n};\n\nHeaderParser.prototype._parseHeader = function () {\n  if (this.npairs === this.maxHeaderPairs) return;\n  var lines = this.buffer.split(RE_CRLF),\n      len = lines.length,\n      m,\n      h,\n      modded = false;\n\n  for (var i = 0; i < len; ++i) {\n    if (lines[i].length === 0) continue;\n\n    if (lines[i][0] === '\\t' || lines[i][0] === ' ') {\n      // folded header content\n      // RFC2822 says to just remove the CRLF and not the whitespace following\n      // it, so we follow the RFC and include the leading whitespace ...\n      this.header[h][this.header[h].length - 1] += lines[i];\n    } else {\n      m = RE_HDR.exec(lines[i]);\n\n      if (m) {\n        h = m[1].toLowerCase();\n\n        if (m[2]) {\n          if (this.header[h] === undefined) this.header[h] = [m[2]];else this.header[h].push(m[2]);\n        } else this.header[h] = [''];\n\n        if (++this.npairs === this.maxHeaderPairs) break;\n      } else {\n        this.buffer = lines[i];\n        modded = true;\n        break;\n      }\n    }\n  }\n\n  if (!modded) this.buffer = '';\n};\n\nmodule.exports = HeaderParser;","map":null,"metadata":{},"sourceType":"script"}