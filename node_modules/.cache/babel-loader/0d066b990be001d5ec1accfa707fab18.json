{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar reference_1 = require(\"./reference\");\n\nvar path_1 = require(\"./path\");\n\nvar serializer_1 = require(\"./serializer\");\n/**\n * A split point that can be used in a query as a starting and/or end point for\n * the query results. The cursors returned by {@link #startAt} and {@link\n * #endBefore} can only be used in a query that matches the constraint of query\n * that produced this partition.\n *\n * @class QueryPartition\n */\n\n\nvar QueryPartition = /*#__PURE__*/function () {\n  /** @hideconstructor */\n  function QueryPartition(_firestore, _collectionId, _converter, _startAt, _endBefore) {\n    _classCallCheck(this, QueryPartition);\n\n    this._firestore = _firestore;\n    this._collectionId = _collectionId;\n    this._converter = _converter;\n    this._startAt = _startAt;\n    this._endBefore = _endBefore;\n    this._serializer = new serializer_1.Serializer(_firestore);\n  }\n  /**\n   * The cursor that defines the first result for this partition or `undefined`\n   * if this is the first partition. The cursor value must be\n   * destructured when passed to `startAt()` (for example with\n   * `query.startAt(...queryPartition.startAt)`).\n   *\n   * @example\n   * const query = firestore.collectionGroup('collectionId');\n   * for await (const partition of query.getPartitions(42)) {\n   *   let partitionedQuery = query.orderBy(FieldPath.documentId());\n   *   if (partition.startAt) {\n   *     partitionedQuery = partitionedQuery.startAt(...partition.startAt);\n   *   }\n   *   if (partition.endBefore) {\n   *     partitionedQuery = partitionedQuery.endBefore(...partition.endBefore);\n   *   }\n   *   const querySnapshot = await partitionedQuery.get();\n   *   console.log(`Partition contained ${querySnapshot.length} documents`);\n   * }\n   *\n   * @type {Array<*>}\n   * @return {Array<*>} A cursor value that can be used with {@link\n   * Query#startAt} or `undefined` if this is the first partition.\n   */\n\n\n  _createClass(QueryPartition, [{\n    key: \"toQuery\",\n\n    /**\n     * Returns a query that only encapsulates the documents for this partition.\n     *\n     * @example\n     * const query = firestore.collectionGroup('collectionId');\n     * for await (const partition of query.getPartitions(42)) {\n     *   const partitionedQuery = partition.toQuery();\n     *   const querySnapshot = await partitionedQuery.get();\n     *   console.log(`Partition contained ${querySnapshot.length} documents`);\n     * }\n     *\n     * @return {Query<T>} A query partitioned by a {@link Query#startAt} and\n     * {@link Query#endBefore} cursor.\n     */\n    value: function toQuery() {\n      // Since the api.Value to JavaScript type conversion can be lossy (unless\n      // `useBigInt` is used), we pass the original protobuf representation to the\n      // created query.\n      var queryOptions = reference_1.QueryOptions.forCollectionGroupQuery(this._collectionId, this._converter);\n      queryOptions = queryOptions.with({\n        fieldOrders: [new reference_1.FieldOrder(path_1.FieldPath.documentId())]\n      });\n\n      if (this._startAt !== undefined) {\n        queryOptions = queryOptions.with({\n          startAt: {\n            before: true,\n            values: this._startAt\n          }\n        });\n      }\n\n      if (this._endBefore !== undefined) {\n        queryOptions = queryOptions.with({\n          endAt: {\n            before: true,\n            values: this._endBefore\n          }\n        });\n      }\n\n      return new reference_1.Query(this._firestore, queryOptions);\n    }\n  }, {\n    key: \"startAt\",\n    get: function get() {\n      var _this = this;\n\n      if (this._startAt && !this._memoizedStartAt) {\n        this._memoizedStartAt = this._startAt.map(function (v) {\n          return _this._serializer.decodeValue(v);\n        });\n      }\n\n      return this._memoizedStartAt;\n    }\n    /**\n     * The cursor that defines the first result after this partition or\n     * `undefined` if this is the last partition.  The cursor value must be\n     * destructured when passed to `endBefore()` (for example with\n     * `query.endBefore(...queryPartition.endBefore)`).\n     *\n     * @example\n     * const query = firestore.collectionGroup('collectionId');\n     * for await (const partition of query.getPartitions(42)) {\n     *   let partitionedQuery = query.orderBy(FieldPath.documentId());\n     *   if (partition.startAt) {\n     *     partitionedQuery = partitionedQuery.startAt(...partition.startAt);\n     *   }\n     *   if (partition.endBefore) {\n     *     partitionedQuery = partitionedQuery.endBefore(...partition.endBefore);\n     *   }\n     *   const querySnapshot = await partitionedQuery.get();\n     *   console.log(`Partition contained ${querySnapshot.length} documents`);\n     * }\n     *\n     * @type {Array<*>}\n     * @return {Array<*>} A cursor value that can be used with {@link\n     * Query#endBefore} or `undefined` if this is the last partition.\n     */\n\n  }, {\n    key: \"endBefore\",\n    get: function get() {\n      var _this2 = this;\n\n      if (this._endBefore && !this._memoizedEndBefore) {\n        this._memoizedEndBefore = this._endBefore.map(function (v) {\n          return _this2._serializer.decodeValue(v);\n        });\n      }\n\n      return this._memoizedEndBefore;\n    }\n  }]);\n\n  return QueryPartition;\n}();\n\nexports.QueryPartition = QueryPartition;","map":null,"metadata":{},"sourceType":"script"}