{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _objectSpread = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread\");\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\Smit\\\\OneDrive\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generateServiceStub = void 0;\n/* global window */\n\n/* global AbortController */\n\nvar node_fetch_1 = require(\"node-fetch\");\n\nvar abort_controller_1 = require(\"abort-controller\");\n\nvar featureDetection_1 = require(\"./featureDetection\");\n\nfunction generateServiceStub(rpcs, protocol, servicePath, servicePort, authClient, requestEncoder, responseDecoder) {\n  var fetch = featureDetection_1.hasWindowFetch() ? window.fetch : node_fetch_1.default;\n  var serviceStub = {};\n\n  var _loop = function _loop() {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n        rpcName = _Object$entries$_i[0],\n        rpc = _Object$entries$_i[1];\n\n    serviceStub[rpcName] = function (request, options, _metadata, callback) {\n      // We cannot use async-await in this function because we need to return the canceller object as soon as possible.\n      // Using plain old promises instead.\n      var cancelController = featureDetection_1.hasAbortController() ? new AbortController() : new abort_controller_1.AbortController();\n      var cancelSignal = cancelController.signal;\n      var cancelRequested = false;\n      var fetchParameters = requestEncoder(rpc, protocol, servicePath, servicePort, request);\n      var url = fetchParameters.url;\n      var headers = fetchParameters.headers;\n\n      for (var _i2 = 0, _Object$keys = Object.keys(options); _i2 < _Object$keys.length; _i2++) {\n        var key = _Object$keys[_i2];\n        headers[key] = options[key][0];\n      }\n\n      authClient.getRequestHeaders().then(function (authHeader) {\n        var fetchRequest = {\n          headers: _objectSpread({}, authHeader, headers),\n          body: fetchParameters.body,\n          method: fetchParameters.method,\n          signal: cancelSignal\n        };\n\n        if (fetchParameters.method === 'get' || fetchParameters.method === 'delete') {\n          delete fetchRequest['body'];\n        }\n\n        return fetch(url, fetchRequest);\n      }).then(function (response) {\n        return Promise.all([Promise.resolve(response.ok), response.arrayBuffer()]);\n      }).then(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            ok = _ref2[0],\n            buffer = _ref2[1];\n\n        var response = responseDecoder(rpc, ok, buffer);\n        callback(null, response);\n      }).catch(function (err) {\n        if (!cancelRequested || err.name !== 'AbortError') {\n          callback(err);\n        }\n      });\n      return {\n        cancel: function cancel() {\n          cancelRequested = true;\n          cancelController.abort();\n        }\n      };\n    };\n  };\n\n  for (var _i = 0, _Object$entries = Object.entries(rpcs); _i < _Object$entries.length; _i++) {\n    _loop();\n  }\n\n  return serviceStub;\n}\n\nexports.generateServiceStub = generateServiceStub;","map":null,"metadata":{},"sourceType":"script"}