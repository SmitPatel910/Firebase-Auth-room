{"ast":null,"code":"/*! firebase-admin v9.11.0 */\n\"use strict\";\n/*!\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SecurityRules = exports.Ruleset = void 0;\n\nvar validator = require(\"../utils/validator\");\n\nvar security_rules_api_client_internal_1 = require(\"./security-rules-api-client-internal\");\n\nvar security_rules_internal_1 = require(\"./security-rules-internal\");\n\nvar RulesetMetadataListImpl =\n/** @class */\nfunction () {\n  function RulesetMetadataListImpl(response) {\n    if (!validator.isNonNullObject(response) || !validator.isArray(response.rulesets)) {\n      throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', \"Invalid ListRulesets response: \" + JSON.stringify(response));\n    }\n\n    this.rulesets = response.rulesets.map(function (rs) {\n      return {\n        name: stripProjectIdPrefix(rs.name),\n        createTime: new Date(rs.createTime).toUTCString()\n      };\n    });\n\n    if (response.nextPageToken) {\n      this.nextPageToken = response.nextPageToken;\n    }\n  }\n\n  return RulesetMetadataListImpl;\n}();\n/**\n * Represents a set of Firebase security rules.\n */\n\n\nvar Ruleset =\n/** @class */\nfunction () {\n  function Ruleset(ruleset) {\n    if (!validator.isNonNullObject(ruleset) || !validator.isNonEmptyString(ruleset.name) || !validator.isNonEmptyString(ruleset.createTime) || !validator.isNonNullObject(ruleset.source)) {\n      throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', \"Invalid Ruleset response: \" + JSON.stringify(ruleset));\n    }\n\n    this.name = stripProjectIdPrefix(ruleset.name);\n    this.createTime = new Date(ruleset.createTime).toUTCString();\n    this.source = ruleset.source.files || [];\n  }\n\n  return Ruleset;\n}();\n\nexports.Ruleset = Ruleset;\n/**\n * The Firebase `SecurityRules` service interface.\n *\n * Do not call this constructor directly. Instead, use\n * [`admin.securityRules()`](securityRules#securityRules).\n */\n\nvar SecurityRules =\n/** @class */\nfunction () {\n  /**\n   * @param {object} app The app for this SecurityRules service.\n   * @constructor\n   */\n  function SecurityRules(app) {\n    this.app = app;\n    this.client = new security_rules_api_client_internal_1.SecurityRulesApiClient(app);\n  }\n  /**\n   * Gets the Ruleset identified by the given name. The input name should be the short name string without\n   * the project ID prefix. For example, to retrieve the `projects/project-id/rulesets/my-ruleset`, pass the\n   * short name \"my-ruleset\". Rejects with a `not-found` error if the specified Ruleset cannot be found.\n   *\n   * @param {string} name Name of the Ruleset to retrieve.\n   * @returns {Promise<Ruleset>} A promise that fulfills with the specified Ruleset.\n   */\n\n\n  SecurityRules.prototype.getRuleset = function (name) {\n    return this.client.getRuleset(name).then(function (rulesetResponse) {\n      return new Ruleset(rulesetResponse);\n    });\n  };\n  /**\n   * Gets the Ruleset currently applied to Cloud Firestore. Rejects with a `not-found` error if no Ruleset is\n   * applied on Firestore.\n   *\n   * @returns {Promise<Ruleset>} A promise that fulfills with the Firestore Ruleset.\n   */\n\n\n  SecurityRules.prototype.getFirestoreRuleset = function () {\n    return this.getRulesetForRelease(SecurityRules.CLOUD_FIRESTORE);\n  };\n  /**\n   * Creates a new ruleset from the given source, and applies it to Cloud Firestore.\n   *\n   * @param {string|Buffer} source Rules source to apply.\n   * @returns {Promise<Ruleset>} A promise that fulfills when the ruleset is created and released.\n   */\n\n\n  SecurityRules.prototype.releaseFirestoreRulesetFromSource = function (source) {\n    var _this = this;\n\n    return Promise.resolve().then(function () {\n      var rulesFile = _this.createRulesFileFromSource('firestore.rules', source);\n\n      return _this.createRuleset(rulesFile);\n    }).then(function (ruleset) {\n      return _this.releaseFirestoreRuleset(ruleset).then(function () {\n        return ruleset;\n      });\n    });\n  };\n  /**\n   * Makes the specified ruleset the currently applied ruleset for Cloud Firestore.\n   *\n   * @param {string|RulesetMetadata} ruleset Name of the ruleset to apply or a RulesetMetadata object containing\n   *   the name.\n   * @returns {Promise<void>} A promise that fulfills when the ruleset is released.\n   */\n\n\n  SecurityRules.prototype.releaseFirestoreRuleset = function (ruleset) {\n    return this.releaseRuleset(ruleset, SecurityRules.CLOUD_FIRESTORE);\n  };\n  /**\n   * Gets the Ruleset currently applied to a Cloud Storage bucket. Rejects with a `not-found` error if no Ruleset is\n   * applied on the bucket.\n   *\n   * @param {string=} bucket Optional name of the Cloud Storage bucket to be retrieved. If not specified,\n   *   retrieves the ruleset applied on the default bucket configured via `AppOptions`.\n   * @returns {Promise<Ruleset>} A promise that fulfills with the Cloud Storage Ruleset.\n   */\n\n\n  SecurityRules.prototype.getStorageRuleset = function (bucket) {\n    var _this = this;\n\n    return Promise.resolve().then(function () {\n      return _this.getBucketName(bucket);\n    }).then(function (bucketName) {\n      return _this.getRulesetForRelease(SecurityRules.FIREBASE_STORAGE + \"/\" + bucketName);\n    });\n  };\n  /**\n   * Creates a new ruleset from the given source, and applies it to a Cloud Storage bucket.\n   *\n   * @param {string|Buffer} source Rules source to apply.\n   * @param {string=} bucket Optional name of the Cloud Storage bucket to apply the rules on. If not specified,\n   *   applies the ruleset on the default bucket configured via `AppOptions`.\n   * @returns {Promise<Ruleset>} A promise that fulfills when the ruleset is created and released.\n   */\n\n\n  SecurityRules.prototype.releaseStorageRulesetFromSource = function (source, bucket) {\n    var _this = this;\n\n    return Promise.resolve().then(function () {\n      // Bucket name is not required until the last step. But since there's a createRuleset step\n      // before then, make sure to run this check and fail early if the bucket name is invalid.\n      _this.getBucketName(bucket);\n\n      var rulesFile = _this.createRulesFileFromSource('storage.rules', source);\n\n      return _this.createRuleset(rulesFile);\n    }).then(function (ruleset) {\n      return _this.releaseStorageRuleset(ruleset, bucket).then(function () {\n        return ruleset;\n      });\n    });\n  };\n  /**\n   * Makes the specified ruleset the currently applied ruleset for a Cloud Storage bucket.\n   *\n   * @param {string|RulesetMetadata} ruleset Name of the ruleset to apply or a RulesetMetadata object containing\n   *   the name.\n   * @param {string=} bucket Optional name of the Cloud Storage bucket to apply the rules on. If not specified,\n   *   applies the ruleset on the default bucket configured via `AppOptions`.\n   * @returns {Promise<void>} A promise that fulfills when the ruleset is released.\n   */\n\n\n  SecurityRules.prototype.releaseStorageRuleset = function (ruleset, bucket) {\n    var _this = this;\n\n    return Promise.resolve().then(function () {\n      return _this.getBucketName(bucket);\n    }).then(function (bucketName) {\n      return _this.releaseRuleset(ruleset, SecurityRules.FIREBASE_STORAGE + \"/\" + bucketName);\n    });\n  };\n  /**\n   * Creates a {@link securityRules.RulesFile `RuleFile`} with the given name\n   * and source. Throws an error if any of the arguments are invalid. This is a local\n   * operation, and does not involve any network API calls.\n   *\n   * @example\n   * ```javascript\n   * const source = '// Some rules source';\n   * const rulesFile = admin.securityRules().createRulesFileFromSource(\n   *   'firestore.rules', source);\n   * ```\n   *\n   * @param name Name to assign to the rules file. This is usually a short file name that\n   *   helps identify the file in a ruleset.\n   * @param source Contents of the rules file.\n   * @return A new rules file instance.\n   */\n\n\n  SecurityRules.prototype.createRulesFileFromSource = function (name, source) {\n    if (!validator.isNonEmptyString(name)) {\n      throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Name must be a non-empty string.');\n    }\n\n    var content;\n\n    if (validator.isNonEmptyString(source)) {\n      content = source;\n    } else if (validator.isBuffer(source)) {\n      content = source.toString('utf-8');\n    } else {\n      throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Source must be a non-empty string or a Buffer.');\n    }\n\n    return {\n      name: name,\n      content: content\n    };\n  };\n  /**\n   * Creates a new {@link securityRules.Ruleset `Ruleset`} from the given\n   * {@link securityRules.RulesFile `RuleFile`}.\n   *\n   * @param file Rules file to include in the new `Ruleset`.\n   * @returns A promise that fulfills with the newly created `Ruleset`.\n   */\n\n\n  SecurityRules.prototype.createRuleset = function (file) {\n    var ruleset = {\n      source: {\n        files: [file]\n      }\n    };\n    return this.client.createRuleset(ruleset).then(function (rulesetResponse) {\n      return new Ruleset(rulesetResponse);\n    });\n  };\n  /**\n   * Deletes the {@link securityRules.Ruleset `Ruleset`} identified by the given\n   * name. The input name should be the short name string without the project ID\n   * prefix. For example, to delete the `projects/project-id/rulesets/my-ruleset`,\n   * pass the  short name \"my-ruleset\". Rejects with a `not-found` error if the\n   * specified `Ruleset` cannot be found.\n   *\n   * @param name Name of the `Ruleset` to delete.\n   * @return A promise that fulfills when the `Ruleset` is deleted.\n   */\n\n\n  SecurityRules.prototype.deleteRuleset = function (name) {\n    return this.client.deleteRuleset(name);\n  };\n  /**\n   * Retrieves a page of ruleset metadata.\n   *\n   * @param pageSize The page size, 100 if undefined. This is also the maximum allowed\n   *   limit.\n   * @param nextPageToken The next page token. If not specified, returns rulesets\n   *   starting without any offset.\n   * @return A promise that fulfills with a page of rulesets.\n   */\n\n\n  SecurityRules.prototype.listRulesetMetadata = function (pageSize, nextPageToken) {\n    if (pageSize === void 0) {\n      pageSize = 100;\n    }\n\n    return this.client.listRulesets(pageSize, nextPageToken).then(function (response) {\n      return new RulesetMetadataListImpl(response);\n    });\n  };\n\n  SecurityRules.prototype.getRulesetForRelease = function (releaseName) {\n    var _this = this;\n\n    return this.client.getRelease(releaseName).then(function (release) {\n      var rulesetName = release.rulesetName;\n\n      if (!validator.isNonEmptyString(rulesetName)) {\n        throw new security_rules_internal_1.FirebaseSecurityRulesError('not-found', \"Ruleset name not found for \" + releaseName + \".\");\n      }\n\n      return _this.getRuleset(stripProjectIdPrefix(rulesetName));\n    });\n  };\n\n  SecurityRules.prototype.releaseRuleset = function (ruleset, releaseName) {\n    if (!validator.isNonEmptyString(ruleset) && (!validator.isNonNullObject(ruleset) || !validator.isNonEmptyString(ruleset.name))) {\n      var err = new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'ruleset must be a non-empty name or a RulesetMetadata object.');\n      return Promise.reject(err);\n    }\n\n    var rulesetName = validator.isString(ruleset) ? ruleset : ruleset.name;\n    return this.client.updateRelease(releaseName, rulesetName).then(function () {\n      return;\n    });\n  };\n\n  SecurityRules.prototype.getBucketName = function (bucket) {\n    var bucketName = typeof bucket !== 'undefined' ? bucket : this.app.options.storageBucket;\n\n    if (!validator.isNonEmptyString(bucketName)) {\n      throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Bucket name not specified or invalid. Specify a default bucket name via the ' + 'storageBucket option when initializing the app, or specify the bucket name ' + 'explicitly when calling the rules API.');\n    }\n\n    return bucketName;\n  };\n\n  SecurityRules.CLOUD_FIRESTORE = 'cloud.firestore';\n  SecurityRules.FIREBASE_STORAGE = 'firebase.storage';\n  return SecurityRules;\n}();\n\nexports.SecurityRules = SecurityRules;\n\nfunction stripProjectIdPrefix(name) {\n  return name.split('/').pop();\n}","map":null,"metadata":{},"sourceType":"script"}