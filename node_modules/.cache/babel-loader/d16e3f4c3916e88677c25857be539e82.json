{"ast":null,"code":"\"use strict\";\n\nmodule.exports = encoder;\n\nvar Enum = require(\"./enum\"),\n    types = require(\"./types\"),\n    util = require(\"./util\");\n/**\n * Generates a partial message type encoder.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\n\n\nfunction genTypePartial(gen, field, fieldIndex, ref) {\n  return field.resolvedType.group ? gen(\"types[%i].encode(%s,w.uint32(%i)).uint32(%i)\", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0) : gen(\"types[%i].encode(%s,w.uint32(%i).fork()).ldelim()\", fieldIndex, ref, (field.id << 3 | 2) >>> 0);\n}\n/**\n * Generates an encoder specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\n\n\nfunction encoder(mtype) {\n  /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n  var gen = util.codegen([\"m\", \"w\"], mtype.name + \"$encode\")(\"if(!w)\")(\"w=Writer.create()\");\n  var i, ref; // \"when a message is serialized its known fields should be written sequentially by field number\"\n\n  var fields =\n  /* initializes */\n  mtype.fieldsArray.slice().sort(util.compareFieldsById);\n\n  for (var i = 0; i < fields.length; ++i) {\n    var field = fields[i].resolve(),\n        index = mtype._fieldsArray.indexOf(field),\n        type = field.resolvedType instanceof Enum ? \"int32\" : field.type,\n        wireType = types.basic[type];\n\n    ref = \"m\" + util.safeProp(field.name); // Map fields\n\n    if (field.map) {\n      gen(\"if(%s!=null&&Object.hasOwnProperty.call(m,%j)){\", ref, field.name) // !== undefined && !== null\n      (\"for(var ks=Object.keys(%s),i=0;i<ks.length;++i){\", ref)(\"w.uint32(%i).fork().uint32(%i).%s(ks[i])\", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);\n      if (wireType === undefined) gen(\"types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()\", index, ref); // can't be groups\n      else gen(\".uint32(%i).%s(%s[ks[i]]).ldelim()\", 16 | wireType, type, ref);\n      gen(\"}\")(\"}\"); // Repeated fields\n    } else if (field.repeated) {\n      gen(\"if(%s!=null&&%s.length){\", ref, ref); // !== undefined && !== null\n      // Packed repeated\n\n      if (field.packed && types.packed[type] !== undefined) {\n        gen(\"w.uint32(%i).fork()\", (field.id << 3 | 2) >>> 0)(\"for(var i=0;i<%s.length;++i)\", ref)(\"w.%s(%s[i])\", type, ref)(\"w.ldelim()\"); // Non-packed\n      } else {\n        gen(\"for(var i=0;i<%s.length;++i)\", ref);\n        if (wireType === undefined) genTypePartial(gen, field, index, ref + \"[i]\");else gen(\"w.uint32(%i).%s(%s[i])\", (field.id << 3 | wireType) >>> 0, type, ref);\n      }\n\n      gen(\"}\"); // Non-repeated\n    } else {\n      if (field.optional) gen(\"if(%s!=null&&Object.hasOwnProperty.call(m,%j))\", ref, field.name); // !== undefined && !== null\n\n      if (wireType === undefined) genTypePartial(gen, field, index, ref);else gen(\"w.uint32(%i).%s(%s)\", (field.id << 3 | wireType) >>> 0, type, ref);\n    }\n  }\n\n  return gen(\"return w\");\n  /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n}","map":null,"metadata":{},"sourceType":"script"}