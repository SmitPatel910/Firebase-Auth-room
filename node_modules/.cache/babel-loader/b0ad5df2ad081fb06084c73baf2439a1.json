{"ast":null,"code":"var _objectSpread = require(\"C:\\\\Users\\\\Smit\\\\Desktop\\\\RTC-React\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread\");\n\nvar _require = require('os'),\n    EOL = _require.EOL;\n\nvar errors = require('../errors');\n\nvar _require2 = require('./runtime_support'),\n    keyObjectSupported = _require2.keyObjectSupported;\n\nvar _require3 = require('./key_object'),\n    createPublicKey = _require3.createPublicKey;\n\nvar base64url = require('./base64url');\n\nvar asn1 = require('./asn1');\n\nvar computePrimes = require('./rsa_primes');\n\nvar _require4 = require('../registry'),\n    OKP_CURVES = _require4.OKP_CURVES,\n    EC_CURVES = _require4.EC_CURVES;\n\nvar formatPem = function formatPem(base64pem, descriptor) {\n  return \"-----BEGIN \".concat(descriptor, \" KEY-----\").concat(EOL).concat((base64pem.match(/.{1,64}/g) || []).join(EOL)).concat(EOL, \"-----END \").concat(descriptor, \" KEY-----\");\n};\n\nvar okpToJWK = {\n  private: function _private(crv, keyObject) {\n    var der = keyObject.export({\n      type: 'pkcs8',\n      format: 'der'\n    });\n    var OneAsymmetricKey = asn1.get('OneAsymmetricKey');\n\n    var _OneAsymmetricKey$dec = OneAsymmetricKey.decode(der),\n        d = _OneAsymmetricKey$dec.privateKey.privateKey;\n\n    return _objectSpread({}, okpToJWK.public(crv, createPublicKey(keyObject)), {\n      d: base64url.encodeBuffer(d)\n    });\n  },\n  public: function _public(crv, keyObject) {\n    var der = keyObject.export({\n      type: 'spki',\n      format: 'der'\n    });\n    var PublicKeyInfo = asn1.get('PublicKeyInfo');\n\n    var _PublicKeyInfo$decode = PublicKeyInfo.decode(der),\n        x = _PublicKeyInfo$decode.publicKey.data;\n\n    return {\n      kty: 'OKP',\n      crv: crv,\n      x: base64url.encodeBuffer(x)\n    };\n  }\n};\nvar keyObjectToJWK = {\n  rsa: {\n    private: function _private(keyObject) {\n      var der = keyObject.export({\n        type: 'pkcs8',\n        format: 'der'\n      });\n      var PrivateKeyInfo = asn1.get('PrivateKeyInfo');\n      var RSAPrivateKey = asn1.get('RSAPrivateKey');\n\n      var _PrivateKeyInfo$decod = PrivateKeyInfo.decode(der),\n          privateKey = _PrivateKeyInfo$decod.privateKey;\n\n      var _RSAPrivateKey$decode = RSAPrivateKey.decode(privateKey),\n          version = _RSAPrivateKey$decode.version,\n          n = _RSAPrivateKey$decode.n,\n          e = _RSAPrivateKey$decode.e,\n          d = _RSAPrivateKey$decode.d,\n          p = _RSAPrivateKey$decode.p,\n          q = _RSAPrivateKey$decode.q,\n          dp = _RSAPrivateKey$decode.dp,\n          dq = _RSAPrivateKey$decode.dq,\n          qi = _RSAPrivateKey$decode.qi;\n\n      if (version !== 'two-prime') {\n        throw new errors.JOSENotSupported('Private RSA keys with more than two primes are not supported');\n      }\n\n      return {\n        kty: 'RSA',\n        n: base64url.encodeBigInt(n),\n        e: base64url.encodeBigInt(e),\n        d: base64url.encodeBigInt(d),\n        p: base64url.encodeBigInt(p),\n        q: base64url.encodeBigInt(q),\n        dp: base64url.encodeBigInt(dp),\n        dq: base64url.encodeBigInt(dq),\n        qi: base64url.encodeBigInt(qi)\n      };\n    },\n    public: function _public(keyObject) {\n      var der = keyObject.export({\n        type: 'spki',\n        format: 'der'\n      });\n      var PublicKeyInfo = asn1.get('PublicKeyInfo');\n      var RSAPublicKey = asn1.get('RSAPublicKey');\n\n      var _PublicKeyInfo$decode2 = PublicKeyInfo.decode(der),\n          publicKey = _PublicKeyInfo$decode2.publicKey.data;\n\n      var _RSAPublicKey$decode = RSAPublicKey.decode(publicKey),\n          n = _RSAPublicKey$decode.n,\n          e = _RSAPublicKey$decode.e;\n\n      return {\n        kty: 'RSA',\n        n: base64url.encodeBigInt(n),\n        e: base64url.encodeBigInt(e)\n      };\n    }\n  },\n  ec: {\n    private: function _private(keyObject) {\n      var der = keyObject.export({\n        type: 'pkcs8',\n        format: 'der'\n      });\n      var PrivateKeyInfo = asn1.get('PrivateKeyInfo');\n      var ECPrivateKey = asn1.get('ECPrivateKey');\n\n      var _PrivateKeyInfo$decod2 = PrivateKeyInfo.decode(der),\n          privateKey = _PrivateKeyInfo$decod2.privateKey,\n          crv = _PrivateKeyInfo$decod2.algorithm.parameters.value;\n\n      var _ECPrivateKey$decode = ECPrivateKey.decode(privateKey),\n          d = _ECPrivateKey$decode.privateKey,\n          publicKey = _ECPrivateKey$decode.publicKey;\n\n      if (typeof publicKey === 'undefined') {\n        if (keyObjectSupported) {\n          return _objectSpread({}, keyObjectToJWK.ec.public(createPublicKey(keyObject)), {\n            d: base64url.encodeBuffer(d)\n          });\n        }\n\n        throw new errors.JOSENotSupported('Private EC keys without the public key embedded are not supported in your Node.js runtime version');\n      }\n\n      var x = publicKey.data.slice(1, (publicKey.data.length - 1) / 2 + 1);\n      var y = publicKey.data.slice((publicKey.data.length - 1) / 2 + 1);\n      return {\n        kty: 'EC',\n        crv: crv,\n        d: base64url.encodeBuffer(d),\n        x: base64url.encodeBuffer(x),\n        y: base64url.encodeBuffer(y)\n      };\n    },\n    public: function _public(keyObject) {\n      var der = keyObject.export({\n        type: 'spki',\n        format: 'der'\n      });\n      var PublicKeyInfo = asn1.get('PublicKeyInfo');\n\n      var _PublicKeyInfo$decode3 = PublicKeyInfo.decode(der),\n          publicKey = _PublicKeyInfo$decode3.publicKey.data,\n          crv = _PublicKeyInfo$decode3.algorithm.parameters.value;\n\n      var x = publicKey.slice(1, (publicKey.length - 1) / 2 + 1);\n      var y = publicKey.slice((publicKey.length - 1) / 2 + 1);\n      return {\n        kty: 'EC',\n        crv: crv,\n        x: base64url.encodeBuffer(x),\n        y: base64url.encodeBuffer(y)\n      };\n    }\n  },\n  ed25519: {\n    private: function _private(keyObject) {\n      return okpToJWK.private('Ed25519', keyObject);\n    },\n    public: function _public(keyObject) {\n      return okpToJWK.public('Ed25519', keyObject);\n    }\n  },\n  ed448: {\n    private: function _private(keyObject) {\n      return okpToJWK.private('Ed448', keyObject);\n    },\n    public: function _public(keyObject) {\n      return okpToJWK.public('Ed448', keyObject);\n    }\n  },\n  x25519: {\n    private: function _private(keyObject) {\n      return okpToJWK.private('X25519', keyObject);\n    },\n    public: function _public(keyObject) {\n      return okpToJWK.public('X25519', keyObject);\n    }\n  },\n  x448: {\n    private: function _private(keyObject) {\n      return okpToJWK.private('X448', keyObject);\n    },\n    public: function _public(keyObject) {\n      return okpToJWK.public('X448', keyObject);\n    }\n  }\n};\n\nmodule.exports.keyObjectToJWK = function (keyObject) {\n  if (keyObject.type === 'private') {\n    return keyObjectToJWK[keyObject.asymmetricKeyType].private(keyObject);\n  }\n\n  return keyObjectToJWK[keyObject.asymmetricKeyType].public(keyObject);\n};\n\nvar concatEcPublicKey = function concatEcPublicKey(x, y) {\n  return {\n    unused: 0,\n    data: Buffer.concat([Buffer.alloc(1, 4), base64url.decodeToBuffer(x), base64url.decodeToBuffer(y)])\n  };\n};\n\nvar jwkToPem = {\n  RSA: {\n    private: function _private(jwk, _ref) {\n      var calculateMissingRSAPrimes = _ref.calculateMissingRSAPrimes;\n      var RSAPrivateKey = asn1.get('RSAPrivateKey');\n\n      if ('oth' in jwk) {\n        throw new errors.JOSENotSupported('Private RSA keys with more than two primes are not supported');\n      }\n\n      if (jwk.p || jwk.q || jwk.dp || jwk.dq || jwk.qi) {\n        if (!(jwk.p && jwk.q && jwk.dp && jwk.dq && jwk.qi)) {\n          throw new errors.JWKInvalid('all other private key parameters must be present when any one of them is present');\n        }\n      } else if (calculateMissingRSAPrimes) {\n        jwk = computePrimes(jwk);\n      } else if (!calculateMissingRSAPrimes) {\n        throw new errors.JOSENotSupported('importing private RSA keys without all other private key parameters is not enabled, see documentation and its advisory on how and when its ok to enable it');\n      }\n\n      return RSAPrivateKey.encode({\n        version: 0,\n        n: BigInt(\"0x\".concat(base64url.decodeToBuffer(jwk.n).toString('hex'))),\n        e: BigInt(\"0x\".concat(base64url.decodeToBuffer(jwk.e).toString('hex'))),\n        d: BigInt(\"0x\".concat(base64url.decodeToBuffer(jwk.d).toString('hex'))),\n        p: BigInt(\"0x\".concat(base64url.decodeToBuffer(jwk.p).toString('hex'))),\n        q: BigInt(\"0x\".concat(base64url.decodeToBuffer(jwk.q).toString('hex'))),\n        dp: BigInt(\"0x\".concat(base64url.decodeToBuffer(jwk.dp).toString('hex'))),\n        dq: BigInt(\"0x\".concat(base64url.decodeToBuffer(jwk.dq).toString('hex'))),\n        qi: BigInt(\"0x\".concat(base64url.decodeToBuffer(jwk.qi).toString('hex')))\n      }, 'pem', {\n        label: 'RSA PRIVATE KEY'\n      });\n    },\n    public: function _public(jwk) {\n      var RSAPublicKey = asn1.get('RSAPublicKey');\n      return RSAPublicKey.encode({\n        version: 0,\n        n: BigInt(\"0x\".concat(base64url.decodeToBuffer(jwk.n).toString('hex'))),\n        e: BigInt(\"0x\".concat(base64url.decodeToBuffer(jwk.e).toString('hex')))\n      }, 'pem', {\n        label: 'RSA PUBLIC KEY'\n      });\n    }\n  },\n  EC: {\n    private: function _private(jwk) {\n      var ECPrivateKey = asn1.get('ECPrivateKey');\n      return ECPrivateKey.encode({\n        version: 1,\n        privateKey: base64url.decodeToBuffer(jwk.d),\n        parameters: {\n          type: 'namedCurve',\n          value: jwk.crv\n        },\n        publicKey: concatEcPublicKey(jwk.x, jwk.y)\n      }, 'pem', {\n        label: 'EC PRIVATE KEY'\n      });\n    },\n    public: function _public(jwk) {\n      var PublicKeyInfo = asn1.get('PublicKeyInfo');\n      return PublicKeyInfo.encode({\n        algorithm: {\n          algorithm: 'ecPublicKey',\n          parameters: {\n            type: 'namedCurve',\n            value: jwk.crv\n          }\n        },\n        publicKey: concatEcPublicKey(jwk.x, jwk.y)\n      }, 'pem', {\n        label: 'PUBLIC KEY'\n      });\n    }\n  },\n  OKP: {\n    private: function _private(jwk) {\n      var OneAsymmetricKey = asn1.get('OneAsymmetricKey');\n      var b64 = OneAsymmetricKey.encode({\n        version: 0,\n        privateKey: {\n          privateKey: base64url.decodeToBuffer(jwk.d)\n        },\n        algorithm: {\n          algorithm: jwk.crv\n        }\n      }, 'der'); // TODO: WHYYY? https://github.com/indutny/asn1.js/issues/110\n\n      b64.write('04', 12, 1, 'hex');\n      return formatPem(b64.toString('base64'), 'PRIVATE');\n    },\n    public: function _public(jwk) {\n      var PublicKeyInfo = asn1.get('PublicKeyInfo');\n      return PublicKeyInfo.encode({\n        algorithm: {\n          algorithm: jwk.crv\n        },\n        publicKey: {\n          unused: 0,\n          data: base64url.decodeToBuffer(jwk.x)\n        }\n      }, 'pem', {\n        label: 'PUBLIC KEY'\n      });\n    }\n  }\n};\n\nmodule.exports.jwkToPem = function (jwk) {\n  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref2$calculateMissin = _ref2.calculateMissingRSAPrimes,\n      calculateMissingRSAPrimes = _ref2$calculateMissin === void 0 ? false : _ref2$calculateMissin;\n\n  switch (jwk.kty) {\n    case 'EC':\n      if (!EC_CURVES.has(jwk.crv)) {\n        throw new errors.JOSENotSupported(\"unsupported EC key curve: \".concat(jwk.crv));\n      }\n\n      break;\n\n    case 'OKP':\n      if (!OKP_CURVES.has(jwk.crv)) {\n        throw new errors.JOSENotSupported(\"unsupported OKP key curve: \".concat(jwk.crv));\n      }\n\n      break;\n\n    case 'RSA':\n      break;\n\n    default:\n      throw new errors.JOSENotSupported(\"unsupported key type: \".concat(jwk.kty));\n  }\n\n  if (jwk.d) {\n    return jwkToPem[jwk.kty].private(jwk, {\n      calculateMissingRSAPrimes: calculateMissingRSAPrimes\n    });\n  }\n\n  return jwkToPem[jwk.kty].public(jwk);\n};","map":null,"metadata":{},"sourceType":"script"}