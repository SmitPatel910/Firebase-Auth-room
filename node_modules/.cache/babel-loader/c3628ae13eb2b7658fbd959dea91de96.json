{"ast":null,"code":"/*! firebase-admin v9.11.0 */\n\"use strict\";\n/*!\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExponentialBackoffPoller = exports.ApiSettings = exports.AuthorizedHttpClient = exports.parseHttpResponse = exports.HttpClient = exports.defaultRetryConfig = exports.HttpError = void 0;\n\nvar error_1 = require(\"./error\");\n\nvar validator = require(\"./validator\");\n\nvar http = require(\"http\");\n\nvar https = require(\"https\");\n\nvar url = require(\"url\");\n\nvar events_1 = require(\"events\");\n\nvar DefaultHttpResponse =\n/** @class */\nfunction () {\n  /**\n   * Constructs a new HttpResponse from the given LowLevelResponse.\n   */\n  function DefaultHttpResponse(resp) {\n    this.status = resp.status;\n    this.headers = resp.headers;\n    this.text = resp.data;\n\n    try {\n      if (!resp.data) {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'HTTP response missing data.');\n      }\n\n      this.parsedData = JSON.parse(resp.data);\n    } catch (err) {\n      this.parsedData = undefined;\n      this.parseError = err;\n    }\n\n    this.request = resp.config.method + \" \" + resp.config.url;\n  }\n\n  Object.defineProperty(DefaultHttpResponse.prototype, \"data\", {\n    get: function get() {\n      if (this.isJson()) {\n        return this.parsedData;\n      }\n\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.UNABLE_TO_PARSE_RESPONSE, \"Error while parsing response data: \\\"\" + this.parseError.toString() + \"\\\". Raw server \" + (\"response: \\\"\" + this.text + \"\\\". Status code: \\\"\" + this.status + \"\\\". Outgoing \") + (\"request: \\\"\" + this.request + \".\\\"\"));\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  DefaultHttpResponse.prototype.isJson = function () {\n    return typeof this.parsedData !== 'undefined';\n  };\n\n  return DefaultHttpResponse;\n}();\n/**\n * Represents a multipart HTTP response. Parts that constitute the response body can be accessed\n * via the multipart getter. Getters for text and data throw errors.\n */\n\n\nvar MultipartHttpResponse =\n/** @class */\nfunction () {\n  function MultipartHttpResponse(resp) {\n    this.status = resp.status;\n    this.headers = resp.headers;\n    this.multipart = resp.multipart;\n  }\n\n  Object.defineProperty(MultipartHttpResponse.prototype, \"text\", {\n    get: function get() {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.UNABLE_TO_PARSE_RESPONSE, 'Unable to parse multipart payload as text');\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MultipartHttpResponse.prototype, \"data\", {\n    get: function get() {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.UNABLE_TO_PARSE_RESPONSE, 'Unable to parse multipart payload as JSON');\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  MultipartHttpResponse.prototype.isJson = function () {\n    return false;\n  };\n\n  return MultipartHttpResponse;\n}();\n\nvar HttpError =\n/** @class */\nfunction (_super) {\n  __extends(HttpError, _super);\n\n  function HttpError(response) {\n    var _this = _super.call(this, \"Server responded with status \" + response.status + \".\") || this;\n\n    _this.response = response; // Set the prototype so that instanceof checks will work correctly.\n    // See: https://github.com/Microsoft/TypeScript/issues/13965\n\n    Object.setPrototypeOf(_this, HttpError.prototype);\n    return _this;\n  }\n\n  return HttpError;\n}(Error);\n\nexports.HttpError = HttpError;\n/**\n * Default retry configuration for HTTP requests. Retries up to 4 times on connection reset and timeout errors\n * as well as HTTP 503 errors. Exposed as a function to ensure that every HttpClient gets its own RetryConfig\n * instance.\n */\n\nfunction defaultRetryConfig() {\n  return {\n    maxRetries: 4,\n    statusCodes: [503],\n    ioErrorCodes: ['ECONNRESET', 'ETIMEDOUT'],\n    backOffFactor: 0.5,\n    maxDelayInMillis: 60 * 1000\n  };\n}\n\nexports.defaultRetryConfig = defaultRetryConfig;\n/**\n * Ensures that the given RetryConfig object is valid.\n *\n * @param retry The configuration to be validated.\n */\n\nfunction validateRetryConfig(retry) {\n  if (!validator.isNumber(retry.maxRetries) || retry.maxRetries < 0) {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'maxRetries must be a non-negative integer');\n  }\n\n  if (typeof retry.backOffFactor !== 'undefined') {\n    if (!validator.isNumber(retry.backOffFactor) || retry.backOffFactor < 0) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'backOffFactor must be a non-negative number');\n    }\n  }\n\n  if (!validator.isNumber(retry.maxDelayInMillis) || retry.maxDelayInMillis < 0) {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'maxDelayInMillis must be a non-negative integer');\n  }\n\n  if (typeof retry.statusCodes !== 'undefined' && !validator.isArray(retry.statusCodes)) {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'statusCodes must be an array');\n  }\n\n  if (typeof retry.ioErrorCodes !== 'undefined' && !validator.isArray(retry.ioErrorCodes)) {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'ioErrorCodes must be an array');\n  }\n}\n\nvar HttpClient =\n/** @class */\nfunction () {\n  function HttpClient(retry) {\n    if (retry === void 0) {\n      retry = defaultRetryConfig();\n    }\n\n    this.retry = retry;\n\n    if (this.retry) {\n      validateRetryConfig(this.retry);\n    }\n  }\n  /**\n   * Sends an HTTP request to a remote server. If the server responds with a successful response (2xx), the returned\n   * promise resolves with an HttpResponse. If the server responds with an error (3xx, 4xx, 5xx), the promise rejects\n   * with an HttpError. In case of all other errors, the promise rejects with a FirebaseAppError. If a request fails\n   * due to a low-level network error, transparently retries the request once before rejecting the promise.\n   *\n   * If the request data is specified as an object, it will be serialized into a JSON string. The application/json\n   * content-type header will also be automatically set in this case. For all other payload types, the content-type\n   * header should be explicitly set by the caller. To send a JSON leaf value (e.g. \"foo\", 5), parse it into JSON,\n   * and pass as a string or a Buffer along with the appropriate content-type header.\n   *\n   * @param {HttpRequest} config HTTP request to be sent.\n   * @return {Promise<HttpResponse>} A promise that resolves with the response details.\n   */\n\n\n  HttpClient.prototype.send = function (config) {\n    return this.sendWithRetry(config);\n  };\n  /**\n   * Sends an HTTP request. In the event of an error, retries the HTTP request according to the\n   * RetryConfig set on the HttpClient.\n   *\n   * @param {HttpRequestConfig} config HTTP request to be sent.\n   * @param {number} retryAttempts Number of retries performed up to now.\n   * @return {Promise<HttpResponse>} A promise that resolves with the response details.\n   */\n\n\n  HttpClient.prototype.sendWithRetry = function (config, retryAttempts) {\n    var _this = this;\n\n    if (retryAttempts === void 0) {\n      retryAttempts = 0;\n    }\n\n    return AsyncHttpCall.invoke(config).then(function (resp) {\n      return _this.createHttpResponse(resp);\n    }).catch(function (err) {\n      var _a = _this.getRetryDelayMillis(retryAttempts, err),\n          delayMillis = _a[0],\n          canRetry = _a[1];\n\n      if (canRetry && _this.retry && delayMillis <= _this.retry.maxDelayInMillis) {\n        return _this.waitForRetry(delayMillis).then(function () {\n          return _this.sendWithRetry(config, retryAttempts + 1);\n        });\n      }\n\n      if (err.response) {\n        throw new HttpError(_this.createHttpResponse(err.response));\n      }\n\n      if (err.code === 'ETIMEDOUT') {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_TIMEOUT, \"Error while making request: \" + err.message + \".\");\n      }\n\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_ERROR, \"Error while making request: \" + err.message + \". Error code: \" + err.code);\n    });\n  };\n\n  HttpClient.prototype.createHttpResponse = function (resp) {\n    if (resp.multipart) {\n      return new MultipartHttpResponse(resp);\n    }\n\n    return new DefaultHttpResponse(resp);\n  };\n\n  HttpClient.prototype.waitForRetry = function (delayMillis) {\n    if (delayMillis > 0) {\n      return new Promise(function (resolve) {\n        setTimeout(resolve, delayMillis);\n      });\n    }\n\n    return Promise.resolve();\n  };\n  /**\n   * Checks if a failed request is eligible for a retry, and if so returns the duration to wait before initiating\n   * the retry.\n   *\n   * @param {number} retryAttempts Number of retries completed up to now.\n   * @param {LowLevelError} err The last encountered error.\n   * @returns {[number, boolean]} A 2-tuple where the 1st element is the duration to wait before another retry, and the\n   *     2nd element is a boolean indicating whether the request is eligible for a retry or not.\n   */\n\n\n  HttpClient.prototype.getRetryDelayMillis = function (retryAttempts, err) {\n    if (!this.isRetryEligible(retryAttempts, err)) {\n      return [0, false];\n    }\n\n    var response = err.response;\n\n    if (response && response.headers['retry-after']) {\n      var delayMillis = this.parseRetryAfterIntoMillis(response.headers['retry-after']);\n\n      if (delayMillis > 0) {\n        return [delayMillis, true];\n      }\n    }\n\n    return [this.backOffDelayMillis(retryAttempts), true];\n  };\n\n  HttpClient.prototype.isRetryEligible = function (retryAttempts, err) {\n    if (!this.retry) {\n      return false;\n    }\n\n    if (retryAttempts >= this.retry.maxRetries) {\n      return false;\n    }\n\n    if (err.response) {\n      var statusCodes = this.retry.statusCodes || [];\n      return statusCodes.indexOf(err.response.status) !== -1;\n    }\n\n    if (err.code) {\n      var retryCodes = this.retry.ioErrorCodes || [];\n      return retryCodes.indexOf(err.code) !== -1;\n    }\n\n    return false;\n  };\n  /**\n   * Parses the Retry-After HTTP header as a milliseconds value. Return value is negative if the Retry-After header\n   * contains an expired timestamp or otherwise malformed.\n   */\n\n\n  HttpClient.prototype.parseRetryAfterIntoMillis = function (retryAfter) {\n    var delaySeconds = parseInt(retryAfter, 10);\n\n    if (!isNaN(delaySeconds)) {\n      return delaySeconds * 1000;\n    }\n\n    var date = new Date(retryAfter);\n\n    if (!isNaN(date.getTime())) {\n      return date.getTime() - Date.now();\n    }\n\n    return -1;\n  };\n\n  HttpClient.prototype.backOffDelayMillis = function (retryAttempts) {\n    if (retryAttempts === 0) {\n      return 0;\n    }\n\n    if (!this.retry) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'Expected this.retry to exist.');\n    }\n\n    var backOffFactor = this.retry.backOffFactor || 0;\n    var delayInSeconds = Math.pow(2, retryAttempts) * backOffFactor;\n    return Math.min(delayInSeconds * 1000, this.retry.maxDelayInMillis);\n  };\n\n  return HttpClient;\n}();\n\nexports.HttpClient = HttpClient;\n/**\n * Parses a full HTTP response message containing both a header and a body.\n *\n * @param {string|Buffer} response The HTTP response to be parsed.\n * @param {HttpRequestConfig} config The request configuration that resulted in the HTTP response.\n * @return {HttpResponse} An object containing the parsed HTTP status, headers and the body.\n */\n\nfunction parseHttpResponse(response, config) {\n  var responseText = validator.isBuffer(response) ? response.toString('utf-8') : response;\n  var endOfHeaderPos = responseText.indexOf('\\r\\n\\r\\n');\n  var headerLines = responseText.substring(0, endOfHeaderPos).split('\\r\\n');\n  var statusLine = headerLines[0];\n  var status = statusLine.trim().split(/\\s/)[1];\n  var headers = {};\n  headerLines.slice(1).forEach(function (line) {\n    var colonPos = line.indexOf(':');\n    var name = line.substring(0, colonPos).trim().toLowerCase();\n    var value = line.substring(colonPos + 1).trim();\n    headers[name] = value;\n  });\n  var data = responseText.substring(endOfHeaderPos + 4);\n\n  if (data.endsWith('\\n')) {\n    data = data.slice(0, -1);\n  }\n\n  if (data.endsWith('\\r')) {\n    data = data.slice(0, -1);\n  }\n\n  var lowLevelResponse = {\n    status: parseInt(status, 10),\n    headers: headers,\n    data: data,\n    config: config,\n    request: null\n  };\n\n  if (!validator.isNumber(lowLevelResponse.status)) {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'Malformed HTTP status line.');\n  }\n\n  return new DefaultHttpResponse(lowLevelResponse);\n}\n\nexports.parseHttpResponse = parseHttpResponse;\n/**\n * A helper class for sending HTTP requests over the wire. This is a wrapper around the standard\n * http and https packages of Node.js, providing content processing, timeouts and error handling.\n * It also wraps the callback API of the Node.js standard library in a more flexible Promise API.\n */\n\nvar AsyncHttpCall =\n/** @class */\nfunction () {\n  function AsyncHttpCall(config) {\n    var _this = this;\n\n    try {\n      this.config = new HttpRequestConfigImpl(config);\n      this.options = this.config.buildRequestOptions();\n      this.entity = this.config.buildEntity(this.options.headers);\n      this.promise = new Promise(function (resolve, reject) {\n        _this.resolve = resolve;\n        _this.reject = reject;\n\n        _this.execute();\n      });\n    } catch (err) {\n      this.promise = Promise.reject(this.enhanceError(err, null));\n    }\n  }\n  /**\n   * Sends an HTTP request based on the provided configuration.\n   */\n\n\n  AsyncHttpCall.invoke = function (config) {\n    return new AsyncHttpCall(config).promise;\n  };\n\n  AsyncHttpCall.prototype.execute = function () {\n    var _this = this;\n\n    var transport = this.options.protocol === 'https:' ? https : http;\n    var req = transport.request(this.options, function (res) {\n      _this.handleResponse(res, req);\n    }); // Handle errors\n\n    req.on('error', function (err) {\n      if (req.aborted) {\n        return;\n      }\n\n      _this.enhanceAndReject(err, null, req);\n    });\n    var timeout = this.config.timeout;\n\n    var timeoutCallback = function timeoutCallback() {\n      req.abort();\n\n      _this.rejectWithError(\"timeout of \" + timeout + \"ms exceeded\", 'ETIMEDOUT', req);\n    };\n\n    if (timeout) {\n      // Listen to timeouts and throw an error.\n      req.setTimeout(timeout, timeoutCallback);\n      req.on('socket', function (socket) {\n        socket.setTimeout(timeout, timeoutCallback);\n      });\n    } // Send the request\n\n\n    req.end(this.entity);\n  };\n\n  AsyncHttpCall.prototype.handleResponse = function (res, req) {\n    if (req.aborted) {\n      return;\n    }\n\n    if (!res.statusCode) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'Expected a statusCode on the response from a ClientRequest');\n    }\n\n    var response = {\n      status: res.statusCode,\n      headers: res.headers,\n      request: req,\n      data: undefined,\n      config: this.config\n    };\n    var boundary = this.getMultipartBoundary(res.headers);\n    var respStream = this.uncompressResponse(res);\n\n    if (boundary) {\n      this.handleMultipartResponse(response, respStream, boundary);\n    } else {\n      this.handleRegularResponse(response, respStream);\n    }\n  };\n  /**\n   * Extracts multipart boundary from the HTTP header. The content-type header of a multipart\n   * response has the form 'multipart/subtype; boundary=string'.\n   *\n   * If the content-type header does not exist, or does not start with\n   * 'multipart/', then null will be returned.\n   */\n\n\n  AsyncHttpCall.prototype.getMultipartBoundary = function (headers) {\n    var contentType = headers['content-type'];\n\n    if (!contentType || !contentType.startsWith('multipart/')) {\n      return null;\n    }\n\n    var segments = contentType.split(';');\n    var emptyObject = {};\n    var headerParams = segments.slice(1).map(function (segment) {\n      return segment.trim().split('=');\n    }).reduce(function (curr, params) {\n      // Parse key=value pairs in the content-type header into properties of an object.\n      if (params.length === 2) {\n        var keyValuePair = {};\n        keyValuePair[params[0]] = params[1];\n        return Object.assign(curr, keyValuePair);\n      }\n\n      return curr;\n    }, emptyObject);\n    return headerParams.boundary;\n  };\n\n  AsyncHttpCall.prototype.uncompressResponse = function (res) {\n    // Uncompress the response body transparently if required.\n    var respStream = res;\n    var encodings = ['gzip', 'compress', 'deflate'];\n\n    if (res.headers['content-encoding'] && encodings.indexOf(res.headers['content-encoding']) !== -1) {\n      // Add the unzipper to the body stream processing pipeline.\n      var zlib = require('zlib'); // eslint-disable-line @typescript-eslint/no-var-requires\n\n\n      respStream = respStream.pipe(zlib.createUnzip()); // Remove the content-encoding in order to not confuse downstream operations.\n\n      delete res.headers['content-encoding'];\n    }\n\n    return respStream;\n  };\n\n  AsyncHttpCall.prototype.handleMultipartResponse = function (response, respStream, boundary) {\n    var _this = this;\n\n    var dicer = require('dicer'); // eslint-disable-line @typescript-eslint/no-var-requires\n\n\n    var multipartParser = new dicer({\n      boundary: boundary\n    });\n    var responseBuffer = [];\n    multipartParser.on('part', function (part) {\n      var tempBuffers = [];\n      part.on('data', function (partData) {\n        tempBuffers.push(partData);\n      });\n      part.on('end', function () {\n        responseBuffer.push(Buffer.concat(tempBuffers));\n      });\n    });\n    multipartParser.on('finish', function () {\n      response.data = undefined;\n      response.multipart = responseBuffer;\n\n      _this.finalizeResponse(response);\n    });\n    respStream.pipe(multipartParser);\n  };\n\n  AsyncHttpCall.prototype.handleRegularResponse = function (response, respStream) {\n    var _this = this;\n\n    var responseBuffer = [];\n    respStream.on('data', function (chunk) {\n      responseBuffer.push(chunk);\n    });\n    respStream.on('error', function (err) {\n      var req = response.request;\n\n      if (req && req.aborted) {\n        return;\n      }\n\n      _this.enhanceAndReject(err, null, req);\n    });\n    respStream.on('end', function () {\n      response.data = Buffer.concat(responseBuffer).toString();\n\n      _this.finalizeResponse(response);\n    });\n  };\n  /**\n   * Finalizes the current HTTP call in-flight by either resolving or rejecting the associated\n   * promise. In the event of an error, adds additional useful information to the returned error.\n   */\n\n\n  AsyncHttpCall.prototype.finalizeResponse = function (response) {\n    if (response.status >= 200 && response.status < 300) {\n      this.resolve(response);\n    } else {\n      this.rejectWithError('Request failed with status code ' + response.status, null, response.request, response);\n    }\n  };\n  /**\n   * Creates a new error from the given message, and enhances it with other information available.\n   * Then the promise associated with this HTTP call is rejected with the resulting error.\n   */\n\n\n  AsyncHttpCall.prototype.rejectWithError = function (message, code, request, response) {\n    var error = new Error(message);\n    this.enhanceAndReject(error, code, request, response);\n  };\n\n  AsyncHttpCall.prototype.enhanceAndReject = function (error, code, request, response) {\n    this.reject(this.enhanceError(error, code, request, response));\n  };\n  /**\n   * Enhances the given error by adding more information to it. Specifically, the HttpRequestConfig,\n   * the underlying request and response will be attached to the error.\n   */\n\n\n  AsyncHttpCall.prototype.enhanceError = function (error, code, request, response) {\n    error.config = this.config;\n\n    if (code) {\n      error.code = code;\n    }\n\n    error.request = request;\n    error.response = response;\n    return error;\n  };\n\n  return AsyncHttpCall;\n}();\n/**\n * An adapter class for extracting options and entity data from an HttpRequestConfig.\n */\n\n\nvar HttpRequestConfigImpl =\n/** @class */\nfunction () {\n  function HttpRequestConfigImpl(config) {\n    this.config = config;\n  }\n\n  Object.defineProperty(HttpRequestConfigImpl.prototype, \"method\", {\n    get: function get() {\n      return this.config.method;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(HttpRequestConfigImpl.prototype, \"url\", {\n    get: function get() {\n      return this.config.url;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(HttpRequestConfigImpl.prototype, \"headers\", {\n    get: function get() {\n      return this.config.headers;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(HttpRequestConfigImpl.prototype, \"data\", {\n    get: function get() {\n      return this.config.data;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(HttpRequestConfigImpl.prototype, \"timeout\", {\n    get: function get() {\n      return this.config.timeout;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(HttpRequestConfigImpl.prototype, \"httpAgent\", {\n    get: function get() {\n      return this.config.httpAgent;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  HttpRequestConfigImpl.prototype.buildRequestOptions = function () {\n    var parsed = this.buildUrl();\n    var protocol = parsed.protocol;\n    var port = parsed.port;\n\n    if (!port) {\n      var isHttps = protocol === 'https:';\n      port = isHttps ? '443' : '80';\n    }\n\n    return {\n      protocol: protocol,\n      hostname: parsed.hostname,\n      port: port,\n      path: parsed.path,\n      method: this.method,\n      agent: this.httpAgent,\n      headers: Object.assign({}, this.headers)\n    };\n  };\n\n  HttpRequestConfigImpl.prototype.buildEntity = function (headers) {\n    var data;\n\n    if (!this.hasEntity() || !this.isEntityEnclosingRequest()) {\n      return data;\n    }\n\n    if (validator.isBuffer(this.data)) {\n      data = this.data;\n    } else if (validator.isObject(this.data)) {\n      data = Buffer.from(JSON.stringify(this.data), 'utf-8');\n\n      if (typeof headers['content-type'] === 'undefined') {\n        headers['content-type'] = 'application/json;charset=utf-8';\n      }\n    } else if (validator.isString(this.data)) {\n      data = Buffer.from(this.data, 'utf-8');\n    } else {\n      throw new Error('Request data must be a string, a Buffer or a json serializable object');\n    } // Add Content-Length header if data exists.\n\n\n    headers['Content-Length'] = data.length.toString();\n    return data;\n  };\n\n  HttpRequestConfigImpl.prototype.buildUrl = function () {\n    var fullUrl = this.urlWithProtocol();\n\n    if (!this.hasEntity() || this.isEntityEnclosingRequest()) {\n      return url.parse(fullUrl);\n    }\n\n    if (!validator.isObject(this.data)) {\n      throw new Error(this.method + \" requests cannot have a body\");\n    } // Parse URL and append data to query string.\n\n\n    var parsedUrl = new url.URL(fullUrl);\n    var dataObj = this.data;\n\n    for (var key in dataObj) {\n      if (Object.prototype.hasOwnProperty.call(dataObj, key)) {\n        parsedUrl.searchParams.append(key, dataObj[key]);\n      }\n    }\n\n    return url.parse(parsedUrl.toString());\n  };\n\n  HttpRequestConfigImpl.prototype.urlWithProtocol = function () {\n    var fullUrl = this.url;\n\n    if (fullUrl.startsWith('http://') || fullUrl.startsWith('https://')) {\n      return fullUrl;\n    }\n\n    return \"https://\" + fullUrl;\n  };\n\n  HttpRequestConfigImpl.prototype.hasEntity = function () {\n    return !!this.data;\n  };\n\n  HttpRequestConfigImpl.prototype.isEntityEnclosingRequest = function () {\n    // GET and HEAD requests do not support entity (body) in request.\n    return this.method !== 'GET' && this.method !== 'HEAD';\n  };\n\n  return HttpRequestConfigImpl;\n}();\n\nvar AuthorizedHttpClient =\n/** @class */\nfunction (_super) {\n  __extends(AuthorizedHttpClient, _super);\n\n  function AuthorizedHttpClient(app) {\n    var _this = _super.call(this) || this;\n\n    _this.app = app;\n    return _this;\n  }\n\n  AuthorizedHttpClient.prototype.send = function (request) {\n    var _this = this;\n\n    return this.getToken().then(function (token) {\n      var requestCopy = Object.assign({}, request);\n      requestCopy.headers = Object.assign({}, request.headers);\n      var authHeader = 'Authorization';\n      requestCopy.headers[authHeader] = \"Bearer \" + token;\n\n      if (!requestCopy.httpAgent && _this.app.options.httpAgent) {\n        requestCopy.httpAgent = _this.app.options.httpAgent;\n      }\n\n      return _super.prototype.send.call(_this, requestCopy);\n    });\n  };\n\n  AuthorizedHttpClient.prototype.getToken = function () {\n    return this.app.INTERNAL.getToken().then(function (accessTokenObj) {\n      return accessTokenObj.accessToken;\n    });\n  };\n\n  return AuthorizedHttpClient;\n}(HttpClient);\n\nexports.AuthorizedHttpClient = AuthorizedHttpClient;\n/**\n * Class that defines all the settings for the backend API endpoint.\n *\n * @param {string} endpoint The Firebase Auth backend endpoint.\n * @param {HttpMethod} httpMethod The http method for that endpoint.\n * @constructor\n */\n\nvar ApiSettings =\n/** @class */\nfunction () {\n  function ApiSettings(endpoint, httpMethod) {\n    if (httpMethod === void 0) {\n      httpMethod = 'POST';\n    }\n\n    this.endpoint = endpoint;\n    this.httpMethod = httpMethod;\n    this.setRequestValidator(null).setResponseValidator(null);\n  }\n  /** @return {string} The backend API endpoint. */\n\n\n  ApiSettings.prototype.getEndpoint = function () {\n    return this.endpoint;\n  };\n  /** @return {HttpMethod} The request HTTP method. */\n\n\n  ApiSettings.prototype.getHttpMethod = function () {\n    return this.httpMethod;\n  };\n  /**\n   * @param {ApiCallbackFunction} requestValidator The request validator.\n   * @return {ApiSettings} The current API settings instance.\n   */\n\n\n  ApiSettings.prototype.setRequestValidator = function (requestValidator) {\n    var nullFunction = function nullFunction() {\n      return undefined;\n    };\n\n    this.requestValidator = requestValidator || nullFunction;\n    return this;\n  };\n  /** @return {ApiCallbackFunction} The request validator. */\n\n\n  ApiSettings.prototype.getRequestValidator = function () {\n    return this.requestValidator;\n  };\n  /**\n   * @param {ApiCallbackFunction} responseValidator The response validator.\n   * @return {ApiSettings} The current API settings instance.\n   */\n\n\n  ApiSettings.prototype.setResponseValidator = function (responseValidator) {\n    var nullFunction = function nullFunction() {\n      return undefined;\n    };\n\n    this.responseValidator = responseValidator || nullFunction;\n    return this;\n  };\n  /** @return {ApiCallbackFunction} The response validator. */\n\n\n  ApiSettings.prototype.getResponseValidator = function () {\n    return this.responseValidator;\n  };\n\n  return ApiSettings;\n}();\n\nexports.ApiSettings = ApiSettings;\n/**\n * Class used for polling an endpoint with exponential backoff.\n *\n * Example usage:\n * ```\n * const poller = new ExponentialBackoffPoller();\n * poller\n *     .poll(() => {\n *       return myRequestToPoll()\n *           .then((responseData: any) => {\n *             if (!isValid(responseData)) {\n *               // Continue polling.\n *               return null;\n *             }\n *\n *             // Polling complete. Resolve promise with final response data.\n *             return responseData;\n *           });\n *     })\n *     .then((responseData: any) => {\n *       console.log(`Final response: ${responseData}`);\n *     });\n * ```\n */\n\nvar ExponentialBackoffPoller =\n/** @class */\nfunction (_super) {\n  __extends(ExponentialBackoffPoller, _super);\n\n  function ExponentialBackoffPoller(initialPollingDelayMillis, maxPollingDelayMillis, masterTimeoutMillis) {\n    if (initialPollingDelayMillis === void 0) {\n      initialPollingDelayMillis = 1000;\n    }\n\n    if (maxPollingDelayMillis === void 0) {\n      maxPollingDelayMillis = 10000;\n    }\n\n    if (masterTimeoutMillis === void 0) {\n      masterTimeoutMillis = 60000;\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this.initialPollingDelayMillis = initialPollingDelayMillis;\n    _this.maxPollingDelayMillis = maxPollingDelayMillis;\n    _this.masterTimeoutMillis = masterTimeoutMillis;\n    _this.numTries = 0;\n    _this.completed = false;\n    return _this;\n  }\n  /**\n   * Poll the provided callback with exponential backoff.\n   *\n   * @param {() => Promise<T>} callback The callback to be called for each poll. If the\n   *     callback resolves to a falsey value, polling will continue. Otherwise, the truthy\n   *     resolution will be used to resolve the promise returned by this method.\n   * @return {Promise<T>} A Promise which resolves to the truthy value returned by the provided\n   *     callback when polling is complete.\n   */\n\n\n  ExponentialBackoffPoller.prototype.poll = function (callback) {\n    var _this = this;\n\n    if (this.pollCallback) {\n      throw new Error('poll() can only be called once per instance of ExponentialBackoffPoller');\n    }\n\n    this.pollCallback = callback;\n    this.on('poll', this.repoll);\n    this.masterTimer = setTimeout(function () {\n      if (_this.completed) {\n        return;\n      }\n\n      _this.markCompleted();\n\n      _this.reject(new Error('ExponentialBackoffPoller deadline exceeded - Master timeout reached'));\n    }, this.masterTimeoutMillis);\n    return new Promise(function (resolve, reject) {\n      _this.resolve = resolve;\n      _this.reject = reject;\n\n      _this.repoll();\n    });\n  };\n\n  ExponentialBackoffPoller.prototype.repoll = function () {\n    var _this = this;\n\n    this.pollCallback().then(function (result) {\n      if (_this.completed) {\n        return;\n      }\n\n      if (!result) {\n        _this.repollTimer = setTimeout(function () {\n          return _this.emit('poll');\n        }, _this.getPollingDelayMillis());\n        _this.numTries++;\n        return;\n      }\n\n      _this.markCompleted();\n\n      _this.resolve(result);\n    }).catch(function (err) {\n      if (_this.completed) {\n        return;\n      }\n\n      _this.markCompleted();\n\n      _this.reject(err);\n    });\n  };\n\n  ExponentialBackoffPoller.prototype.getPollingDelayMillis = function () {\n    var increasedPollingDelay = Math.pow(2, this.numTries) * this.initialPollingDelayMillis;\n    return Math.min(increasedPollingDelay, this.maxPollingDelayMillis);\n  };\n\n  ExponentialBackoffPoller.prototype.markCompleted = function () {\n    this.completed = true;\n\n    if (this.masterTimer) {\n      clearTimeout(this.masterTimer);\n    }\n\n    if (this.repollTimer) {\n      clearTimeout(this.repollTimer);\n    }\n  };\n\n  return ExponentialBackoffPoller;\n}(events_1.EventEmitter);\n\nexports.ExponentialBackoffPoller = ExponentialBackoffPoller;","map":null,"metadata":{},"sourceType":"script"}