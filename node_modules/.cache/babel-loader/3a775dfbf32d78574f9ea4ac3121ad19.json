{"ast":null,"code":"/*! firebase-admin v9.11.0 */\n\"use strict\";\n/*!\n * Copyright 2020 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Model = exports.MachineLearning = void 0;\n\nvar machine_learning_api_client_1 = require(\"./machine-learning-api-client\");\n\nvar error_1 = require(\"../utils/error\");\n\nvar validator = require(\"../utils/validator\");\n\nvar machine_learning_utils_1 = require(\"./machine-learning-utils\");\n\nvar deep_copy_1 = require(\"../utils/deep-copy\");\n\nvar utils = require(\"../utils\");\n/**\n * The Firebase Machine Learning class\n */\n\n\nvar MachineLearning =\n/** @class */\nfunction () {\n  /**\n   * @param {FirebaseApp} app The app for this ML service.\n   * @constructor\n   */\n  function MachineLearning(app) {\n    if (!validator.isNonNullObject(app) || !('options' in app)) {\n      throw new error_1.FirebaseError({\n        code: 'machine-learning/invalid-argument',\n        message: 'First argument passed to admin.machineLearning() must be a ' + 'valid Firebase app instance.'\n      });\n    }\n\n    this.appInternal = app;\n    this.client = new machine_learning_api_client_1.MachineLearningApiClient(app);\n  }\n\n  Object.defineProperty(MachineLearning.prototype, \"app\", {\n    /**\n     * Returns the app associated with this ML instance.\n     *\n     * @return {FirebaseApp} The app associated with this ML instance.\n     */\n    get: function get() {\n      return this.appInternal;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Creates a model in Firebase ML.\n   *\n   * @param {ModelOptions} model The model to create.\n   *\n   * @return {Promise<Model>} A Promise fulfilled with the created model.\n   */\n\n  MachineLearning.prototype.createModel = function (model) {\n    var _this = this;\n\n    return this.signUrlIfPresent(model).then(function (modelContent) {\n      return _this.client.createModel(modelContent);\n    }).then(function (operation) {\n      return _this.client.handleOperation(operation);\n    }).then(function (modelResponse) {\n      return new Model(modelResponse, _this.client);\n    });\n  };\n  /**\n   * Updates a model in Firebase ML.\n   *\n   * @param {string} modelId The id of the model to update.\n   * @param {ModelOptions} model The model fields to update.\n   *\n   * @return {Promise<Model>} A Promise fulfilled with the updated model.\n   */\n\n\n  MachineLearning.prototype.updateModel = function (modelId, model) {\n    var _this = this;\n\n    var updateMask = utils.generateUpdateMask(model);\n    return this.signUrlIfPresent(model).then(function (modelContent) {\n      return _this.client.updateModel(modelId, modelContent, updateMask);\n    }).then(function (operation) {\n      return _this.client.handleOperation(operation);\n    }).then(function (modelResponse) {\n      return new Model(modelResponse, _this.client);\n    });\n  };\n  /**\n   * Publishes a model in Firebase ML.\n   *\n   * @param {string} modelId The id of the model to publish.\n   *\n   * @return {Promise<Model>} A Promise fulfilled with the published model.\n   */\n\n\n  MachineLearning.prototype.publishModel = function (modelId) {\n    return this.setPublishStatus(modelId, true);\n  };\n  /**\n   * Unpublishes a model in Firebase ML.\n   *\n   * @param {string} modelId The id of the model to unpublish.\n   *\n   * @return {Promise<Model>} A Promise fulfilled with the unpublished model.\n   */\n\n\n  MachineLearning.prototype.unpublishModel = function (modelId) {\n    return this.setPublishStatus(modelId, false);\n  };\n  /**\n   * Gets a model from Firebase ML.\n   *\n   * @param {string} modelId The id of the model to get.\n   *\n   * @return {Promise<Model>} A Promise fulfilled with the unpublished model.\n   */\n\n\n  MachineLearning.prototype.getModel = function (modelId) {\n    var _this = this;\n\n    return this.client.getModel(modelId).then(function (modelResponse) {\n      return new Model(modelResponse, _this.client);\n    });\n  };\n  /**\n   * Lists models from Firebase ML.\n   *\n   * @param {ListModelsOptions} options The listing options.\n   *\n   * @return {Promise<{models: Model[], pageToken?: string}>} A promise that\n   *     resolves with the current (filtered) list of models and the next page\n   *     token. For the last page, an empty list of models and no page token are\n   *     returned.\n   */\n\n\n  MachineLearning.prototype.listModels = function (options) {\n    var _this = this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    return this.client.listModels(options).then(function (resp) {\n      if (!validator.isNonNullObject(resp)) {\n        throw new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', \"Invalid ListModels response: \" + JSON.stringify(resp));\n      }\n\n      var models = [];\n\n      if (resp.models) {\n        models = resp.models.map(function (rs) {\n          return new Model(rs, _this.client);\n        });\n      }\n\n      var result = {\n        models: models\n      };\n\n      if (resp.nextPageToken) {\n        result.pageToken = resp.nextPageToken;\n      }\n\n      return result;\n    });\n  };\n  /**\n   * Deletes a model from Firebase ML.\n   *\n   * @param {string} modelId The id of the model to delete.\n   */\n\n\n  MachineLearning.prototype.deleteModel = function (modelId) {\n    return this.client.deleteModel(modelId);\n  };\n\n  MachineLearning.prototype.setPublishStatus = function (modelId, publish) {\n    var _this = this;\n\n    var updateMask = ['state.published'];\n    var options = {\n      state: {\n        published: publish\n      }\n    };\n    return this.client.updateModel(modelId, options, updateMask).then(function (operation) {\n      return _this.client.handleOperation(operation);\n    }).then(function (modelResponse) {\n      return new Model(modelResponse, _this.client);\n    });\n  };\n\n  MachineLearning.prototype.signUrlIfPresent = function (options) {\n    var modelOptions = deep_copy_1.deepCopy(options);\n\n    if (machine_learning_api_client_1.isGcsTfliteModelOptions(modelOptions)) {\n      return this.signUrl(modelOptions.tfliteModel.gcsTfliteUri).then(function (uri) {\n        modelOptions.tfliteModel.gcsTfliteUri = uri;\n        return modelOptions;\n      }).catch(function (err) {\n        throw new machine_learning_utils_1.FirebaseMachineLearningError('internal-error', \"Error during signing upload url: \" + err.message);\n      });\n    }\n\n    return Promise.resolve(modelOptions);\n  };\n\n  MachineLearning.prototype.signUrl = function (unsignedUrl) {\n    var MINUTES_IN_MILLIS = 60 * 1000;\n    var URL_VALID_DURATION = 10 * MINUTES_IN_MILLIS;\n    var gcsRegex = /^gs:\\/\\/([a-z0-9_.-]{3,63})\\/(.+)$/;\n    var matches = gcsRegex.exec(unsignedUrl);\n\n    if (!matches) {\n      throw new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', \"Invalid unsigned url: \" + unsignedUrl);\n    }\n\n    var bucketName = matches[1];\n    var blobName = matches[2];\n    var bucket = this.appInternal.storage().bucket(bucketName);\n    var blob = bucket.file(blobName);\n    return blob.getSignedUrl({\n      action: 'read',\n      expires: Date.now() + URL_VALID_DURATION\n    }).then(function (signUrl) {\n      return signUrl[0];\n    });\n  };\n\n  return MachineLearning;\n}();\n\nexports.MachineLearning = MachineLearning;\n/**\n * A Firebase ML Model output object.\n */\n\nvar Model =\n/** @class */\nfunction () {\n  function Model(model, client) {\n    this.model = Model.validateAndClone(model);\n    this.client = client;\n  }\n\n  Object.defineProperty(Model.prototype, \"modelId\", {\n    get: function get() {\n      return extractModelId(this.model.name);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Model.prototype, \"displayName\", {\n    get: function get() {\n      return this.model.displayName;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Model.prototype, \"tags\", {\n    get: function get() {\n      return this.model.tags || [];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Model.prototype, \"createTime\", {\n    get: function get() {\n      return new Date(this.model.createTime).toUTCString();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Model.prototype, \"updateTime\", {\n    get: function get() {\n      return new Date(this.model.updateTime).toUTCString();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Model.prototype, \"validationError\", {\n    get: function get() {\n      var _a, _b;\n\n      return (_b = (_a = this.model.state) === null || _a === void 0 ? void 0 : _a.validationError) === null || _b === void 0 ? void 0 : _b.message;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Model.prototype, \"published\", {\n    get: function get() {\n      var _a;\n\n      return ((_a = this.model.state) === null || _a === void 0 ? void 0 : _a.published) || false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Model.prototype, \"etag\", {\n    get: function get() {\n      return this.model.etag;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Model.prototype, \"modelHash\", {\n    get: function get() {\n      return this.model.modelHash;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Model.prototype, \"tfliteModel\", {\n    get: function get() {\n      // Make a copy so people can't directly modify the private this.model object.\n      return deep_copy_1.deepCopy(this.model.tfliteModel);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Model.prototype, \"locked\", {\n    /**\n     * Locked indicates if there are active long running operations on the model.\n     * Models may not be modified when they are locked.\n     */\n    get: function get() {\n      var _a, _b;\n\n      return ((_b = (_a = this.model.activeOperations) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) > 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Model.prototype.toJSON = function () {\n    // We can't just return this.model because it has extra fields and\n    // different formats etc. So we build the expected model object.\n    var jsonModel = {\n      modelId: this.modelId,\n      displayName: this.displayName,\n      tags: this.tags,\n      createTime: this.createTime,\n      updateTime: this.updateTime,\n      published: this.published,\n      etag: this.etag,\n      locked: this.locked\n    }; // Also add possibly undefined fields if they exist.\n\n    if (this.validationError) {\n      jsonModel['validationError'] = this.validationError;\n    }\n\n    if (this.modelHash) {\n      jsonModel['modelHash'] = this.modelHash;\n    }\n\n    if (this.tfliteModel) {\n      jsonModel['tfliteModel'] = this.tfliteModel;\n    }\n\n    return jsonModel;\n  };\n  /**\n   * Wait for the active operations on the model to complete.\n   * @param maxTimeMillis The number of milliseconds to wait for the model to be unlocked. If unspecified,\n   *     a default will be used.\n   */\n\n\n  Model.prototype.waitForUnlocked = function (maxTimeMillis) {\n    var _this = this;\n\n    var _a, _b;\n\n    if (((_b = (_a = this.model.activeOperations) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) > 0) {\n      // The client will always be defined on Models that have activeOperations\n      // because models with active operations came back from the server and\n      // were constructed with a non-empty client.\n      return this.client.handleOperation(this.model.activeOperations[0], {\n        wait: true,\n        maxTimeMillis: maxTimeMillis\n      }).then(function (modelResponse) {\n        _this.model = Model.validateAndClone(modelResponse);\n      });\n    }\n\n    return Promise.resolve();\n  };\n\n  Model.validateAndClone = function (model) {\n    if (!validator.isNonNullObject(model) || !validator.isNonEmptyString(model.name) || !validator.isNonEmptyString(model.createTime) || !validator.isNonEmptyString(model.updateTime) || !validator.isNonEmptyString(model.displayName) || !validator.isNonEmptyString(model.etag)) {\n      throw new machine_learning_utils_1.FirebaseMachineLearningError('invalid-server-response', \"Invalid Model response: \" + JSON.stringify(model));\n    }\n\n    var tmpModel = deep_copy_1.deepCopy(model); // If tflite Model is specified, it must have a source consisting of\n    // oneof {gcsTfliteUri, automlModel}\n\n    if (model.tfliteModel && !validator.isNonEmptyString(model.tfliteModel.gcsTfliteUri) && !validator.isNonEmptyString(model.tfliteModel.automlModel)) {\n      // If we have some other source, ignore the whole tfliteModel.\n      delete tmpModel.tfliteModel;\n    } // Remove '@type' field. We don't need it.\n\n\n    if (tmpModel['@type']) {\n      delete tmpModel['@type'];\n    }\n\n    return tmpModel;\n  };\n\n  return Model;\n}();\n\nexports.Model = Model;\n\nfunction extractModelId(resourceName) {\n  return resourceName.split('/').pop();\n}","map":null,"metadata":{},"sourceType":"script"}